<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[Apigee] APIM Policy 實作多API backend 導流設計 | Conditional Routing of APIs Based on Feature Flag</title>
    <url>/2020/09/20/Apigee-APIM-Policy-%E5%AF%A6%E4%BD%9C%E5%A4%9AAPI-backend-%E5%B0%8E%E6%B5%81%E8%A8%AD%E8%A8%88-Conditional-Routing-of-APIs-Based-on-Feature-Flag/</url>
    <content><![CDATA[<h1 id="Purpose"><a href="#Purpose" class="headerlink" title="Purpose"></a>Purpose</h1><p><img src="Untitled.png" alt="Untitled.png"></p>
<p>Apigee提供一個更強的方法，使用同一個proxy endpoint保留不變，異動的是後端的Target Endpoint，如此可以使<code>route-rule</code>讓流量導向新版v2</p>
<p><img src="Untitled1.png" alt="Untitled1.png"></p>
<hr>
<h1 id="Prepare-Target-Point"><a href="#Prepare-Target-Point" class="headerlink" title="Prepare Target Point"></a>Prepare Target Point</h1><h3 id="step1-deploy-Proxy-Product"><a href="#step1-deploy-Proxy-Product" class="headerlink" title="step1. deploy Proxy, Product"></a>step1. deploy Proxy, Product</h3><ul>
<li>script 執行前請先準備好, Apigee account, password, organization 供環境變數使用</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://storage.googleapis.com/apigee-quest/scripts/lab13.rewind.sh</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">./lab13.rewind.sh</span></pre></td></tr></table></figure>

<p>執行script畫面</p>
<p><img src="Untitled2.png" alt="Untitled2.png"></p>
<h3 id="step2-Check-proxy-with-lab13"><a href="#step2-Check-proxy-with-lab13" class="headerlink" title="step2. Check proxy with lab13"></a>step2. Check proxy with lab13</h3><ul>
<li>檢查script 部署的proxy, product, apps</li>
</ul>
<p>proxy &gt; done</p>
<p><img src="Untitled3.png" alt="Untitled3.png"></p>
<p>product &gt; done</p>
<p><img src="Untitled4.png" alt="Untitled4.png"></p>
<p>Apps &gt; done</p>
<p><img src="Untitled5.png" alt="Untitled5.png"></p>
<h3 id="step3-Save-Apps-key"><a href="#step3-Save-Apps-key" class="headerlink" title="step3. Save Apps key"></a>step3. Save Apps key</h3><ul>
<li>保存Apps產生的<code>key</code>，供後面API測試</li>
</ul>
<p><img src="Untitled6.png" alt="Untitled6.png"></p>
<h1 id="Integrate-Stackdriver-Add-Extension-Policy-to-your-API"><a href="#Integrate-Stackdriver-Add-Extension-Policy-to-your-API" class="headerlink" title="Integrate Stackdriver Add Extension Policy to your API"></a>Integrate Stackdriver Add Extension Policy to your API</h1><ul>
<li>整合GCP monitoring，可以把API operation records 送進stackdriver管理</li>
<li>操作流程：新增Stackdirver extension: Proxy Endpoints → PreFlow → <code>+Step</code></li>
<li>並改寫以下xml 內官，*記得換你自已專案的名字<code>&quot;PROJECT_ID_HERE&quot;</code></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Input</span>&gt;</span>&lt;![CDATA[</span></pre></td></tr><tr><td class="code"><pre><span class="line">         &#123;  "logName": "example-log",</span></pre></td></tr><tr><td class="code"><pre><span class="line">            "resource": &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                "type": "global",</span></pre></td></tr><tr><td class="code"><pre><span class="line">                "labels": &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    "project_id": "PROJECT_ID_HERE"</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            "message": &#123;"Action": "&#123;request.verb&#125;", "ClientIP": "&#123;client.ip&#125;", "responsePayload": &#123;response.content&#125;,  "Apiproxyname": "&#123;apiproxy.name&#125;"&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     ]]&gt;<span class="tag">&lt;/<span class="name">Input</span>&gt;</span></span></pre></td></tr></table></figure>

<p>xml 修改示意圖</p>
<p><img src="Untitled7.png" alt="Untitled7.png"></p>
<h1 id="Provide-alternate-flow-logic-for-the-cloud-as-a-target"><a href="#Provide-alternate-flow-logic-for-the-cloud-as-a-target" class="headerlink" title="Provide alternate flow logic for the cloud as a target"></a>Provide alternate flow logic for the cloud as a target</h1><ul>
<li>重點來了，除了原有default target backend之外，在外加<code>新的backend</code></li>
<li><code>Target Endpoints</code> 新增一個名為<code>cloud</code>(new target endpoint)</li>
</ul>
<h3 id="step1"><a href="#step1" class="headerlink" title="step1."></a>step1.</h3><ul>
<li>請在Target Endpoints → 點選”+” 為其新增一個Target Endpooint</li>
</ul>
<p><img src="Untitled8.png" alt="Untitled8.png"></p>
<h3 id="step2"><a href="#step2" class="headerlink" title="step2."></a>step2.</h3><ul>
<li>命名：<code>cloud</code></li>
<li>Target：<a href="http://cloud.hipster.s.apigee.com/products" target="_blank" rel="noopener">http://cloud.hipster.s.apigee.com/products</a></li>
</ul>
<p><img src="Untitled9.png" alt="Untitled9.png"></p>
<h3 id="step3-Check-2nd-TargetEndpoint"><a href="#step3-Check-2nd-TargetEndpoint" class="headerlink" title="step3. Check 2nd TargetEndpoint"></a>step3. Check 2nd TargetEndpoint</h3><ul>
<li>現在可以看到Target Endpoints有二個分別為<ul>
<li><code>default</code></li>
<li><code>cloud</code></li>
</ul>
</li>
</ul>
<p><img src="Untitled10.png" alt="Untitled10.png"></p>
<ul>
<li><p>檢視一下新 TargetEndpoint<br>API會顯示簡單的products ID, description etc.</p>
<p>  <a href="http://cloud.hipster.s.apigee.com/products" target="_blank" rel="noopener">http://cloud.hipster.s.apigee.com/products</a></p>
<p>  <img src="Untitled11.png" alt="Untitled11.png"></p>
</li>
</ul>
<h3 id="step4-Cloud-Target-Add-“Assign-Message”"><a href="#step4-Cloud-Target-Add-“Assign-Message”" class="headerlink" title="step4. Cloud Target Add “Assign Message”"></a>step4. Cloud Target Add “Assign Message”</h3><ul>
<li>要在cloud 上加上policy<code>&quot;Assign Message&quot;</code>，並且名為<code>Keep Target URL</code></li>
<li>“Assign Message”目的為 response content 可以清楚Target Endpoint 是來自<code>cloud</code></li>
</ul>
<p><img src="Untitled12.png" alt="Untitled12.png"></p>
<p>新增policy <code>&quot;Assign Message&quot;</code></p>
<p><img src="Untitled13.png" alt="Untitled13.png"></p>
<h3 id="step5-Check"><a href="#step5-Check" class="headerlink" title="step5. Check"></a>step5. Check</h3><ul>
<li>對針<code>&quot;Assign Message&quot;</code>修改policy</li>
</ul>
<p><img src="Untitled14.png" alt="Untitled14.png"></p>
<p>編輯 xml</p>
<ul>
<li>透過<DisplayName><code>Keep Target URL</code></DisplayName></li>
<li>其中也使用了<Name><code>target.copy.queryparams</code></Name> 取環境變數</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">AssignMessage</span> <span class="attr">async</span>=<span class="string">"false"</span> <span class="attr">continueOnError</span>=<span class="string">"false"</span> <span class="attr">enabled</span>=<span class="string">"true"</span> <span class="attr">name</span>=<span class="string">"Keep-Target-URL"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">DisplayName</span>&gt;</span>Keep Target URL<span class="tag">&lt;/<span class="name">DisplayName</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">AssignVariable</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">Name</span>&gt;</span>target.copy.pathsuffix<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">Value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">Value</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">AssignVariable</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">AssignVariable</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">Name</span>&gt;</span>target.copy.queryparams<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">Value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">Value</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">AssignVariable</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">IgnoreUnresolvedVariables</span>&gt;</span>true<span class="tag">&lt;/<span class="name">IgnoreUnresolvedVariables</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">AssignTo</span> <span class="attr">createNew</span>=<span class="string">"false"</span> <span class="attr">transport</span>=<span class="string">"http"</span> <span class="attr">type</span>=<span class="string">"request"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">AssignMessage</span>&gt;</span></span></pre></td></tr></table></figure>

<p>編輯完的畫面如下 </p>
<p>This new policy has rules to prevent changes to the Target Endpoint URL.</p>
<p><img src="Untitled15.png" alt="Untitled15.png"></p>
<h3 id="step6-default-Target-Add-a-“Route-rule”"><a href="#step6-default-Target-Add-a-“Route-rule”" class="headerlink" title="step6. default Target Add a “Route rule”"></a>step6. default Target Add a “Route rule”</h3><ul>
<li>請在<code>Proxy Endpoints.default</code>新增路由新的Target Endpoint(cloud)</li>
<li>詳細路徑 <code>*Proxy Endpoint</code> &gt; default &gt; PreFlow</li>
</ul>
<p><img src="Untitled16.png" alt="Untitled16.png"></p>
<h3 id="step7-check-2-RouteRule"><a href="#step7-check-2-RouteRule" class="headerlink" title="step7. check 2 RouteRule"></a>step7. check 2 <code>RouteRule</code></h3><ul>
<li><code>RouteRule</code>:<ol>
<li>cloud 新增的</li>
</ol>
  *這邊塞入xml <code>verifyapikey.verify-api-key.platform equals &quot;cloud&quot;</code> 規擇，可根據API key的不同導向至不同的Target Endpoint<ol start="2">
<li>default 即有的</li>
</ol>
</li>
</ul>
<p><img src="Untitled17.png" alt="Untitled17.png"></p>
<ul>
<li><p>Overview</p>
<p>  新增完cloud，請確認有2個Target Endpoints存在</p>
</li>
</ul>
<p><img src="Untitled18.png" alt="Untitled18.png"></p>
<h3 id="step8-Deployment-to-test"><a href="#step8-Deployment-to-test" class="headerlink" title="step8. Deployment to test"></a>step8. Deployment to test</h3><ul>
<li>以上的policy 新增修改，請部署至 <strong>test 環境</strong></li>
<li>另外也請確認latest revision.</li>
</ul>
<p><img src="Untitled19.png" alt="Untitled19.png"></p>
<h1 id="Flag-the-developer-app-to-route-its-calls-to-the-cloud"><a href="#Flag-the-developer-app-to-route-its-calls-to-the-cloud" class="headerlink" title="Flag the developer app to route its calls to the cloud"></a>Flag the developer app to route its calls to the cloud</h1><p>Apps Custom Attributes 可以增加key:value值來辨識背後的API backend</p>
<ul>
<li>請至Apps: <code>lab13-Product-App</code></li>
<li>編輯 &gt; <code>Custom Attributes</code><ul>
<li>Name: <code>platform</code></li>
<li>Value: <code>cloud</code></li>
</ul>
</li>
</ul>
<h3 id="step1-edit"><a href="#step1-edit" class="headerlink" title="step1. edit"></a>step1. edit</h3><p><img src="Untitled20.png" alt="Untitled20.png"></p>
<h3 id="step2-Custom-Attributes"><a href="#step2-Custom-Attributes" class="headerlink" title="step2. Custom Attributes"></a>step2. Custom Attributes</h3><ul>
<li>Key-value pairs值可更細微對API Target backend控制</li>
</ul>
<p><img src="Untitled21.png" alt="Untitled21.png"></p>
<h1 id="Create-a-new-app-that-remains-routed-to-the-legacy-backend"><a href="#Create-a-new-app-that-remains-routed-to-the-legacy-backend" class="headerlink" title="Create a new app that remains routed to the legacy backend"></a>Create a new app that remains routed to the legacy backend</h1><p>為了實驗不同的API key 導向不同的Target Endpoint，因此我們新增第二個Apps</p>
<ul>
<li>請至  Publish &gt; Apps 命名為<code>Legacy App</code></li>
<li>Product 同樣納入 <code>lab13-cataloh-Products</code></li>
</ul>
<h3 id="step1-legacy-App"><a href="#step1-legacy-App" class="headerlink" title="step1. legacy App"></a>step1. legacy App</h3><p><img src="Untitled22.png" alt="Untitled22.png"></p>
<h3 id="step2-Get-2nd-key"><a href="#step2-Get-2nd-key" class="headerlink" title="step2. Get 2nd key"></a>step2. Get 2nd key</h3><ul>
<li>取得新的Apps Key</li>
</ul>
<p><img src="Untitled23.png" alt="Untitled23.png"></p>
<h1 id="API-Diagnostics-Trace-Tool"><a href="#API-Diagnostics-Trace-Tool" class="headerlink" title="API Diagnostics: Trace Tool"></a>API Diagnostics: Trace Tool</h1><p>以上的準備都是為此的測試，這邊請先收錄二隻Apps key，而Target Endpoint目標都是同一個</p>
<h3 id="step1-Track-calls-with-Trace"><a href="#step1-Track-calls-with-Trace" class="headerlink" title="step1. Track calls with Trace"></a>step1. Track calls with Trace</h3><ul>
<li>Develop &gt; API Proxies &gt; lab13-catalog proxy</li>
<li>/products?apikey=[API-KEY -01]</li>
<li>/products?apikey=[API-KEY -02]</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#key1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">https://joeuang-eval-test.apigee.net/lab13-catalog/v1/products?apikey=YiXXXXXXtN</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#key2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">https://joehuang-eval-test.apigee.net/lab13-catalog/v1/products?apikey=bcLXXXXXX5ih</span></pre></td></tr></table></figure>

<h3 id="step2-1st-API-Key-as-the-value-of-the-apikey-query-parameter"><a href="#step2-1st-API-Key-as-the-value-of-the-apikey-query-parameter" class="headerlink" title="step2. 1st API Key as the value of the apikey query parameter."></a>step2. 1st API Key as the value of the apikey query parameter.</h3><ul>
<li>第一把 API Key的測試，得到 response 200</li>
<li>且在Target Requests 得到<code>&quot;Keep Target URL&quot;</code>，代並這次的requst是打<code>cloud</code></li>
</ul>
<p><img src="Untitled24.png" alt="Untitled24.png"></p>
<p>問題#1 為什麼Apps custome attributes 可以判斷不同的Target Endpoints？</p>
<ul>
<li>因為我們有<code>condition flow</code> 其中expression 可以幫忙比對content內容</li>
</ul>
<p><img src="Untitled25.png" alt="Untitled25.png"></p>
<p>還記得剛才設定的custome attributes 這個<code>flag</code>，就是透過condition flow幫忙比對的</p>
<p><img src="Untitled26.png" alt="Untitled26.png"></p>
<h3 id="step3-2nd-API-Key-as-the-value-of-the-apikey-query-parameter"><a href="#step3-2nd-API-Key-as-the-value-of-the-apikey-query-parameter" class="headerlink" title="step3. 2nd API Key as the value of the apikey query parameter."></a>step3. 2nd API Key as the value of the apikey query parameter.</h3><ul>
<li>第二把 API Key的測試，得到同樣得到 response 200</li>
<li>但是這次的Target Endpoint是不一樣的，請注意是”default”</li>
</ul>
<p><img src="Untitled27.png" alt="Untitled27.png"></p>
<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>服務在更版時候，我們常用藍綠部署(Blue Green Deployment)，可以保證系統在不間斷提供服務的情況下，上新版的部署方式，一般會在Load balance上實作。現在我們了解Apigee polocy 方法可以實作multiple Target，如此我們就可以鎖定同樣的proxy endpoint。透過修改APIM policy增加不同的API Endpoint，可將流量導到不同的版本的API backend(default, cloud)。方法是透過<code>Condition flow</code> 偵查不同組的API Key (key1, key2)，可以將流量轉發到不同的服務上(Target Endpoints)。</p>
<p>此作法可較過去更有彈性，怎麼說呢？因為我們二邊的Target Endpoints，不僅都保留住，只要不同的API key，還都能通往到目的地。如果你是developer, system administrator 對APIM 有興趣妨可以考慮更彈的管理版本部署方法。</p>
]]></content>
      <categories>
        <category>APIM</category>
      </categories>
      <tags>
        <tag>APIGEE</tag>
        <tag>BLUE GREEN DEPLOYMENT</tag>
        <tag>MULTIPLE TARGET ENDPOINT</tag>
        <tag>API GATEWAY</tag>
        <tag>APIM</tag>
      </tags>
  </entry>
  <entry>
    <title>[GCP] Cloud Run 六個實作: 解析麻雀雖小五臟俱全 | Cloud Run is Small but Complete</title>
    <url>/2020/05/01/GCP-Cloud-Run-%E5%85%AD%E5%80%8B%E5%AF%A6%E4%BD%9C-%E8%A7%A3%E6%9E%90%E9%BA%BB%E9%9B%80%E9%9B%96%E5%B0%8F%E4%BA%94%E8%87%9F%E4%BF%B1%E5%85%A8-Cloud-Run-is-Small-but-Complete/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p><code>Serverless</code>(無伺服器)具有易用且快速的特性，讓使用者享<code>managed</code>好處，而不需要理會基礎設施的配置，就能快速的建立應用程式，這點是大家都知道的。</p>
<p>但一般的Serverless也有其限制，包括Runtime支援不足或是遭特定廠商綁住等缺點，這些缺點卻是容器的優點，因容器更具有靈活性與可移植性，而Google的Cloud Run則是結合兩者，讓使用者可以在無伺服器平臺上執行容器。本篇分享 <code>Cloud Run</code> 一點實作的經驗跟心得，如果要我用一句來形容<code>Cloud Run</code>，我會說「麻雀雖小五臟俱全」，那麼究竟有那五臟呢？</p>
<h2 id="1-Serverless-Container"><a href="#1-Serverless-Container" class="headerlink" title="1. Serverless + Container"></a>1. Serverless + Container</h2><hr>
<h3 id="問題-前言"><a href="#問題-前言" class="headerlink" title="問題 / 前言"></a>問題 / 前言</h3><ul>
<li><p>過去一般使用<code>Serverless</code>服務時，常會碰到程式語言、程式版本僅有固定版本<br>或是套件不匹配等情況</p>
</li>
<li><p>Cloud Run的出現，可以解決原生serverless，對於以上程式與套件的限制<br>官方是這樣描述Cloud Run features</p>
<blockquote>
<p>Any language, any library, any binary</p>
</blockquote>
</li>
</ul>
<h3 id="作法-實做"><a href="#作法-實做" class="headerlink" title="作法 / 實做"></a>作法 / 實做</h3><ul>
<li>透過docker build，建立自已的docker image</li>
<li>運行自已的docker image，部署至Cloud Run<br>此時，可以享用google managed platform托管服務，完完全全不理管後台的維護，只需要管好每次的新的docker build 版本</li>
</ul>
<p>從下面的示意圖可以看出幾點</p>
<ul>
<li><p>來源可以從自已project Cloud Build</p>
</li>
<li><p>developer 可以從Trigger動作，或是由 internet 直接操作Cloud Run</p>
<p>  <img src="Untitled.png" alt="Untitled.png"></p>
</li>
</ul>
<p>Steps1. </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 建立一個docker build 測試用的image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">student_00_44cb0fa3b714@cloudshell:$ docker build . --tag=test1</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">gcloud builds submit --tag gcr.io/<span class="variable">$&#123;GOOGLE_CLOUD_PROJECT&#125;</span>/monolith:1.0.0 .</span></pre></td></tr></table></figure>

<p>dockerfile 內容</p>
<p><img src="Untitled1.png" alt="Untitled1.png"></p>
<p>Steps2.  docker build 完成</p>
<p><img src="Untitled2.png" alt="Untitled2.png"></p>
<ul>
<li><p>有docker build, 也有<code>gcloud build</code>阿阿阿</p>
<p>  <img src="Untitled3.png" alt="Untitled3.png"></p>
</li>
<li><p>驗證剛剛build image</p>
<p>  <img src="Untitled4.png" alt="Untitled4.png"></p>
</li>
</ul>
<p>Steps3. Deploy Container To Cloud Run</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 部署cloud run</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">gcloud run deploy --image=gcr.io/<span class="variable">$&#123;GOOGLE_CLOUD_PROJECT&#125;</span>/monolith:1.0.0 --platform managed</span></pre></td></tr></table></figure>

<p><img src="Untitled5.png" alt="Untitled5.png"></p>
<h3 id="結果"><a href="#結果" class="headerlink" title="結果"></a>結果</h3><ul>
<li>檢視剛剛生出來的Cloud Run</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># list out current microservice</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">gcloud run services list</span></pre></td></tr></table></figure>

<ul>
<li><p>一個名為<code>monolith</code> microservice就是剛剛所建立的</p>
<p>  <img src="Untitled6.png" alt="Untitled6.png"></p>
</li>
</ul>
<p>驗證 Service</p>
<ul>
<li><p>取得 URL</p>
</li>
<li><p>驗證 microservice 是否works</p>
<p>  <img src="Untitled7.png" alt="Untitled7.png"></p>
</li>
</ul>
<p>可以看到網頁的結果<br>Welcome to the Fancy Store!</p>
<p><img src="Untitled8.png" alt="Untitled8.png"></p>
<h2 id="2-流量管理：原生功能，不用基於外部Load-Balance"><a href="#2-流量管理：原生功能，不用基於外部Load-Balance" class="headerlink" title="2. 流量管理：原生功能，不用基於外部Load Balance"></a>2. 流量管理：原生功能，不用基於外部Load Balance</h2><hr>
<h3 id="問題-前言-1"><a href="#問題-前言-1" class="headerlink" title="問題 / 前言"></a>問題 / 前言</h3><ul>
<li>如果是使用一般的<code>GCE</code>，都需要搭配Load  Balance才能達到流量管理</li>
<li>使用Cloud Run 則不用，因為它內建了”流量管理”</li>
</ul>
<h3 id="作法-實做-1"><a href="#作法-實做-1" class="headerlink" title="作法 / 實做"></a>作法 / 實做</h3><p>step1. 點選 <code>Actions: traffic</code> 進行流量的管理</p>
<p><img src="Untitled9.png" alt="Untitled9.png"></p>
<p>step2. 輸入期望的traffic 百分比</p>
<p>分流設定: 0001-duk: <code>20%</code></p>
<p><img src="Untitled10.png" alt="Untitled10.png"></p>
<p>step3. 使用<code>Apache ab tool</code> 進行測試</p>
<ul>
<li>目標皆為<code>monolith-cjsbhbijjq-de.a.run.app</code></li>
<li>但實際上會流量會分到二隻microservice <code>001-duk</code>, <code>002-zey</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Apache ab stressking</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ab -n 10000 -c 10 <span class="variable">$WEB</span></span></pre></td></tr></table></figure>

<p><img src="Untitled11.png" alt="Untitled11.png"></p>
<h3 id="結果-1"><a href="#結果-1" class="headerlink" title="結果"></a>結果</h3><p>打開monitoring檢視</p>
<ul>
<li><p>0001-duk, 0002-zey 皆有流量進入</p>
<p>  <img src="Untitled12.png" alt="Untitled12.png"></p>
</li>
</ul>
<h2 id="3-Cloud-Run-像是更-Free-版的-Cloud-Functions"><a href="#3-Cloud-Run-像是更-Free-版的-Cloud-Functions" class="headerlink" title="3. Cloud Run 像是更 Free 版的 Cloud Functions"></a>3. Cloud Run 像是更 Free 版的 Cloud Functions</h2><hr>
<h3 id="問題-前言-2"><a href="#問題-前言-2" class="headerlink" title="問題 / 前言"></a>問題 / 前言</h3><ul>
<li>一般的<code>Serverless</code>也有其限制，包括<code>Runtime</code>支援不足，這些缺點卻是容器的優點，因為容器更具有靈活性與可移植性，Cloud Run則是<strong>“結合兩者”</strong>，讓使用者可以在無伺服器平臺上執行容器</li>
<li><code>Cloud Run</code> 適用於任何程式語言，也不會綁死在某雲端平台</li>
</ul>
<h3 id="作法-實做-2"><a href="#作法-實做-2" class="headerlink" title="作法 / 實做"></a>作法 / 實做</h3><ul>
<li>透過docker build, gcloud build的image都可以當作 Cloud Run的<code>runtime</code>的bases</li>
</ul>
<p>step1. docker build</p>
<ul>
<li>將image，存放在cloud shell之中</li>
</ul>
<p><img src="Untitled2.png" alt="Untitled2.png"></p>
<p>step2. gcloud build</p>
<ul>
<li><p>將image，存放在gcr.io，它是GCP Container Registry位置</p>
<p>  <img src="Untitled3.png" alt="Untitled3.png"></p>
</li>
</ul>
<h3 id="結果-2"><a href="#結果-2" class="headerlink" title="結果"></a>結果</h3><ul>
<li>Cloud Run 的好處，就是可以選自已build image</li>
<li>其中gcr.io/qwiklabs-gcp-02-7ef52e609d63/helloworld，是即是GCP Container Registry位置</li>
<li>部署Cloud Run指令為 gcloud beta run deploy，再加上image位置</li>
<li>Service名稱和位置是在部署中再補上</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># gcr.io path</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">gcr.io/qwiklabs-gcp-02-7ef52e609d63/helloworld</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># cloud run</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">gcloud beta run deploy --image gcr.io/qwiklabs-gcp-02-7ef52e609d63/helloworld</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 需外額外的參數</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">--platform managed \</span></pre></td></tr><tr><td class="code"><pre><span class="line">--region us-central1 \</span></pre></td></tr><tr><td class="code"><pre><span class="line">--allow-unauthenticated</span></pre></td></tr></table></figure>

<ul>
<li><p>hello-v1 service 已成功部署</p>
</li>
<li><p>gcloud run 運行時需要提供以下資訊</p>
<ul>
<li><p>Service 名稱和位置</p>
</li>
<li><p>Unauthenticated 是否允許非驗驗證模式的存取</p>
<p><img src="Untitled13.png" alt="Untitled13.png"></p>
</li>
</ul>
</li>
</ul>
<h2 id="4-Cloud-Functions-可以綁自已的domain"><a href="#4-Cloud-Functions-可以綁自已的domain" class="headerlink" title="4. Cloud Functions 可以綁自已的domain"></a>4. Cloud Functions 可以綁自已的domain</h2><hr>
<h3 id="問題-前言-3"><a href="#問題-前言-3" class="headerlink" title="問題 / 前言"></a>問題 / 前言</h3><ul>
<li><p>Cloud Run 提供的full managed 服務可以直接產出<code>URL</code>，供連線測試</p>
</li>
<li><p>但有很多情境會需要使用自已的<code>domain</code></p>
<p>  e.g. <code>CDN</code>情境就是<code>CNAME</code>也讓CDN幫忙托管，因此流量就可以先經由CDN加速，再到Cloud Run Service</p>
</li>
</ul>
<h2 id="作法-實做-3"><a href="#作法-實做-3" class="headerlink" title="作法 / 實做"></a>作法 / 實做</h2><p>step1. 在原本的URL 旁邊點選<code>Manage custom domains</code></p>
<p><img src="Untitled14.png" alt="Untitled14.png"></p>
<p>step2. 輸入domain名字，以<a href="http://joehuang.nctu.me/" target="_blank" rel="noopener"><code>joehuang.nctu.me</code></a> 為例</p>
<p><img src="Untitled15.png" alt="Untitled15.png"></p>
<p>step3. 驗證domain</p>
<ul>
<li><p>小弟使用的免費交通大學二級的<code>DNS</code> <a href="http://joehuang.nctu.me/" target="_blank" rel="noopener">nctu.me</a>.，因此沒有在清單之中<br>(e.g Godday 之類大牌的DNS, 是可以直接以帳密登入做驗證服務)</p>
</li>
<li><p>因為沒有在清單之中<br>選擇 <code>other</code> 做驗證，驗證方法有二新增<code>TXT</code>, <code>CNAME</code> 二種</p>
<ul>
<li><p>a. 新增TXT<br>Add the TXT record below to the DNS configuration for <a href="http://joehuang.nctu.me/" target="_blank" rel="noopener">joehuang.nctu.me</a>.</p>
<p>  <img src="Untitled16.png" alt="Untitled16.png"></p>
</li>
</ul>
</li>
<li><p>b. 新增 CNAME</p>
<p>  <img src="Untitled17.png" alt="Untitled17.png"></p>
</li>
</ul>
<p>step4. 確認domain 是否驗證成功</p>
<p><img src="Untitled18.png" alt="Untitled18.png"></p>
<p>step5. 增加<code>hello-run-v1</code> 在<a href="http://joehuang.nctu.me/" target="_blank" rel="noopener"><code>joehuang.nctu.me</code></a> 這個網域</p>
<p><img src="Untitled15.png" alt="Untitled15.png"></p>
<p>step6. 驗證DNS 同步</p>
<p>a. dig</p>
<ul>
<li><p>使用<code>dig</code>, 第一要確認的是<code>status</code> 是否為NOERROR</p>
</li>
<li><p>再確認, <code>[ghs.googlehosted.com](http://ghs.googlehosted.com)</code> ，有沒有解析出 IP(216.58.200.51)</p>
<p>  <img src="Untitled19.png" alt="Untitled19.png"></p>
</li>
</ul>
<p>b. DNSCHECKER</p>
<ul>
<li><p>如果覺得本機<code>dig</code>，會有cache影響</p>
</li>
<li><p>可以選用<code>DNSCHECKER</code>，去除本機cahce的影響<br>結果在各國DNS都可以解析到<a href="http://joehuang.nctu.me/" target="_blank" rel="noopener"><code>hello-run-v1.oehuang.nctu.me</code></a></p>
<p>  <img src="Untitled20.png" alt="Untitled20.png"></p>
</li>
</ul>
<p>c. 檢視Cloud Run: <code>DNS Records</code></p>
<ul>
<li><p>可以看到hello-run-v1 已經有被<code>ghs.googlehosted.com</code>托管</p>
<p>  <img src="Untitled21.png" alt="Untitled21.png"></p>
</li>
</ul>
<h3 id="結果-3"><a href="#結果-3" class="headerlink" title="結果"></a>結果</h3><ul>
<li><p>現在可以連線新的domain</p>
<p>  在browser 上連線<a href="http://joehuang.nctu.me/" target="_blank" rel="noopener"><code>hello-run-v1.oehuang.nctu.me</code></a><br>  可以看到與原本<a href="https://hello-run-v1-ve3udnlh4q-uc.a.run.app/" target="_blank" rel="noopener"><code>hello-run-v1-ve3udnlh4q-uc.a.run.app</code></a>看到的頁面是一樣的</p>
<p>  <img src="Untitled22.png" alt="Untitled22.png"></p>
</li>
</ul>
<h2 id="5-Cloud-Run-還有跟-GAE-一樣的”版本切換”-比-Cloud-Functions-有更多的彈性"><a href="#5-Cloud-Run-還有跟-GAE-一樣的”版本切換”-比-Cloud-Functions-有更多的彈性" class="headerlink" title="5. Cloud Run 還有跟 GAE 一樣的”版本切換” 比 Cloud Functions 有更多的彈性"></a>5. Cloud Run 還有跟 GAE 一樣的”版本切換” 比 Cloud Functions 有更多的彈性</h2><hr>
<h3 id="問題-前言-4"><a href="#問題-前言-4" class="headerlink" title="問題 / 前言"></a>問題 / 前言</h3><p>Cloud Run承習<code>Cloud App Engine (GAE)</code> 二個特性<br>Cloud Run 還有跟 GAE 一樣的版本切換、流量管理功能，因此在管理上比 <code>Cloud Functions</code> 有更多的彈性</p>
<ul>
<li><p><strong>應用程式版本設定</strong></p>
<p>  輕鬆託管應用程式的各種不同版本，讓user不費吹灰之力即可建立開發、測試、準備和實際工作環境</p>
</li>
<li><p><strong>流量拆分</strong></p>
<p>  將連入要求導向不同的應用程式版本、快速執行 A/B 測試，並以漸進方式發布功能</p>
</li>
</ul>
<h3 id="作法-實做-4"><a href="#作法-實做-4" class="headerlink" title="作法 / 實做"></a>作法 / 實做</h3><ul>
<li>直接部署新版，比方說新上版服務，或是改了新的<code>dockerfile</code></li>
<li>可以直接用更版過的<code>image</code></li>
</ul>
<p>step1. 直接餵新的image</p>
<p>Container image URL 餵更版過的<code>image</code>, 可以部署在相同的managed service</p>
<ul>
<li>優勢一：可以延用<code>endpoint</code>，不會作任何的更動</li>
<li>優勢二：直接100% 切換至新版的service</li>
</ul>
<p><img src="Untitled23.png" alt="Untitled23.png"></p>
<h3 id="結果-4"><a href="#結果-4" class="headerlink" title="結果"></a>結果</h3><ul>
<li><p>延用<code>endpoint</code>，直接100% 切換流量至新版的microservice</p>
</li>
<li><p>如此就很方便developer做 <code>A/B</code> 測試</p>
<p>  <img src="Untitled24.png" alt="Untitled24.png"></p>
</li>
</ul>
<h2 id="6-支援混雲合-Anthos環境"><a href="#6-支援混雲合-Anthos環境" class="headerlink" title="6. 支援混雲合 Anthos環境"></a>6. 支援混雲合 Anthos環境</h2><hr>
<h3 id="問題-前言-5"><a href="#問題-前言-5" class="headerlink" title="問題 / 前言"></a>問題 / 前言</h3><ul>
<li><p>原生的Cloud Run 也有其限制，CPU 2核心、memroy上限是2GB</p>
</li>
<li><p>如果想要保留移植性，並解決運算資源的限制，要怎麼做呢？</p>
<p>  答案就是啟用<code>Anthos</code>，它是Google混合雲的solution</p>
</li>
<li><p>讓Cloud Run原本部署為full managed，增加了<code>多雲</code>的選擇</p>
<p>  多雲可以是</p>
<ul>
<li>是雲上的<code>Google Kubernetes Engine (GKE)</code></li>
<li>更可以是地端的<code>Anthos (GKE on-prem)</code></li>
</ul>
</li>
</ul>
<h3 id="作法-實做-5"><a href="#作法-實做-5" class="headerlink" title="作法 / 實做"></a>作法 / 實做</h3><p>二個步驟</p>
<ul>
<li>第一host 端：也就是Google Kubernetes Engine(GKE)，<code>**啟用Anthos</code>**</li>
<li>第二deploy端：Cloud Run上的設定，選擇<strong>部署在<code>Anthos</code></strong></li>
</ul>
<p>step1. 雲上的<code>GKE</code>：GKE的設定</p>
<ul>
<li><p>GKE 環境中，啟用Cloud Run for Anthos即可</p>
<p>  <img src="Untitled25.png" alt="Untitled25.png"></p>
</li>
</ul>
<p>step2. Cloud Run</p>
<ul>
<li>環境部署：選擇<code>現有的GKE環境</code>，依圖示有偵測到<code>run-gke2-us-central1-a</code> 這個cluster有啟用<code>Anthos</code> (Cloud Run for Anthos)</li>
<li>docker image：選用demo hello</li>
</ul>
<p><img src="Untitled26.png" alt="Untitled26.png"></p>
<ul>
<li>在選定啟用 Anthos GKE環境後，再選用demo hello image</li>
</ul>
<p><img src="Untitled27.png" alt="Untitled27.png"></p>
<h3 id="結果-5"><a href="#結果-5" class="headerlink" title="結果"></a>結果</h3><ul>
<li>思考一下，原本是以上面的實驗都是<code>managed</code>全托管的服務</li>
<li>但現在，郤可以在其它你選擇的kubernetes環境，是不是很酷！</li>
</ul>
<p>檢視一下hello app workload</p>
<ul>
<li><p>Cloud Run 成功部署一個 application GKE <code>run-gke2-us-central1-a</code> cluster</p>
<p>  <img src="Untitled28.png" alt="Untitled28.png"></p>
</li>
</ul>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><hr>
<ol>
<li>Deploy Your Website on Cloud Run<br>[<a href="https://www.qwiklabs.com/focuses/10445?catalog_rank={&quot;rank&quot;%3A1%2C&quot;num_filters&quot;%3A0%2C&quot;has_search&quot;%3Atrue}&amp;parent=catalog&amp;search_id=5043953]" target="_blank" rel="noopener">https://www.qwiklabs.com/focuses/10445?catalog_rank={&quot;rank&quot;%3A1%2C&quot;num_filters&quot;%3A0%2C&quot;has_search&quot;%3Atrue}&amp;parent=catalog&amp;search_id=5043953]</a></li>
</ol>
]]></content>
      <categories>
        <category>GCP</category>
      </categories>
      <tags>
        <tag>GCP</tag>
        <tag>Cloud Run</tag>
        <tag>Serverless</tag>
        <tag>Cloud function</tag>
        <tag>Cloud App Engine</tag>
      </tags>
  </entry>
  <entry>
    <title>[Apigee] Portal發佈 APIs 協助開發人員串接服務 | Self Service API Discovery &amp; Sign Up Experience</title>
    <url>/2020/09/20/Apigee-Portal%E7%99%BC%E4%BD%88-APIs-%E5%8D%94%E5%8A%A9%E9%96%8B%E7%99%BC%E4%BA%BA%E5%93%A1%E4%B8%B2%E6%8E%A5%E6%9C%8D%E5%8B%99-Self-Service-API-Discovery-Sign-Up-Experience/</url>
    <content><![CDATA[<h1 id="Purpose"><a href="#Purpose" class="headerlink" title="Purpose"></a>Purpose</h1><p>APIM是為開發人員提供一個簡單、靈活、全受管，且可以處理針對應用程式後端而建立和操作穩固 API 的所有層面。那麼透過 API Management，您可以用較少的投資更快速啟動新服務，以便將重點放在建置核心商業服務上。因為API Management 的建置是可以建制一個Developer Portal透過已編譯過的Open API sepc，供開發者測試API 並掌握各種Response, Parameter設計，以利快速串接API 開發TSP 服務，今天的分享即是在Apigee上刻一個專有 Developer Portal供你的合作廠商測試你的API。</p>
<h1 id="Prepare-Target-Point"><a href="#Prepare-Target-Point" class="headerlink" title="Prepare Target Point"></a>Prepare Target Point</h1><ul>
<li>準備測試用的API backend, API proxy, product, Apps</li>
</ul>
<h3 id="step1-deploy-Proxy-Product"><a href="#step1-deploy-Proxy-Product" class="headerlink" title="step1. deploy Proxy, Product"></a>step1. deploy Proxy, Product</h3><p><img src="Untitled.png" alt="Untitled.png"></p>
<h3 id="step2-Check-proxy-with-lab6"><a href="#step2-Check-proxy-with-lab6" class="headerlink" title="step2. Check proxy with lab6"></a>step2. Check proxy with lab6</h3><p>API proxy &gt; done</p>
<p><img src="Untitled1.png" alt="Untitled1.png"></p>
<p>API products &gt; done</p>
<p><img src="Untitled2.png" alt="Untitled2.png"></p>
<p>Apps &gt; done</p>
<p><img src="Untitled3.png" alt="Untitled3.png"></p>
<h3 id="step3-Export-your-API-Proxy"><a href="#step3-Export-your-API-Proxy" class="headerlink" title="step3. Export your API Proxy"></a>step3. Export your API Proxy</h3><p>這個步驟只是備份用而已，對後面的實作沒有關系</p>
<ul>
<li>請至<code>lab6</code> proxy</li>
<li>確認你的<code>lab6-catalog.xml</code> 檔案是否存在，以及確認APIProxy revision=x name 要等於 =”lab6-catalog”</li>
</ul>
<p><img src="Untitled4.png" alt="Untitled4.png"></p>
<p><img src="Untitled5.png" alt="Untitled5.png"></p>
<h3 id="step4-Create-GCS-and-upload-APIProxy-folder"><a href="#step4-Create-GCS-and-upload-APIProxy-folder" class="headerlink" title="step4. Create GCS and upload APIProxy folder"></a>step4. Create GCS and upload APIProxy folder</h3><p><img src="Untitled6.png" alt="Untitled6.png"></p>
<h1 id="OpenAPI-Sepc"><a href="#OpenAPI-Sepc" class="headerlink" title="OpenAPI Sepc"></a>OpenAPI Sepc</h1><p>上傳Open API 範例至Spec</p>
<h3 id="step1-import-URL"><a href="#step1-import-URL" class="headerlink" title="step1. import URL"></a>step1. import URL</h3><ul>
<li>請至 Develop&gt; Specs &gt; <code>import URL</code></li>
<li>name: Hipster Products API</li>
<li>Import URL: <a href="https://storage.googleapis.com/apigee-quest/data/hipster-products.yml" target="_blank" rel="noopener">https://storage.googleapis.com/apigee-quest/data/hipster-products.yml</a></li>
<li>請修改範例中的{edge-org}的名稱，以利script運行</li>
</ul>
<p><img src="Untitled7.png" alt="Untitled7.png"></p>
<p>記錄Apps KEY</p>
<p><img src="Untitled8.png" alt="Untitled8.png"></p>
<h3 id="step2-Authorize-KEY"><a href="#step2-Authorize-KEY" class="headerlink" title="step2. Authorize KEY"></a>step2. Authorize KEY</h3><ul>
<li>我們在Open Spec頁面中，可以直接測試API</li>
<li>但必預先驗證過Key的值，才能繼續在測試頁面發送request</li>
</ul>
<p><img src="Untitled9.png" alt="Untitled9.png"></p>
<p>驗證 &gt; done</p>
<p><img src="Untitled10.png" alt="Untitled10.png"></p>
<h3 id="step3-Test-Send-out-request"><a href="#step3-Test-Send-out-request" class="headerlink" title="step3. Test Send out request"></a>step3. Test Send out request</h3><p>可以正常發送request</p>
<p><img src="Untitled11.png" alt="Untitled11.png"></p>
<h3 id="認識OpenAPI-Spec-格式"><a href="#認識OpenAPI-Spec-格式" class="headerlink" title="認識OpenAPI Spec 格式"></a>認識OpenAPI Spec 格式</h3><p>#1 <code>basePath</code>:</p>
<p>說在在這個endpoint之下的那一個basePath是可用的</p>
<p><img src="Untitled12.png" alt="Untitled12.png"></p>
<p>#2 <code>securityDefinitions</code>:</p>
<p>說明這隻API 使用的驗證方試為verify API key</p>
<p><img src="Untitled13.png" alt="Untitled13.png"></p>
<p>#3 <code>paths</code>:</p>
<p>說明有實作那些methods</p>
<ul>
<li>description</li>
<li>schema</li>
</ul>
<p><img src="Untitled14.png" alt="Untitled14.png"></p>
<p>#4 <code>definitions</code></p>
<ul>
<li>其中使用了$ref 更細項的<code>definitions</code>，同時也將定義的後面寫在下方</li>
</ul>
<p><img src="Untitled15.png" alt="Untitled15.png"></p>
<p>右側欄的項目，都是來自Open API spec中所定義的<code>definitions</code></p>
<p><img src="Untitled16.png" alt="Untitled16.png"></p>
<h3 id="step3-Test-API"><a href="#step3-Test-API" class="headerlink" title="step3. Test API"></a>step3. Test API</h3><ul>
<li>測試API，得到 200 response</li>
<li>同時也得到完整的response structure</li>
</ul>
<p><img src="Untitled17.png" alt="Untitled17.png"></p>
<p>測試結果如下</p>
<p>response results</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">"products"</span>: [</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">"id"</span>: <span class="string">"OLJCESPC7Z"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">"name"</span>: <span class="string">"Vintage Typewriter"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">"description"</span>: <span class="string">"This typewriter looks good in your living room."</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>#1 In console畫面可得到如下</p>
<p><img src="Untitled18.png" alt="Untitled18.png"></p>
<p>#2 terminal curl方法測試</p>
<p><img src="Untitled19.png" alt="Untitled19.png"></p>
<p>#3 HTTP 方法測試</p>
<p><img src="Untitled20.png" alt="Untitled20.png"></p>
<h1 id="API-Publishing-Developer-Portal"><a href="#API-Publishing-Developer-Portal" class="headerlink" title="API Publishing: Developer Portal"></a>API Publishing: Developer Portal</h1><p>完成了SmartDoc 中的測試，接下來我們把API 發佈至public製作一個網站供測試，步驟如下</p>
<h3 id="step1-建立developer-portal"><a href="#step1-建立developer-portal" class="headerlink" title="step1. 建立developer portal"></a>step1. 建立developer portal</h3><ul>
<li><strong>Name:</strong> <code>Demo_Hipster Developer Portal</code></li>
<li><strong>Description</strong>: <code>Developer Portal for Hipster APIs</code></li>
</ul>
<p><img src="Untitled21.png" alt="Untitled21.png"></p>
<p>符合命名</p>
<p><img src="Untitled22.png" alt="Untitled22.png"></p>
<h3 id="step2-加入APIM-內的APIs"><a href="#step2-加入APIM-內的APIs" class="headerlink" title="step2. 加入APIM 內的APIs"></a>step2. 加入APIM 內的APIs</h3><ul>
<li>因為Apigee Edge 版本差異，項目可能為APIs, 亦或是API Catalog</li>
</ul>
<p><img src="Untitled23.png" alt="Untitled23.png"></p>
<p>右上角的 + API</p>
<p><img src="Untitled24.png" alt="Untitled24.png"></p>
<h3 id="step3-3-Follows-to-inest-API"><a href="#step3-3-Follows-to-inest-API" class="headerlink" title="step3. 3 Follows to inest API"></a>step3. 3 Follows to inest API</h3><ul>
<li>選擇API Products</li>
</ul>
<p><img src="Untitled25.png" alt="Untitled25.png"></p>
<ul>
<li>DOCUMENTATION<br>選擇你的Open API Spec</li>
</ul>
<p><img src="Untitled26.png" alt="Untitled26.png"></p>
<p>記得選擇先帶入的Open API Spec 命為<code>Hipster Products API</code></p>
<p><img src="Untitled27.png" alt="Untitled27.png"></p>
<p>確認完成，點選Finish</p>
<p><img src="Untitled28.png" alt="Untitled28.png"></p>
<h3 id="step4-Portal-overview"><a href="#step4-Portal-overview" class="headerlink" title="step4. Portal overview"></a>step4. Portal overview</h3><ul>
<li>回到Portal overvie檢查剛剛加入的Portal</li>
<li>以及選入的API product, API Spec</li>
</ul>
<p><img src="Untitled29.png" alt="Untitled29.png"></p>
<h1 id="Discovering-API-products-on-the-Portal"><a href="#Discovering-API-products-on-the-Portal" class="headerlink" title="Discovering API products on the Portal"></a>Discovering API products on the Portal</h1><h3 id="step1-轉至Developer-portal"><a href="#step1-轉至Developer-portal" class="headerlink" title="step1. 轉至Developer portal"></a>step1. 轉至Developer portal</h3><p>第一次測試，我設定為public，所以不用登入</p>
<p><img src="Untitled30.png" alt="Untitled30.png"></p>
<h3 id="step2-View-APIs"><a href="#step2-View-APIs" class="headerlink" title="step2. View APIs"></a>step2. View APIs</h3><p>請至APIs，查看lab6-catalog-product</p>
<p><img src="Untitled31.png" alt="Untitled31.png"></p>
<p>基本上可以看剛Open API Spec測試頁面一樣的Spec, 以及定義出的structure</p>
<p>Path: <code>/products</code></p>
<p><img src="Untitled32.png" alt="Untitled32.png"></p>
<p>Execute#1 Error no Authorize</p>
<ul>
<li>嘿嘿，這個當然也是要經過驗證身份，若沒有驗證過就會得到error</li>
</ul>
<p><img src="Untitled33.png" alt="Untitled33.png"></p>
<p>Execute#2  Authorize</p>
<ul>
<li>我們乖乖得做完驗證</li>
</ul>
<p><img src="Untitled34.png" alt="Untitled34.png"></p>
<ul>
<li>可以正常送request</li>
</ul>
<p><img src="Untitled35.png" alt="Untitled35.png"></p>
<h1 id="Registering-an-application-on-the-Portal"><a href="#Registering-an-application-on-the-Portal" class="headerlink" title="Registering an application on the Portal"></a>Registering an application on the Portal</h1><p>這次我們要註冊一個user，你可以想像是外部的TSP，要和你們合作開發，正準備進入你們公司的APIs inventory，我們現在把URL提供給他們，只要他們一經驗證就可以進來測試這些你授權的APIs</p>
<h3 id="step1"><a href="#step1" class="headerlink" title="step1."></a>step1.</h3><ul>
<li>Sign In a <code>USER</code>&gt; <code>Create account</code></li>
<li>請至信箱開發認證網址</li>
</ul>
<p><img src="Untitled36.png" alt="Untitled36.png"></p>
<p><img src="Untitled37.png" alt="Untitled37.png"></p>
<p>目前的user是有指定的註冊者身份，請見右上方</p>
<p><img src="Untitled38.png" alt="Untitled38.png"></p>
<h3 id="step2-NEW-APP-to-create-a-new-application"><a href="#step2-NEW-APP-to-create-a-new-application" class="headerlink" title="step2. NEW APP to create a new application."></a>step2. NEW APP to create a new application.</h3><p>有了註冊後的帳號，我們可以就自已建立自已的<code>APIs, key</code>，透過這把key 可以存取自已名下的APIs</p>
<ul>
<li>設定<code>App name</code>, <code>description</code>, 並選入 lab6-catalog-product</li>
<li>確認APIs 的狀態應為 <code>Actives</code></li>
</ul>
<p><strong>App Name:</strong> <code>ProductCatalogApp</code></p>
<p><strong>Description</strong>: <code>Application to manage the product catalog</code></p>
<p><img src="Untitled39.png" alt="Untitled39.png"></p>
<h3 id="step3-Generate-ID-API-Keys"><a href="#step3-Generate-ID-API-Keys" class="headerlink" title="step3. Generate ID, API Keys"></a>step3. Generate ID, API Keys</h3><p>TSP 開發者，有別於Apps key之外，可以有自已<code>key</code>, 當然也有自已的key expires</p>
<ul>
<li>App ID</li>
<li>API Keys</li>
</ul>
<p><img src="Untitled40.png" alt="Untitled40.png"></p>
<h3 id="step4-使用新的User-key-發送request"><a href="#step4-使用新的User-key-發送request" class="headerlink" title="step4. 使用新的User key 發送request"></a>step4. 使用新的User key 發送request</h3><ul>
<li>Apoted NEW <code>API KEY</code>，同樣也可以得到正常的response結果</li>
</ul>
<p><img src="Untitled41.png" alt="Untitled41.png"></p>
<hr>
<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>完成以上的Portal建製與授權，建立APIM Portal 總結目有三項</p>
<ul>
<li><p><strong>發布 API 並協助開發人員順利上手</strong></p>
<p>  可供自訂的多功能開發人員入口網站不僅內建應用程式註冊服務，<code>也支援 API 金鑰的自動與手動核准程序</code>，完全是開發人員心目中的理想工具。此外，開發人員還可快速且<code>安全地存取探索、測試及運用 API</code> 所需的工具與資訊</p>
</li>
<li><p><strong>推動 API 產品上市</strong></p>
<p>  利用符合開發人員與合作夥伴需求的 API 產品，協助他們快速上手。透過 API Proxy 及其他設定等組合資源，提高附加價值、探索新商機，同時簡化學習流程。</p>
</li>
<li><p><strong>透過入口網站實現品牌體驗</strong></p>
<p>  無論是部署在雲端或內部部署環境中的 Apigee API 管理平台，自訂開發人員入口網站都可提供獨一無二的品牌體驗。第二個實驗，<code>TSP可以自已註冊一個帳戶，以自助方式</code>存取安全的開發人員入口網站，是開發人員與貴公司能成功交流的關鍵。</p>
</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://cloud.google.com/apigee/api-management/developer-portal?hl=zh-tw" target="_blank" rel="noopener">Apigee 開發人員入口網站</a></li>
<li><a href="https://www.qwiklabs.com/focuses/10522?parent=catalog" target="_blank" rel="noopener">Self Service API Discovery &amp; Sign Up Experience</a></li>
</ul>
]]></content>
      <categories>
        <category>APIM</category>
      </categories>
      <tags>
        <tag>APIGEE</tag>
        <tag>API GATEWAY</tag>
        <tag>APIM PORTAL</tag>
      </tags>
  </entry>
  <entry>
    <title>[GCP]Google Apps Scripts 串接 GCP BigQuery</title>
    <url>/2020/02/12/GCP-Google-Apps-Scripts-%E4%B8%B2%E6%8E%A5-GCP-BigQuery/</url>
    <content><![CDATA[<h1 id="GCP-Google-Apps-Scripts-串接-GCP-BigQuery"><a href="#GCP-Google-Apps-Scripts-串接-GCP-BigQuery" class="headerlink" title="[GCP]Google Apps Scripts 串接 GCP BigQuery"></a>[GCP]Google Apps Scripts 串接 GCP BigQuery</h1><h2 id="Google-Apps-Scripts-串接-GCP-BigQuery"><a href="#Google-Apps-Scripts-串接-GCP-BigQuery" class="headerlink" title="Google Apps Scripts 串接 GCP BigQuery"></a>Google Apps Scripts 串接 GCP BigQuery</h2><h3 id="Google-Apps-Scripts"><a href="#Google-Apps-Scripts" class="headerlink" title="Google Apps Scripts"></a>Google Apps Scripts</h3><p><a href="https://script.google.com/u/0/home" target="_blank" rel="noopener">Apps Script</a></p>
<p>Apps Script是Google開發的腳本平台，用於在G Suite平台中進行輕量級應用程序開發。可以簡單的後端功能也就能輕鬆實現了，這篇將會介紹如何使用 Google Apps Script，實現串接Cloud BigQuery</p>
<blockquote>
<p><code>&quot;Apps Script is a serverless JavaScript runtime for G suite automation, extension, and integration.&quot;</code><br>It is server-side JavaScript, similar to Node.js, but focuses on tight integration with G Suite and other Google services rather than fast asynchronous event-driven application hosting. It also features a development environment that may be completely different from what you’re used to. With Apps Script, you:</p>
</blockquote>
<ul>
<li>Develop in a browser-based code editor but can choose to develop locally if using <a href="http://developers.google.com/apps-script/guides/clasp" target="_blank" rel="noopener">clasp</a>, the command-line deployment tool for Apps Script</li>
<li>Code in a specialized version of JavaScript customized to access G Suite, and other Google or external services (via the Apps Script <a href="https://developers.google.com/apps-script/reference/url-fetch/" target="_blank" rel="noopener">URLfetch</a> or <a href="https://developers.google.com/apps-script/reference/jdbc/" target="_blank" rel="noopener">Jdbc</a> services)</li>
<li>Avoid writing authorization code because Apps Script handles it for you</li>
<li>Do not have to host your app—it lives and runs on Google servers in the cloud</li>
</ul>
<h3 id="▌實作步驟"><a href="#▌實作步驟" class="headerlink" title="▌實作步驟"></a>▌實作步驟</h3><ol>
<li>登入Google Apps Scripts，建立一個新的App scripts</li>
<li>啟用 GCP BigQuery API</li>
<li>編寫script：BigQuery code</li>
<li>驗證內容 Apps Scripts</li>
</ol>
<hr>
<h3 id="1-登入Google-Apps-Scripts，建立一個新的App-scripts"><a href="#1-登入Google-Apps-Scripts，建立一個新的App-scripts" class="headerlink" title="1. 登入Google Apps Scripts，建立一個新的App scripts"></a>1. 登入Google Apps Scripts，建立一個新的App scripts</h3><ul>
<li><p>開啟一開新專案</p>
<p>  <img src="Untitled.png" alt=" Untitled.png"></p>
</li>
<li><p>建立一個為為first-appscript project</p>
<p>  <img src="Untitled%201.png" alt=" Untitled%201.png"></p>
</li>
</ul>
<h3 id="2-啟用-GCP-BigQuery-API"><a href="#2-啟用-GCP-BigQuery-API" class="headerlink" title="2. 啟用 GCP BigQuery API"></a>2. 啟用 GCP BigQuery API</h3><p>啟用API設定有二個地方，第一是GCP API &amp; Service</p>
<p>第二是App Script中的 Advanced Google service</p>
<ul>
<li><p>設定 App Script  “Advanced Google service”</p>
<p>  <img src="Untitled2.png" alt=" Untitled%202.png"></p>
</li>
<li><p>BigQuery API → <code>on</code></p>
<p>  <img src="Untitled3.png" alt=" Untitled%203.png"></p>
</li>
<li><p>GCP API &amp; Service → <code>API enabled</code></p>
<p>  <img src="Untitled4.png" alt=" Untitled%204.png"></p>
</li>
</ul>
<h3 id="3-編寫Script：BigQuery-code"><a href="#3-編寫Script：BigQuery-code" class="headerlink" title="3. 編寫Script：BigQuery code"></a>3. 編寫Script：BigQuery code</h3><p>這個是Google提供的範本，我們僅需要修改二個部份</p>
<ol>
<li>GCP Project ID： <code>var PROJECT_ID = &#39;&lt;YOUR_PROJECT_ID&gt;&#39;</code></li>
<li>實際跑BigQuery code：<code>function runQuery()</code> </li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * Copyright 2018 Google LLC</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * you may not use this file except in compliance with the License.</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * You may obtain a copy of the License at apache.org&#x2F;licenses&#x2F;LICENSE-2.0.</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * Unless required by applicable law or agreed to in writing, software</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * See the License for the specific language governing permissions and</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * limitations under the License.</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; Filename for data results</span></pre></td></tr><tr><td class="code"><pre><span class="line">    var QUERY_NAME &#x3D; &quot;Most common words in all of Shakespeare&#39;s works&quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; Replace this value with your Google Cloud API project ID</span></pre></td></tr><tr><td class="code"><pre><span class="line">    var PROJECT_ID &#x3D; &#39;&lt;YOUR_PROJECT_ID&gt;&#39;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (!PROJECT_ID) throw Error(&#39;Project ID is required in setup&#39;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * Runs a BigQuery query; puts results into Sheet. You must enable</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * the BigQuery advanced service before you can run this code.</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * @see http:&#x2F;&#x2F;developers.google.com&#x2F;apps-script&#x2F;advanced&#x2F;bigquery#run_query</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * @see http:&#x2F;&#x2F;github.com&#x2F;gsuitedevs&#x2F;apps-script-samples&#x2F;blob&#x2F;master&#x2F;advanced&#x2F;bigquery.gs</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * @returns &#123;Spreadsheet&#125; Returns a spreadsheet with BigQuery results</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * @see http:&#x2F;&#x2F;developers.google.com&#x2F;apps-script&#x2F;reference&#x2F;spreadsheet&#x2F;spreadsheet</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    function runQuery() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#x2F;&#x2F; Replace sample with your own BigQuery query.</span></pre></td></tr><tr><td class="code"><pre><span class="line">      var request &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        query:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#39;SELECT &#39; +</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#39;LOWER(word) AS word, &#39; +</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#39;SUM(word_count) AS count &#39; +</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#39;FROM [bigquery-public-data:samples.shakespeare] &#39; +</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#39;GROUP BY word &#39; +</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#39;ORDER BY count &#39; +</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#39;DESC LIMIT 10&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      var queryResults &#x3D; BigQuery.Jobs.query(request, PROJECT_ID);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      var jobId &#x3D; queryResults.jobReference.jobId;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#x2F;&#x2F; Wait for BQ job completion (with exponential backoff).</span></pre></td></tr><tr><td class="code"><pre><span class="line">      var sleepTimeMs &#x3D; 500;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      while (!queryResults.jobComplete) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Utilities.sleep(sleepTimeMs);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sleepTimeMs *&#x3D; 2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        queryResults &#x3D; BigQuery.Jobs.getQueryResults(PROJECT_ID, jobId);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#x2F;&#x2F; Get all results from BigQuery.</span></pre></td></tr><tr><td class="code"><pre><span class="line">      var rows &#x3D; queryResults.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      while (queryResults.pageToken) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        queryResults &#x3D; BigQuery.Jobs.getQueryResults(PROJECT_ID, jobId, &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          pageToken: queryResults.pageToken</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        rows &#x3D; rows.concat(queryResults.rows);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#x2F;&#x2F; Return null if no data returned.</span></pre></td></tr><tr><td class="code"><pre><span class="line">      if (!rows) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return Logger.log(&#39;No rows returned.&#39;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#x2F;&#x2F; Create the new results spreadsheet.</span></pre></td></tr><tr><td class="code"><pre><span class="line">      var spreadsheet &#x3D; SpreadsheetApp.create(QUERY_NAME);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      var sheet &#x3D; spreadsheet.getActiveSheet();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#x2F;&#x2F; Add headers to Sheet.</span></pre></td></tr><tr><td class="code"><pre><span class="line">      var headers &#x3D; queryResults.schema.fields.map(function(field) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return field.name.toUpperCase();</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      sheet.appendRow(headers);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#x2F;&#x2F; Append the results.</span></pre></td></tr><tr><td class="code"><pre><span class="line">      var data &#x3D; new Array(rows.length);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      for (var i &#x3D; 0; i &lt; rows.length; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        var cols &#x3D; rows[i].f;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        data[i] &#x3D; new Array(cols.length);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        for (var j &#x3D; 0; j &lt; cols.length; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          data[i][j] &#x3D; cols[j].v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#x2F;&#x2F; Start storing data in row 2, col 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">      var START_ROW &#x3D; 2;      &#x2F;&#x2F; skip header row</span></pre></td></tr><tr><td class="code"><pre><span class="line">      var START_COL &#x3D; 1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      sheet.getRange(START_ROW, START_COL, rows.length, headers.length).setValues(data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">      Logger.log(&#39;Results spreadsheet created: %s&#39;, spreadsheet.getUrl());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- 貼上script，編輯BigQuery query code</span></pre></td></tr><tr><td class="code"><pre><span class="line">- 命名為[&#96;bq-sheets-slides.gs&#96;](http:&#x2F;&#x2F;bq-sheets-slides.gs&#x2F;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ![ Untitled%205.png](Untitled5.png)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- 主要BigQuery query cod內容</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    往public-data拿資料samples.shakespeare(莎士比亞作品)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    擷取作品中出现频率最高的10個單字，並依歡迎程度降冪排序</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    SELECT</span></pre></td></tr><tr><td class="code"><pre><span class="line">        LOWER(word) AS word,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        SUM(word_count) AS count</span></pre></td></tr><tr><td class="code"><pre><span class="line">    FROM [bigquery-public-data:samples.shakespeare]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    GROUP BY word</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ORDER BY count</span></pre></td></tr><tr><td class="code"><pre><span class="line">    DESC LIMIT 10</span></pre></td></tr></table></figure>

<h3 id="4-驗證內容-Apps-Scripts"><a href="#4-驗證內容-Apps-Scripts" class="headerlink" title="4. 驗證內容 Apps Scripts"></a>4. 驗證內容 Apps Scripts</h3><ul>
<li>第一次 run<ul>
<li>review permissions 系統會再驗證一次user/pwd</li>
<li>執行完會產出Google sheet</li>
</ul>
</li>
</ul>
<p><img src="Untitled6.png" alt=" Untitled%206.png"></p>
<h3 id="Google-Drive"><a href="#Google-Drive" class="headerlink" title="Google Drive"></a>Google Drive</h3><ul>
<li><p>去看看產出名為 <code>Most common words in all of Shakespeare&#39;s works</code> 的sheet</p>
<p>  <img src="Untitled7.png" alt=" Untitled%207.png"></p>
</li>
<li><p>檢視一下檔案內容，看到計算出的結果</p>
<p>  <img src="Untitled8.png" alt=" Untitled%208.png"></p>
</li>
</ul>
<h3 id="驗證從原本的bq-也有一樣的結果"><a href="#驗證從原本的bq-也有一樣的結果" class="headerlink" title="驗證從原本的bq 也有一樣的結果"></a>驗證從原本的bq 也有一樣的結果</h3><ul>
<li>同樣的Query，直接在BigQuery執行</li>
</ul>
<p><img src="Untitled9.png" alt=" Untitled%209.png"></p>
<h3 id="Query-history"><a href="#Query-history" class="headerlink" title="Query history"></a>Query history</h3><ul>
<li><p>從query history可以看到剛剛的執行結果</p>
<p>  <img src="Untitled10.png" alt=" Untitled%2010.png"></p>
</li>
<li><p>第二次直接使用BigQuery的執行結果也出現在history中</p>
<p>  <img src="Untitled11.png" alt=" Untitled%2011.png"></p>
</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h2><p>[1] <a href="https://www.qwiklabs.com/focuses/3565?parent=catalog" target="_blank" rel="noopener">https://www.qwiklabs.com/focuses/3565?parent=catalog</a></p>
<p>[2] <a href="https://script.google.com/u/0/home" target="_blank" rel="noopener">https://script.google.com/u/0/home</a></p>
<hr>
]]></content>
      <categories>
        <category>GCP</category>
      </categories>
      <tags>
        <tag>GCP</tag>
        <tag>API</tag>
        <tag>Google Apps Scripts</tag>
        <tag>BigQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>[GCP] Stackdriver省錢好簡單: 使用Logs Exclusions省成本 | Stackdriver: Adopting Logs Exclusions to Save Costs</title>
    <url>/2020/04/26/GCP-Stackdriver%E7%9C%81%E9%8C%A2%E5%A5%BD%E7%B0%A1%E5%96%AE-%E4%BD%BF%E7%94%A8Logs-Exclusions%E7%9C%81%E6%88%90%E6%9C%AC-Stackdriver-Adopting-Logs-Exclusions-to-Save-Costs/</url>
    <content><![CDATA[<h1 id="GCP-Stackdriver省錢好簡單-使用Logs-Exclusions省成本-Stackdriver-Adopting-Logs-Exclusions-to-Save-Costs"><a href="#GCP-Stackdriver省錢好簡單-使用Logs-Exclusions省成本-Stackdriver-Adopting-Logs-Exclusions-to-Save-Costs" class="headerlink" title="[GCP] Stackdriver省錢好簡單: 使用Logs Exclusions省成本 | Stackdriver: Adopting Logs Exclusions to Save Costs"></a>[GCP] Stackdriver省錢好簡單: 使用Logs Exclusions省成本 | Stackdriver: Adopting Logs Exclusions to Save Costs</h1><h2 id="▌前言"><a href="#▌前言" class="headerlink" title="▌前言"></a>▌前言</h2><hr>
<p>很多GCP 用戶對於<code>Stackdriver</code>是又愛又恨，它的圖形分析簡單，又與GCP深度結合，在操作上實在方便，但是它的計費方式包含<code>log volume</code>。簡單說就是存放雲上的log空間是要計價的，因此有<a href="https://cloud.google.com/solutions/stackdriver-cost-optimization#logging_cost_controls" target="_blank" rel="noopener">優化成本的方式</a>，來達到節費的目的，最可以讓你越來越愛它</p>
<h3 id="依照文件“Reduce-your-logs-usage”-1-降低logging成本方法有二項："><a href="#依照文件“Reduce-your-logs-usage”-1-降低logging成本方法有二項：" class="headerlink" title="依照文件“Reduce your logs usage”[1] 降低logging成本方法有二項："></a>依照文件“Reduce your logs usage”[1] 降低logging成本方法有二項：</h3><ul>
<li>方法一：設定Logs exclusions[2]，以減少日誌記錄的數量。</li>
<li>方法二：設定Logs exports[3]，使用sink 輸出至gcs, pub/sub，再配合第三方軟體 ex.Elastic Search 達成log analysis</li>
</ul>
<h2 id="▌什麼是Log-Exclusion？"><a href="#▌什麼是Log-Exclusion？" class="headerlink" title="▌什麼是Log Exclusion？"></a>▌什麼是Log Exclusion？</h2><hr>
<p>Exclusions 目的是減少日誌存入logging，使費用降低。ex. 當有過量log同時存入logging時，透過設定Logs exclusions 擷取特定log 內容並設定保存的百分比，以達到節費的目的。Logs exclusions 可以建立<strong>過濾器(filter)，只對某些log record進行採樣，以便只顯示一部分採樣的訊息出現在logging viewer。</strong></p>
<p>完整log生命週期，說明方法一、二的路徑，exclude的應用可以二種，保留部份訊息或全丟棄</p>
<ul>
<li>exclude 可以保留部份訊息，可以設定95%，將會隨機丟棄95% log ，僅保留5%的訊息</li>
<li>exclude 可以完全丟棄訊息，可以設定100%，因此不會保留任何訊息在logging</li>
</ul>
<p>圖1. life of log</p>
<p><img src="Untitled.png" alt="Untitled.png"></p>
<h2 id="▌Logs-Exclusions-操作"><a href="#▌Logs-Exclusions-操作" class="headerlink" title="▌Logs Exclusions 操作"></a>▌Logs Exclusions 操作</h2><hr>
<p>首先建立<code>filter</code>篩選log內容，再設定保留的百分比</p>
<p>以VM instance 為例</p>
<ul>
<li>先鎖定一筆VM instance log ，並擷取”Log name”內容，完整操作如下</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">resource.type=<span class="string">"gce_instance"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">logName=<span class="string">"projects/project-test-share/logs/cloudaudit.googleapis.com%2Fdata_access"</span></span></pre></td></tr></table></figure>

<p><strong>step1. 進入Logs ingestion畫面</strong></p>
<p><img src="Untitled1.png" alt="Untitled1.png"></p>
<p><strong>step2. 選擇服務</strong><br>以”GCE VM instance”為例，點選”Create exclusion filter based on this resource”</p>
<p><img src="Untitled2.png" alt="Untitled2.png"></p>
<p><strong>step3. 編輯篩選條件</strong></p>
<ul>
<li>請於”Filter”方框內，增加篩選條件</li>
<li>條件內容，可以使用 “show matching entries”功能，直接將條件帶入Filter</li>
</ul>
<p>以instance “logName”為例，並指定LogName</p>
<p><img src="Untitled3.png" alt="Untitled3.png"></p>
<ul>
<li><p>確認LogName已加入Filter篩選</p>
</li>
<li><p>Editor 請設定名稱與丟棄的%</p>
<p>  <img src="Untitled4.png" alt="Untitled4.png"></p>
</li>
</ul>
<p><strong>step4. 設定完Editor，請回Log injection頁面</strong></p>
<ul>
<li><p>確認exclusion policy，已正常加入exclusion</p>
<p>  <img src="Untitled5.png" alt="Untitled5.png"></p>
</li>
</ul>
<p>另外提供設定多筆exclusion範例</p>
<ul>
<li><p>其中一筆設定保留Load balance服務 10%</p>
</li>
<li><p>其它皆100% 丟棄</p>
</li>
<li><p>可以看到上方status，Excluded log volume確認過濾掉log</p>
<p>  <img src="Untitled6.png" alt="Untitled6.png"></p>
</li>
</ul>
<h3 id="Log-該保留百分比？"><a href="#Log-該保留百分比？" class="headerlink" title="Log 該保留百分比？"></a>Log 該保留百分比？</h3><p>根據GCP Exclude by percentage [4] 建議保留5%，因此設定Percent to Exclude為95%，Filtor將會隨機去除95%的log內容，僅將5%內容存入Cloud Logging中的日誌，另外我們建議可彈性設定1 ~ 5%。</p>
<h2 id="▌結果"><a href="#▌結果" class="headerlink" title="▌結果"></a>▌結果</h2><hr>
<p>最後，排除的日誌record不會計入Logging volume，進而達到節費目的。</p>
<p>另外參考圖1, export方法二，可以導出排除的日誌以保留Logging之外的log analysis軟體</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><hr>
<p>[1] <a href="https://cloud.google.com/stackdriver/pricing#reduce-logs-use" target="_blank" rel="noopener">https://cloud.google.com/stackdriver/pricing#reduce-logs-use</a></p>
<p>[2] <a href="https://cloud.google.com/logging/docs/exclusions" target="_blank" rel="noopener">https://cloud.google.com/logging/docs/exclusions</a></p>
<p>[3] <a href="https://cloud.google.com/logging/docs/export/configure_export_v2" target="_blank" rel="noopener">https://cloud.google.com/logging/docs/export/configure_export_v2</a></p>
<p>[4] <a href="https://cloud.google.com/solutions/stackdriver-cost-optimization#logging_cost_controls" target="_blank" rel="noopener">https://cloud.google.com/solutions/stackdriver-cost-optimization#logging_cost_controls</a></p>
]]></content>
      <categories>
        <category>GCP</category>
      </categories>
      <tags>
        <tag>Stackdriver</tag>
        <tag>Logs Exclusions</tag>
        <tag>Cost down</tag>
      </tags>
  </entry>
  <entry>
    <title>[GCP]Serverless network endpoint groups | Cloud Run 介接 Google Load Balance</title>
    <url>/2020/08/01/GCP-Serverless-network-endpoint-groups-Cloud-Run-%E4%BB%8B%E6%8E%A5-Google-Load-Balance/</url>
    <content><![CDATA[<h1 id="GCP-Serverless-network-endpoint-groups-Cloud-Run-介接-Google-Load-Balance"><a href="#GCP-Serverless-network-endpoint-groups-Cloud-Run-介接-Google-Load-Balance" class="headerlink" title="[GCP]Serverless network endpoint groups | Cloud Run 介接 Google Load Balance"></a>[GCP]Serverless network endpoint groups | Cloud Run 介接 Google Load Balance</h1><p>Status: Completed</p>
<h2 id="Agenda"><a href="#Agenda" class="headerlink" title="Agenda"></a>Agenda</h2><h1 id="簡介-Serverless-Network-Endpoint-Groups"><a href="#簡介-Serverless-Network-Endpoint-Groups" class="headerlink" title="簡介 Serverless Network Endpoint Groups"></a>簡介 Serverless Network Endpoint Groups</h1><p>目前<a href="https://cloud.google.com/load-balancing/docs/negs/serverless-neg-concepts" target="_blank" rel="noopener">NEG support serverless (in in Beta) [1]</a>，透過Load balance 轉 <code>HTTPs</code> 轉換為<code>HTTP</code> 可以滿足BIOS 連接Cloud Run需求。另外我理解acer，也需要WAF功能抵擋外部攻擊，但現在[Cloud Armor[2]](Cloud Armor.)還未能實現，最後文章指出未來幾個月Cloud Armor也會加入戰力</p>
<p>Network Endpoint Groups (NEG) 新功能歸功於Google Cloud網絡和負載平衡的基本功能， NEG的運作原理，請見圖1，它是存在Load balance的後端，它可以定義應外部流量，如何到達一組端點(Endpoint)，因此NEG 可以服務外來request，並將request直接經Load balance發送給GCP backend (eg. 可以是Compute Engine VM 或在VM上運行的服務，或是Endpoint URL, FQDN: port, IP)</p>
<p><img src="Untitled.png" alt="Untitled.png"></p>
<h1 id="準備環境"><a href="#準備環境" class="headerlink" title="準備環境"></a>準備環境</h1><ol>
<li>Cloud Run server：已準備<code>ngnix web</code> <a href="https://ngnix-v1-ve3udnlh4q-uc.a.run.app/" target="_blank" rel="noopener">https://ngnix-v1-ve3udnlh4q-uc.a.run.app</a></li>
<li>Network Endpoint Groups (NEG) ：設定一組<code>Network endpoints</code></li>
<li>Load balance：設定backend選擇<code>Network endpoints</code></li>
</ol>
<h1 id="A-Service-runs-on-Cloud-Run"><a href="#A-Service-runs-on-Cloud-Run" class="headerlink" title="A Service runs on Cloud Run"></a>A Service runs on Cloud Run</h1><h3 id="Step1-建立Cloud-Run-Service"><a href="#Step1-建立Cloud-Run-Service" class="headerlink" title="Step1. 建立Cloud Run Service"></a>Step1. 建立Cloud Run Service</h3><ul>
<li><code>endpoint</code>: <a href="https://ngnix-v1-ve3udnlh4q-uc.a.run.app/" target="_blank" rel="noopener">https://ngnix-v1-ve3udnlh4q-uc.a.run.app</a></li>
</ul>
<p><img src="Untitled1.png" alt="Untitled1.png"></p>
<h3 id="Step2-測試endpoint"><a href="#Step2-測試endpoint" class="headerlink" title="Step2. 測試endpoint"></a>Step2. 測試<code>endpoint</code></h3><ul>
<li><p>注意現在使用https連線</p>
<p>  <img src="Untitled2.png" alt="Untitled2.png"></p>
</li>
</ul>
<h1 id="Enable-Network-Endpoint-Groups-NEG"><a href="#Enable-Network-Endpoint-Groups-NEG" class="headerlink" title="Enable Network Endpoint Groups(NEG)"></a>Enable Network Endpoint Groups(NEG)</h1><h3 id="Step1-建立-Network-Endpoint-Group"><a href="#Step1-建立-Network-Endpoint-Group" class="headerlink" title="Step1. 建立 Network Endpoint Group"></a>Step1. 建立 Network Endpoint Group</h3><ul>
<li>此步驟是將外部來源轉為 <code>GCP 內的 backend service</code>，方可與 GCP HTTP(S) LB 串接。</li>
<li>路徑 GCP console -&gt; Compute Engine -&gt; Network Endpoint Group</li>
</ul>
<p><img src="Untitled3.png" alt="Untitled3.png"></p>
<h3 id="Step2-Create-Network-Endpoint-Group"><a href="#Step2-Create-Network-Endpoint-Group" class="headerlink" title="Step2. Create Network Endpoint Group"></a>Step2. Create Network Endpoint Group</h3><p><img src="Untitled4.png" alt="Untitled4.png"></p>
<h3 id="Step3-設定NEG"><a href="#Step3-設定NEG" class="headerlink" title="Step3. 設定NEG"></a>Step3. 設定NEG</h3><ul>
<li>NEG 命名</li>
<li>Network endpoint group type：請選 <code>Internet</code></li>
<li>Default port：因為來源是Cloud Run 走<code>HTTPs</code> <code>443</code></li>
<li>Add through endpoint<ul>
<li>Fully qualified domain name</li>
<li>Fully qualified domain name：請輸入你的 <code>Cloud Run endpoint</code><br>(eg. ngnix-v1-ve3udnlh4q-uc.a.run.app)</li>
</ul>
</li>
</ul>
<p><img src="Untitled5.png" alt="Untitled5.png"></p>
<h1 id="Load-balance"><a href="#Load-balance" class="headerlink" title="Load balance"></a>Load balance</h1><h3 id="Step1-建立-Load-balance"><a href="#Step1-建立-Load-balance" class="headerlink" title="Step1. 建立 Load balance"></a>Step1. 建立 Load balance</h3><ul>
<li>建立 GCP HTTP(S) LB, 在 GCP console -&gt; Network services -&gt; Load balancing</li>
<li>選擇<code>backend services</code></li>
</ul>
<p><img src="Untitled6.png" alt="Untitled6.png"></p>
<h3 id="Step2-設定-backend"><a href="#Step2-設定-backend" class="headerlink" title="Step2. 設定 backend"></a>Step2. 設定 backend</h3><ul>
<li>backend service 命名</li>
<li>backend type：請選 <code>Internet network endpoint group</code></li>
<li>Default port：因為來源是Cloud Run 走<code>HTTPs</code> <code>443</code></li>
</ul>
<p><img src="Untitled7.png" alt="Untitled7.png"></p>
<p>詳細設定如下</p>
<ul>
<li>Protocol 請選 <code>HTTPS</code></li>
<li>Backend 選擇上面步驟建立 <code>Network Endpoint Group</code></li>
<li>其餘設定依需求自行調整</li>
</ul>
<p><img src="Untitled8.png" alt="Untitled8.png"></p>
<p>header(非常重要)</p>
<ul>
<li>Custom request headers<ul>
<li>Header name：<code>host</code></li>
<li>Header value：Cloud Run 產生的<code>endpoint</code><br>(eg. ngnix-v1-ve3udnlh4q-uc.a.run.app)</li>
</ul>
</li>
</ul>
<p><img src="Untitled9.png" alt="Untitled9.png"></p>
<h3 id="Step2-設定frontend"><a href="#Step2-設定frontend" class="headerlink" title="Step2. 設定frontend"></a>Step2. 設定frontend</h3><p>這邊可以有不同的option <code>HTTP</code>, <code>HTTPs</code>，也可以同時開啟 80 與 443 ，作法需各別開兩個<code>frontend</code>設定</p>
<ul>
<li><p><strong>Option1. HTTP</strong></p>
<ul>
<li><p>frontend 命名</p>
</li>
<li><p>Protocol ：選擇 <code>HTTP</code></p>
</li>
<li><p>IP address ：可選擇<code>Ephemeral</code>, 或先註冊一組 <code>static IP</code></p>
</li>
<li><p>Port：<code>80</code></p>
<p><img src="Untitled10.png" alt="Untitled10.png"></p>
</li>
</ul>
</li>
<li><p><strong>Option2. HTTPs with certificate</strong></p>
<ul>
<li><p>frontend 命名</p>
</li>
<li><p>Protocol ：選擇 <code>HTTPS</code></p>
</li>
<li><p>IP address ：可選擇<code>Ephemeral</code>, 或先註冊一組 <code>static IP</code></p>
</li>
<li><p>Port：<code>443</code></p>
</li>
<li><p>Certificate 可以有二種選擇</p>
<ol>
<li><p>https 可以<code>自行管理</code>或是使用<code>Google管理的證書</code></p>
</li>
<li><p>若要使用自己的SSL證書，可上傳憑證檔；format 如下<br>填入<code>Public key certificate</code>, <code>Certificate chain</code>, <code>Private key</code></p>
<p><img src="Untitled11.png" alt="Untitled11.png"></p>
</li>
</ol>
</li>
<li><p>Certificate：填入<code>Public key certificate</code>, <code>Certificate chain</code>, <code>Private key</code></p>
</li>
<li><p>設定完後建立，需要時間生效</p>
<p>  <img src="Untitled12.png" alt="Untitled12.png"></p>
</li>
</ul>
</li>
</ul>
<p>使用Google管理的SSL證書</p>
<ul>
<li><p>憑證也可以使用Google管理的SSL證書，輸入網域名稱即可，若該網域的DNS設定有正確指向HTTP(S) Load Balancer的IP，少許時間之後可以看到該證書為<code>ACTIVE</code>狀態。</p>
<p>  <img src="Untitled13.png" alt="Untitled13.png"></p>
</li>
</ul>
<h1 id="Review-Setting-of-Load-balancer"><a href="#Review-Setting-of-Load-balancer" class="headerlink" title="Review Setting of Load balancer"></a>Review Setting of Load balancer</h1><ul>
<li>系統會確認您的設定值</li>
</ul>
<p><img src="Untitled14.png" alt="Untitled14.png"></p>
<ul>
<li>若無誤status 會呈現綠色勾勾</li>
</ul>
<p><img src="Untitled15.png" alt="Untitled15.png"></p>
<h1 id="Test-Original-Cloud-Run-with-“HTTP-header”"><a href="#Test-Original-Cloud-Run-with-“HTTP-header”" class="headerlink" title="Test Original Cloud Run with “HTTP header”"></a>Test Original Cloud Run with “HTTP header”</h1><h3 id="Test1-curl"><a href="#Test1-curl" class="headerlink" title="Test1. curl"></a>Test1. curl</h3><ul>
<li>Cloud Run base是採kubernetes，故ingress是L7 load balance，所以Cloud Run 需要透過<code>header</code> host來作為辨識</li>
<li>因此curl 時可以指定Load balance HTTP IP後，再補上<code>-H host header</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -k -H <span class="string">"host: ngnix-v1-ve3udnlh4q-uc.a.run.app"</span> http://35.201.76.173</span></pre></td></tr></table></figure>

<p><img src="Untitled16.png" alt="Untitled16.png"></p>
<h3 id="Test2-Browser"><a href="#Test2-Browser" class="headerlink" title="Test2. Browser"></a>Test2. Browser</h3><ul>
<li>我們已經了解Clour Run識別需要使用header，其實上面設定load balance froentend時，就已經把header寫入，故我們在Browser連線時就不用在加上header</li>
<li>透過HTTP(<a href="http://35.201.76.173/" target="_blank" rel="noopener">http://35.201.76.173/</a>)，可以正常連線至Cloud Run ngnix 網頁</li>
</ul>
<p><img src="Untitled17.png" alt="Untitled17.png"></p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol>
<li><a href="https://cloud.google.com/load-balancing/docs/negs/serverless-neg-concepts" target="_blank" rel="noopener">Serverless network endpoint groups overview</a></li>
<li><a href="https://cloud.google.com/blog/products/networking/better-load-balancing-for-app-engine-cloud-run-and-functions" target="_blank" rel="noopener">Global HTTP(S) Load Balancing and CDN now support serverless compute</a></li>
</ol>
]]></content>
      <categories>
        <category>GCP</category>
      </categories>
      <tags>
        <tag>GCP</tag>
        <tag>Cloud Run</tag>
        <tag>Networking</tag>
        <tag>NEG</tag>
        <tag>kubernetes</tag>
        <tag>network endpoint groups</tag>
      </tags>
  </entry>
  <entry>
    <title>[GCP] 只要懂SQL 即刻打通 BigQuery ML 任督二脈 |  BigQuery ML Hands-on</title>
    <url>/2020/02/19/GCP-%E5%8F%AA%E8%A6%81%E6%87%82SQL-%E5%8D%B3%E5%88%BB%E6%89%93%E9%80%9A-BigQuery-ML-%E4%BB%BB%E7%9D%A3%E4%BA%8C%E8%84%88-BigQuery-ML-Hands-on/</url>
    <content><![CDATA[<h1 id="GCP-只要懂SQL-即刻打通-BigQuery-ML-任督二脈-BigQuery-ML-Hands-on"><a href="#GCP-只要懂SQL-即刻打通-BigQuery-ML-任督二脈-BigQuery-ML-Hands-on" class="headerlink" title="[GCP] 只要懂SQL 即刻打通 BigQuery ML 任督二脈 |  BigQuery ML Hands-on"></a>[GCP] 只要懂SQL 即刻打通 BigQuery ML 任督二脈 |  BigQuery ML Hands-on</h1><hr>
<h2 id="Getting-Started-with-BQML"><a href="#Getting-Started-with-BQML" class="headerlink" title="Getting Started with BQML"></a>Getting Started with BQML</h2><p><a href="https://www.qwiklabs.com/focuses/2157?parent=catalog" target="_blank" rel="noopener">Getting Started with BQML | Qwiklabs</a></p>
<h2 id="▌只要會SQL就能做Machine-Learning？"><a href="#▌只要會SQL就能做Machine-Learning？" class="headerlink" title="▌只要會SQL就能做Machine Learning？"></a>▌只要會SQL就能做Machine Learning？</h2><p>是的！沒錯，BigQuery ML是bases BigQuery，它的運作是提取BigQuery 內的data提供ML訓練模型。使用上80%的語法都是原本的Query的語法，使用ML時儘需加入<code>model_type</code>，如此即可建立從Data Warehouse打造出來的專屬情境模型</p>
<blockquote>
<p><a href="https://cloud.google.com/bigquery/" target="_blank" rel="noopener">BigQuery Machine Learning</a> (BQML, product in beta) enables users to create and execute machine learning models in BigQuery using SQL queries. The goal is to democratise machine learning by enabling SQL practitioners to build models using their existing tools and to increase development speed by eliminating the need for data movement.</p>
</blockquote>
<h2 id="▌機器學習的原理-x-天文軌道"><a href="#▌機器學習的原理-x-天文軌道" class="headerlink" title="▌機器學習的原理 x 天文軌道"></a>▌機器學習的原理 x 天文軌道</h2><p>先用一個例子來解釋什麼是機器學習？機器學習(ML)實際上是尋找一種<code>數學模型</code>，讓這種模型符合它所要描述的對象。比如說我們要尋找一種描述天體運動的模型，讓它符合太陽系行星的運動情況，今天這個模型就是開普勒-牛頓的橢圓形模型:太陽系中所有的行星和彗星圍繞著太陽系的重心(和太陽的位置很接近但是有所差別)，做橢圓運動。當然，這個模型內不同物體的運動速度和周期不同，這些數據被稱為模型的<code>參數</code>。</p>
<p>有了這樣一個模型，就可以知道今後太陽系中行星和彗星的運行規律了，哈雷就用它成功地預測了哈雷彗星未來回到人們視野的時間。</p>
<blockquote>
<p>因此在模型中，要得到模型的參數(比如每一個星體運動的長軸半徑，運動一圈的周期)，就要根據觀察到的歷史資料計算</p>
</blockquote>
<h2 id="▌Mobile-x-預測交易機率"><a href="#▌Mobile-x-預測交易機率" class="headerlink" title="▌Mobile x 預測交易機率"></a>▌Mobile x 預測交易機率</h2><p>換一個例子，我們想透過mobile裝置的歷史資料包括device.operatingSystem、device.isMobile、使用者的國家、以及總瀏覽次數，共四項指標去預測客戶<code>再次交易的機率</code></p>
<pre><code>#standardSQL
CREATE OR REPLACE MODEL `bqml_lab.sample_model`
OPTIONS(model_type=&apos;logistic_reg&apos;) AS
SELECT
  IF(totals.transactions IS NULL, 0, 1) AS label,
  IFNULL(device.operatingSystem, &quot;&quot;) AS os,
  device.isMobile AS is_mobile,
  IFNULL(geoNetwork.country, &quot;&quot;) AS country,
  IFNULL(totals.pageviews, 0) AS pageviews
FROM
  `bigquery-public-data.google_analytics_sample.ga_sessions_*`
WHERE
  _TABLE_SUFFIX BETWEEN &apos;20160801&apos; AND &apos;20170631&apos;
LIMIT 100000;</code></pre><h3 id="其中"><a href="#其中" class="headerlink" title="其中"></a>其中</h3><ol>
<li><p>一開始我們使用 <strong><code>[CREATE MODEL](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-create?hl=zh-tw)</code></strong> 子句來建立及訓練名為 <strong><code>bqml_tutorial.sample_model</code></strong> 的模型。</p>
<p> <strong><code>OPTIONS(model_type=&#39;logistic_reg&#39;)</code></strong> 子句代表您在建立<a href="https://en.wikipedia.org/wiki/Logistic_regression" target="_blank" rel="noopener">邏輯迴歸</a>模型。 邏輯迴歸模型會嘗試將輸入資料拆分成兩個類別，並且給予各類別資料一個機率。</p>
<p> 這邊有用 <code>0</code>,<code>1</code> 的 label<code>標示</code>有沒有交易，像這樣有標記的就是supervised learning，訓練出的模型可以對一個新的使用者行為資料預測他”會不會交易”</p>
<blockquote>
<p>以辨識電子郵件是否屬於垃圾郵件為例，其屬於您有意偵測的事件；這類事件通常會用 1 表示，而不在此類的他種事件，則以 0 代表。若邏輯迴歸模型輸出 0.9，則表示有 90% 的機率為輸入資料是您想偵測的事件 (電子郵件屬於垃圾郵件)。</p>
</blockquote>
</li>
<li><p>這個查詢的 <strong><code>SELECT</code></strong> 語法提取下列欄位，而這些欄位可被模型用來預測顧客完成交易的機率:</p>
<ul>
<li><strong><code>totals.transactions</code></strong> — 訪客於當次工作階段內所達成的電子商務交易總數，若交易次數是 <strong><code>NULL</code></strong>，<strong><code>label</code></strong> 欄位的值就會被設為 <strong><code>0</code></strong>，否則該欄位就會被設定為 <strong><code>1</code></strong>，這些值皆可用來表示可能的結果。若要在 <strong><code>CREATE MODEL</code></strong> 陳述式中設定 <strong><code>input_label_cols=</code></strong> 選項，那麼建立一個名為 <strong><code>label</code></strong> 的別名是可行的替代方案。<ul>
<li><strong><code>device.operatingSystem</code></strong> — 訪客裝置的作業系統。</li>
<li><strong><code>device.isMobile</code></strong> — 用來表示訪客的裝置是否為行動裝置。</li>
<li><strong><code>geoNetwork.country</code></strong> — 以 IP 位置來表示該次工作階段的流量來源國家。</li>
<li><strong><code>totals.pageviews</code></strong> — 當次工作階段的總檢視頁數。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>FROM</code></strong> 子句 — <strong><code>bigquery-public-data.google_analytics_sample.ga_sessions_*</code></strong> </p>
<ul>
<li>表示正在查詢 Google Analytics 樣本資料集此資料集位在 <strong><code>bigquery-public-data</code></strong> 專案中，以日期為分類查詢一組資料表。這可用資料表名稱中的萬用字元來表示：<strong><code>google_analytics_sample.ga_sessions_*</code></strong></li>
</ul>
</li>
<li><p><strong><code>WHERE</code></strong> 子句 — <strong><code>_TABLE_SUFFIX BETWEEN &#39;20160801&#39; AND &#39;20170630&#39;</code></strong> — 限制了查詢所能夠掃描的資料表數量，而所掃描的日期區間則是從 2016.08.01 年 8 月 1 - 2017.06.30</p>
</li>
</ol>
<h2 id="▌模型有那些呢-Supported-models-in-BigQuery-ML"><a href="#▌模型有那些呢-Supported-models-in-BigQuery-ML" class="headerlink" title="▌模型有那些呢 | Supported models in BigQuery ML"></a>▌模型有那些呢 | Supported models in BigQuery ML</h2><p>看完上面的例子，還算簡單吧？因為除了既有的SQL語法之外，其實就只一條code 是在建立模型 → “OPTIONS(model_type=’logistic_reg’)”，那麼到底有幾種呢？</p>
<p><a href="https://cloud.google.com/bigquery-ml/docs/bigqueryml-intro" target="_blank" rel="noopener">Introduction to BigQuery ML | Google Cloud</a></p>
<p>目前有三大類forecasting、classification、 data segmentation，包含客製model共五種：</p>
<ol>
<li>Linear regression for forecasting</li>
<li>Binary logistic for classification</li>
<li>Multiclass logistic regression for classification</li>
<li>K-means clustering for data segmentation</li>
<li>TensorFlow model importing | 客製用</li>
</ol>
<p>以下簡單說明模型使用的場景：</p>
<h3 id="1-Binary-logistic-二元分類模型"><a href="#1-Binary-logistic-二元分類模型" class="headerlink" title="1. Binary logistic | 二元分類模型"></a>1. Binary logistic | 二元分類模型</h3><p>簡單說就是用來做二分法，非A及B，就是兩個可能的類別之中，選其中一個當作結果</p>
<ul>
<li><strong>二元分類問題範例</strong><ul>
<li>是否問題 → 「這個電子郵件是否為垃圾郵件？」</li>
<li>會不會問題 → 「客戶會不會購買此產品？」</li>
<li>是A還是B → 「這個產品是書籍還是電子產品？」</li>
</ul>
</li>
</ul>
<h3 id="2-Multiclass-logistic-多類別分類模型"><a href="#2-Multiclass-logistic-多類別分類模型" class="headerlink" title="2. Multiclass logistic | 多類別分類模型"></a>2. Multiclass logistic | 多類別分類模型</h3><p>Multiclass logistic ML 模型可讓您為多類別產生預測，簡單說就是預測兩個以上結果的其中一個。</p>
<ul>
<li><strong>多類別問題範例</strong><ul>
<li>「這個產品是書籍、電影還是衣服？」</li>
<li>「這個電影是浪漫喜劇片、紀錄片還是驚悚片？」</li>
<li>「這個客戶最感興趣的產品類別為何？」</li>
</ul>
</li>
</ul>
<h3 id="3-Linear-regressio-線性回歸模型"><a href="#3-Linear-regressio-線性回歸模型" class="headerlink" title="3. Linear regressio | 線性回歸模型"></a>3. Linear regressio | 線性回歸模型</h3><p>回歸問題的 ML 模型預測未來可能發生問題，使用數值做為結果基礎。</p>
<ul>
<li><strong>回歸問題範例</strong><ul>
<li>「西雅圖明天的溫度為何？」</li>
<li>「這個產品會售出多少單位？」</li>
<li>「這棟房屋的售價為何？」</li>
</ul>
</li>
</ul>
<h2 id="▌實戰BigQuery"><a href="#▌實戰BigQuery" class="headerlink" title="▌實戰BigQuery"></a>▌實戰BigQuery</h2><h3 id="1-訓練模型"><a href="#1-訓練模型" class="headerlink" title="#1. 訓練模型"></a>#1. 訓練模型</h3><p>訓練模型之前有個前提是帶你的dataset，因屬於BigQuery工作這邊先不多述。看我們的例子使用的模型類型是二元邏輯回歸。在這種情況下，標籤就是你試圖適應的東西</p>
<p><img src="Untitled.png" alt="Untitled.png"></p>
<ul>
<li><p>訓練結果| Execution details<br>產出有三個criteria可以參考：loss、Duration、Learn rate。我們可以發現<code>iteration</code>(迭代)經過了八次，確實有助了<code>loss</code>的下降，代表模型有很高的正確率</p>
<p>  <img src="Untitled1.png" alt="Untitled1.png"></p>
</li>
<li><p><strong>什麼是學習率(learn rate)</strong><br>這個參數是掌握模型的學習進度，如何調learn rate是訓練出好模型的關鍵要素。比如說learn rate對梯度下降的影響，如果learn rate太小，代表對神經網絡進行非常小的權重更新，會使其訓練變非常緩慢；另外learn rate太大，可能導致無法收斂。</p>
</li>
<li><p><strong>什麼遺失值(loss)</strong></p>
<p>  ML演算法是透過若干已知預測結果的範例 (像是使用者購買次數的歷史資料) 以及藉由迭代法來不斷調整模型中的各式權重，使得模型預測得以與真實數值吻合。最後能達到這個目標，是因為機器學習演算法透過「遺失」指標降低模型的錯誤預測。</p>
<p>  預期目標是每次迭代，遺失值越來越低 (理想狀況是降低到 0)。遺失值 0，代表模型具有 100% 的正確率。</p>
</li>
</ul>
<blockquote>
<p>「訓練資料遺失率」(Training Data Loss) 資料欄代表在訓練資料集上指定迭代後計算出來的損失指標。由於您執行了邏輯迴歸，因此該資料欄是<a href="https://en.wikipedia.org/wiki/Cross_entropy#Cross-entropy_error_function_and_logistic_regression" target="_blank" rel="noopener">對數損失</a>， 「評估資料遺失率」(Evaluation Data Loss) 資料欄是在保留資料集上計算的相同損失指標 (從訓練資料收回以驗證模型的資料)。</p>
</blockquote>
<h3 id="2-使用Model-預測"><a href="#2-使用Model-預測" class="headerlink" title="#2. 使用Model 預測"></a>#2. 使用Model 預測</h3><p>剛訓練完的模型，可以再經過一次資料評估但這邊先省略，直帶入做預測，我們要做的是用此模型來預測結果，您使用模型預測來自於每<code>一個國家的網站訪客所進行的交易次數</code>。</p>
<ul>
<li>FROM ml.EVALUATE(MODEL <code>bqml_lab.sample_model</code>：選擇方才建立的模型</li>
<li>SELECT：選擇進入的變數</li>
<li>FROM：選擇進入的table</li>
<li>WHERE：指定table 的日期</li>
</ul>
<p>選用的資料集為</p>
<ul>
<li><p>ml.EVALUATE(MODEL `bqml_lab.sample_model</p>
</li>
<li><p>選用每個國家的網站訪客所進行的交易次數 → 故SELECT country</p>
</li>
<li><p>使用的資料期間為<code>20170701 - 20170801</code> → 注意這次帶入的資料就是用不同區間的資料</p>
<p>  #standardSQL<br>  SELECT</p>
<pre><code>country,
SUM(predicted_label) as total_predicted_purchases</code></pre><p>  FROM</p>
<pre><code>ML.PREDICT(MODEL `bqml_tutorial.sample_model`, (</code></pre><p>  SELECT</p>
<pre><code>IFNULL(device.operatingSystem, &quot;&quot;) AS os,
device.isMobile AS is_mobile,
IFNULL(totals.pageviews, 0) AS pageviews,
IFNULL(geoNetwork.country, &quot;&quot;) AS country</code></pre><p>  FROM</p>
<pre><code>`bigquery-public-data.google_analytics_sample.ga_sessions_*`</code></pre><p>  WHERE</p>
<pre><code>_TABLE_SUFFIX BETWEEN &apos;20170701&apos; AND &apos;20170801&apos;))</code></pre><p>  GROUP BY country<br>  ORDER BY total_predicted_purchases DESC<br>  LIMIT 10</p>
</li>
</ul>
<p>通過這個查詢，預測每個國家的訪問者進行的交易數量，對結果進行排序，並根據購買情況選擇前10個國家：</p>
<h3 id="其中-1"><a href="#其中-1" class="headerlink" title="其中"></a>其中</h3><ul>
<li><p><code>[ML.PREDICT](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-predict?hl=zh_tw)</code> 函式可運用您的 <code>bqml_tutorial.sample_model</code> 模型來預測結果。</p>
<p>  這個查詢的巢狀 <code>SELECT</code> 陳述式及 <code>FROM</code> 子句與 <code>CREATE MODEL</code> 查詢中的相同。</p>
</li>
<li><p><code>WHERE</code> 子句 — <code>_TABLE_SUFFIX BETWEEN &#39;20170701&#39; AND &#39;20170801&#39;</code> — 它限定查詢掃描的資料表數量，日期區間提定在 2017.07.01 - 2017.08.01 ，</p>
</li>
<li><p><code>GROUP BY</code> 與 <code>ORDER BY</code> 子句藉由國家名稱分組結果，並以遞減方式將預測到的交易次數加總後進行遞減排序。</p>
</li>
<li><p><code>LIMIT</code> 子句在此處的用途是僅顯示前 10 筆查詢結果。</p>
</li>
<li><p>Job info</p>
<ul>
<li><code>duration</code>：可以看到執行的時間花了1.7 sec</li>
<li><code>bytes processed</code>：這次Query，是以量計價的模式(on-demand )，BigQuery 會根據「bytes processed處理的位元組數」，白話說也就是系統讀取的bytes，這項指標來收取執行查詢作業的費用</li>
</ul>
</li>
</ul>
<p><img src="Untitled2.png" alt="Untitled2.png"></p>
<ul>
<li><p>work timing<br>完整從SQL篩選資料給ML訓練使用</p>
<p>  Input → Join → Aggregate → Compute(S03)平行運算 → Compute(S04)平行運算 → Output</p>
<p>  <img src="Untitled3.png" alt="Untitled3.png"></p>
</li>
</ul>
<h3 id="3-預測結果說明"><a href="#3-預測結果說明" class="headerlink" title="3. 預測結果說明"></a>3. 預測結果說明</h3><ul>
<li><p><strong>預測1：</strong></p>
<p>  執行 ML.PREDICT 查詢，可以看到表格是預測各國的消費預測如下表</p>
<ul>
<li><p>預估1：美國會有209次的購買</p>
</li>
<li><p>預估2：台灣會有006次的購買</p>
</li>
<li><p>預估3：加國會有004次的購買</p>
<p>  <img src="Untitled4.png" alt="Untitled4.png"></p>
</li>
</ul>
</li>
<li><p><strong>預測2：</strong></p>
<p>  另外也可以修改Query，變成是預測每位使用者的購買量，我們把f<code>ullVisitorId</code> 加入到<code>SELECT</code></p>
<ul>
<li><p>預估1：客戶ID: 2537542…910，未來會有4次的購買</p>
</li>
<li><p>預估2：客戶ID: 9681060…629，未來會有3次的購買</p>
</li>
<li><p>預估3：客戶ID: 7102244…635，未來會有3次的購買</p>
<p>  #standardSQL<br>  SELECT</p>
<pre><code>fullVisitorId,
SUM(predicted_label) as total_predicted_purchases</code></pre><p>  FROM</p>
<pre><code>ml.PREDICT(MODEL `bqml_lab.sample_model`, (</code></pre><p>  SELECT</p>
<pre><code>IFNULL(device.operatingSystem, &quot;&quot;) AS os,
device.isMobile AS is_mobile,
IFNULL(totals.pageviews, 0) AS pageviews,
IFNULL(geoNetwork.country, &quot;&quot;) AS country,
fullVisitorId</code></pre><p>  FROM</p>
<pre><code>`bigquery-public-data.google_analytics_sample.ga_sessions_*`</code></pre><p>  WHERE</p>
<pre><code>_TABLE_SUFFIX BETWEEN &apos;20170701&apos; AND &apos;20170801&apos;))</code></pre><p>  GROUP BY fullVisitorId<br>  ORDER BY total_predicted_purchases DESC<br>  LIMIT 10;</p>
<p><img src="Untitled5.png" alt="Untitled5.png"></p>
</li>
</ul>
</li>
</ul>
<h2 id="▌Reference"><a href="#▌Reference" class="headerlink" title="▌Reference:"></a>▌Reference:</h2><ol>
<li>Qwikilab :<a href="https://www.qwiklabs.com/focuses/2157?parent=catalog" target="_blank" rel="noopener">https://www.qwiklabs.com/focuses/2157?parent=catalog</a></li>
<li><a href="https://docs.aws.amazon.com/zh_tw/machine-learning/latest/dg/types-of-ml-models.html" target="_blank" rel="noopener">https://docs.aws.amazon.com/zh_tw/machine-learning/latest/dg/types-of-ml-models.html</a></li>
<li>說明Iteration, Loss: <a href="https://jtcozylife.com/google-machine-learning-crash-course-%E7%AD%86%E8%A8%98-part-2/" target="_blank" rel="noopener">https://jtcozylife.com/google-machine-learning-crash-course-筆記-part-2/</a></li>
<li>完的ML訓練過程說明 <a href="https://ithelp.ithome.com.tw/articles/10221245" target="_blank" rel="noopener">https://ithelp.ithome.com.tw/articles/10221245</a></li>
</ol>
]]></content>
      <categories>
        <category>GCP</category>
      </categories>
      <tags>
        <tag>GCP</tag>
        <tag>BigQuery</tag>
        <tag>BigQueryML</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>[GCP] 強化GCP 網路資安控管, Enable VPC Service Control</title>
    <url>/2020/07/13/GCP-%E5%BC%B7%E5%8C%96GCP-%E7%B6%B2%E8%B7%AF%E8%B3%87%E5%AE%89%E6%8E%A7%E7%AE%A1-Enable-VPC-Service-Control/</url>
    <content><![CDATA[<h1 id="GCP-強化GCP-網路資安控管-Enable-VPC-Service-Control"><a href="#GCP-強化GCP-網路資安控管-Enable-VPC-Service-Control" class="headerlink" title="[GCP] 強化GCP 網路資安控管, Enable VPC Service Control"></a>[GCP] 強化GCP 網路資安控管, Enable VPC Service Control</h1><hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>做好資安的目的有二，首先是「降低資料竊取風險」，當你的架構規模擴大時，網路管理也隨之變得復雜，如此讓復雜的架構中同時滿足資安的條件，我們可以透過「大規模集中管理安全防護設定」，再對於每個GCP Prodcuts再上一道政策防護。</p>
<p>Service Account 可以讓服務和服務之間彼此溝通，它的發明讓程式更有彈性也更為開放，但他的存在也讓人又愛又恨！打個比方說，開啟了Service Account ，讓特定的服務不只在 Google Cloud 內部可以使用，只要通過權限認證，也能在 on-premise 或者其它雲的環境可以使用。因此我們需要有方法去限制它們的使用範圍，e.g 可以設定一些政策，只讓真正應該存取這些服務的網段、設備、或者是身份進行使用該GCP Products。</p>
<h1 id="什麼是GCP安全層級-Access-Context-Manager"><a href="#什麼是GCP安全層級-Access-Context-Manager" class="headerlink" title="什麼是GCP安全層級 | Access Context Manager"></a>什麼是GCP安全層級 | Access Context Manager</h1><p>在Google Cloud 怎麼解決集中安全控管？這個作法，其實很像<strong>Microsoft GroupPoicy</strong>的作法，我們制訂一個高層級的政策，透過 VPC 服務控制項 (VPC Service Controls)，企業資安團隊能設定精細的安全範圍控管政策並且套用到數個 GCP 專案與服務，而且這些控管政策是在「機構(organization)」層級統一集中設定的，不會散佈在各個專案裡面，方便資安團隊能夠統一管理，能輕鬆對安全控管項目進行增刪改查等操作。</p>
<ul>
<li>e.g 我們可以讓資安團隊設定某些特定的網段才能夠去存取這些代管的服務。</li>
<li>透過這些設定的安全範圍控管政策，我們將可有效減低資安問題，像是設定不當造成的資料外洩、惡意使用者上傳程式到的雲端儲存空間等等。</li>
</ul>
<hr>
<h1 id="實作1-Access-Context-Manager"><a href="#實作1-Access-Context-Manager" class="headerlink" title="實作1. Access Context Manager"></a>實作1. Access Context Manager</h1><h3 id="step1-設定Access-Context-Manager"><a href="#step1-設定Access-Context-Manager" class="headerlink" title="step1. 設定Access Context Manager"></a>step1. 設定Access Context Manager</h3><ul>
<li>在建立 VPC 服務控制項之前，我們先要建立「使用的存取層級」</li>
<li>因為 「輸入政策：存取層級 」，需要有存取層級</li>
<li>先進入Security → Access Context Manager → 建立一筆新的政策</li>
</ul>
<p><img src="Untitled.png" alt="Untitled.png"></p>
<h3 id="step2-Step-up-Policy"><a href="#step2-Step-up-Policy" class="headerlink" title="step2. Step up Policy"></a>step2. Step up Policy</h3><p>這邊開始設定你的條件項目</p>
<ul>
<li>條件可以設定 IP Subnet、地區、裝置政策者</li>
<li>我們這邊以 IP subnet 為例</li>
</ul>
<p><img src="Untitled1.png" alt="Untitled1.png"></p>
<blockquote>
<p>IP 不能是private，所以會噴錯 「Level create failed」</p>
</blockquote>
<p>ERROR: organizations/142432071105:0: Specified cidr block is fully contained in a private IP range. Private IP ranges are not supported.</p>
<p><img src="Untitled2.png" alt="Untitled2.png"></p>
<p>已設定完成的二筆以IP based Policy</p>
<ul>
<li>172.88.10.0/24</li>
</ul>
<p><img src="Untitled3.png" alt="Untitled3.png"></p>
<h3 id="step3-Overview-Access-Context-Manager"><a href="#step3-Overview-Access-Context-Manager" class="headerlink" title="step3.  Overview Access Context Manager"></a>step3.  Overview Access Context Manager</h3><ul>
<li>可以看得到全部的policy</li>
</ul>
<p><img src="Untitled4.png" alt="Untitled4.png"></p>
<h3 id="限制GCP-member-使用特定服務"><a href="#限制GCP-member-使用特定服務" class="headerlink" title="限制GCP member 使用特定服務"></a>限制GCP member 使用特定服務</h3><ul>
<li>Access Context Manager 也可以限定 member使用服務</li>
<li>如果你的IAM設計不夠嚴謹，可以讓user操作各種gcp products</li>
<li>我們使用member目的，是讓user僅使用google cloud特定的product而已</li>
</ul>
<blockquote>
<p>這個限定 member使用方法，目前僅在gcloud SDK操作</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">gcloud access-context-manager levels <span class="keyword">create</span> <span class="keyword">NAME</span> \</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">--title TITLE \</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">--basic-level-spec CONDITIONS.yaml \</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">--combine-function=OR \</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">--policy=POLICY_NAME</span></span></pre></td></tr></table></figure>

<p>其中各個參數值：</p>
<ul>
<li><p><strong>NAME</strong> is the unique name for the access level. It must begin with a letter and include only letters, numbers, and underscores.</p>
</li>
<li><p><strong>TITLE</strong> is a human-readable title. It must be unique to the policy.</p>
</li>
<li><p><strong>POLICY_NAME</strong> is the name of your organization’s access policy.</p>
</li>
<li><p><strong><code>combine-function</code></strong> is set to <strong><code>OR</code></strong>. The default value, <strong><code>AND</code></strong>, requires <em>all</em> conditions be met before an access level is granted. The <strong><code>OR</code></strong> value will give the members access even if other conditions, such as IP address or those inherited from other required access levels, are not met.</p>
</li>
<li><p>condition IP/ access level / Region / Device Policy</p>
<p>  <a href="https://cloud.google.com/vpc-service-controls/docs/use-access-levels?hl=zh-tw" target="_blank" rel="noopener">https://cloud.google.com/vpc-service-controls/docs/use-access-levels?hl=zh-tw</a></p>
<p>  <img src="Untitled5.png" alt="Untitled5.png"></p>
<h1 id="Using-access-levels"><a href="#Using-access-levels" class="headerlink" title="Using access levels"></a>Using access levels</h1><p>  Access levels are created and managed using Access Context Manager.</p>
<h3 id="Creating-an-access-level"><a href="#Creating-an-access-level" class="headerlink" title="Creating an access level"></a>Creating an access level</h3><p>  To create an access level, read about <a href="https://cloud.google.com/access-context-manager/docs/create-access-level?hl=zh-tw" target="_blank" rel="noopener">creating an access level</a> in the Access Context Manager documentation.</p>
<p>  The following examples explain how to create an access level using different conditions:</p>
<ul>
<li><p><a href="https://cloud.google.com/access-context-manager/docs/create-access-level?hl=zh-tw#corporate-network-example" target="_blank" rel="noopener">IP address</a></p>
</li>
<li><p><a href="https://cloud.google.com/access-context-manager/docs/create-access-level?hl=zh-tw#members-example" target="_blank" rel="noopener">User and service accounts</a> (members)</p>
<h3 id="Adding-access-levels-to-service-perimeters"><a href="#Adding-access-levels-to-service-perimeters" class="headerlink" title="Adding access levels to service perimeters"></a>Adding access levels to service perimeters</h3><p>You can add access levels to a service perimeter when creating the perimeter, or to an existing perimeter:</p>
</li>
<li><p>Read about <a href="https://cloud.google.com/vpc-service-controls/docs/create-service-perimeters?hl=zh-tw#external-access" target="_blank" rel="noopener">adding access levels when you create a perimeter</a></p>
</li>
<li><p>Read about <a href="https://cloud.google.com/vpc-service-controls/docs/manage-service-perimeters?hl=zh-tw#add-access-level" target="_blank" rel="noopener">adding access levels to an existing perimeter</a></p>
<h3 id="Managing-access-levels"><a href="#Managing-access-levels" class="headerlink" title="Managing access levels"></a>Managing access levels</h3><p>To manage your access levels, read about <a href="https://cloud.google.com/access-context-manager/docs/managing-access-levels?hl=zh-tw" target="_blank" rel="noopener">managing access levels</a>. This documentation explains how to list, modify, and delete existing access levels.</p>
</li>
</ul>
</li>
</ul>
<h1 id="實作2-VPC-Service-Control"><a href="#實作2-VPC-Service-Control" class="headerlink" title="實作2. VPC Service Control"></a>實作2. VPC Service Control</h1><p>設定一項完整的VPC Service Control，它的操作步驟為以下</p>
<ul>
<li>a. 範圍類型：全專案套用，或者是特定範圍選用</li>
<li>b. 設定類型：可以直接套用，或者先進純模擬測試</li>
<li>c. 要保護的專案</li>
<li>d. <strong>要保護的服務</strong></li>
</ul>
<h3 id="額外的選用限制項目"><a href="#額外的選用限制項目" class="headerlink" title="額外的選用限制項目"></a>額外的選用限制項目</h3><p><strong>可透過虛擬私人雲端存取的服務 (選用)</strong></p>
<p>指定可透過私人 Google 存取權使用的服務。只有在服務存取權受限的情況下，這些服務的資源存取權才會受到限制。這個清單未限制透過服務對服務路徑向服務傳送間接存取要求的行為。</p>
<p><strong>輸入政策：存取層級 (選用)</strong></p>
<p>存取層級僅適用於來自服務範圍外的受保護資源存取要求。您無法透過存取層級允許受保護的資源或 VM 存取範圍以外的資料和服務。</p>
<p><img src="Untitled6.png" alt="Untitled6.png"></p>
<h3 id="Step1-範圍類型"><a href="#Step1-範圍類型" class="headerlink" title="Step1. 範圍類型"></a>Step1. 範圍類型</h3><ul>
<li>設定名稱</li>
<li>套用的範圍為「全專案套用」</li>
<li>政策也是「立即套用」</li>
</ul>
<p><img src="Untitled7.png" alt="Untitled7.png"></p>
<h3 id="Step2-套用的服務"><a href="#Step2-套用的服務" class="headerlink" title="Step2. 套用的服務"></a>Step2. 套用的服務</h3><ul>
<li>套用的服務，我選擇BigQuery</li>
<li>BigQuery API，其實是對等於BigQuery服務</li>
</ul>
<p><img src="Untitled8.png" alt="Untitled8.png"></p>
<h3 id="step3-檢視Control-Policy"><a href="#step3-檢視Control-Policy" class="headerlink" title="step3. 檢視Control Policy"></a>step3. 檢視Control Policy</h3><p><img src="Untitled9.png" alt="Untitled9.png"></p>
<h3 id="step4-測試BigQuery"><a href="#step4-測試BigQuery" class="headerlink" title="step4. 測試BigQuery"></a>step4. 測試BigQuery</h3><ul>
<li>測試環境，刻意使用<code>外部的一組IP</code>，去存取BigQuery</li>
<li>此時VPC Service Control發揮功效，系統彈出錯訊息</li>
</ul>
<blockquote>
<p>VPC Service Controls: Request is prohibited by organization’s policy: vpcServiceControlsUniqeldentifier</p>
</blockquote>
<p><img src="Untitled10.png" alt="Untitled10.png"></p>
<h1 id="結論："><a href="#結論：" class="headerlink" title="結論："></a>結論：</h1><p>如果你很了解<strong>Microsoft Domain</strong> 控管原理，它的概念是使用<strong>GroupPoicy</strong>的作法，相同的道理我們也可以在GCP制訂一個高層級的政策，透過 VPC 服務控制項 (VPC Service Controls)，讓企業資安團隊在<a href="https://cloud.google.com/resource-manager/docs/cloud-platform-resource-hierarchy" target="_blank" rel="noopener">「機構(organization)」</a>層級設定精細的安全範圍控管政策並且套用到數個 GCP 專案與服務，如此防護，就像是城堡前的保壘，可以先行阻斷外部的攻擊，如此就能強化雲上GCP 資安。</p>
]]></content>
      <categories>
        <category>GCP</category>
      </categories>
      <tags>
        <tag>GCP</tag>
        <tag>Security</tag>
        <tag>VPC Service Control</tag>
        <tag>Access Context Manager</tag>
      </tags>
  </entry>
  <entry>
    <title>[Google API] Google 語音生成 API 實作 | Google Text-to-Speech</title>
    <url>/2020/06/25/Google-API-Google-%E8%AA%9E%E9%9F%B3%E7%94%9F%E6%88%90-API-%E5%AF%A6%E4%BD%9C-Google-Text-to-Speech/</url>
    <content><![CDATA[<h1 id="什麼是-Text-to-Speech-TTS"><a href="#什麼是-Text-to-Speech-TTS" class="headerlink" title="什麼是 Text-to-Speech (TTS)"></a>什麼是 Text-to-Speech (TTS)</h1><p>俗稱的TTS，從演進來看通常會有二種，第一類傳統作法已經行之有年，就像你常聽到的google小姐的聲音，第二類是拜於深度神經網路的發達，透過Convolutional Neural Network(CNN)來合成語音，這項技術比較多是運用在圖像的辨識上面，但Google將它轉向生成語音，成效相當很驚人！</p>
<h3 id="1-Basic-傳統作法"><a href="#1-Basic-傳統作法" class="headerlink" title="1. Basic 傳統作法"></a>1. Basic 傳統作法</h3><p>傳統上常見語音合成的方法有拼接生成又稱串接生成(Concatenative synthesis)及統計參數化法(StatisticalParametric method)等。拼接生成是透過<code>事先錄製多段聲音來拼接合成目標語句</code>；參數化法則是用模型生成聲音特徵的參數，再經由<code>聲碼器合成聲音</code>重新建構出聲音的波形。</p>
<p>簡單說，拼接生成最爆力的方式，直接找真人錄一大堆的句子、單字或一個字，建構起一個龐大的資料庫，然後看使用者打的是那一種單字，就從資料庫中去抓取並唸出來，重新拼接出來你要的句子，所以拼接起來會讓人覺得斷斷續續、怪怪的，因為很平淡沒有什麼抑揚頓挫(intonation)</p>
<h3 id="2-WaveNet"><a href="#2-WaveNet" class="headerlink" title="2. WaveNet"></a>2. <strong>WaveNet</strong></h3><p><strong>WaveNet中文稱為</strong>(波網)是一個用於<code>直接生成聲音訊號的[人工神經網路]</code>。是由倫敦人工智慧公司<a href="https://zh.wikipedia.org/wiki/DeepMind" target="_blank" rel="noopener">DeepMind</a>的研究人員於2016發表的。WaveNet強大的地方是通過使用用<strong><code>真實語音記錄訓練的神經網絡</code></strong>方法直接模擬波形，能夠生成聽起來相對<code>真實的人類聲音</code>。除了人類<a href="https://zh.wikipedia.org/wiki/%E8%AA%9E%E9%9F%B3%E5%90%88%E6%88%90" target="_blank" rel="noopener">語音合成</a>外，WaveNet也能應用在音樂生成以及語音辨識等領域。<a href="https://zh.wikipedia.org/wiki/WaveNet#cite_note-2" target="_blank" rel="noopener">[2]</a></p>
<p>2018年，<a href="https://zh.wikipedia.org/wiki/Google" target="_blank" rel="noopener">Google</a>在其雲端語音合成服務(Google Cloud Text-to-Speech)<a href="https://zh.wikipedia.org/wiki/WaveNet#cite_note-3" target="_blank" rel="noopener">[3]</a>提供了基於WaveNet的語音合成<a href="https://zh.wikipedia.org/wiki/API" target="_blank" rel="noopener">API</a><a href="https://zh.wikipedia.org/wiki/WaveNet#cite_note-API-4" target="_blank" rel="noopener">[4]</a>。截至2019年，該產品提供了32種語言以及多種不同音色的語音合成服務，且基於WaveNet的合成結果在自然度上相比傳統方法更接近人類語音。</p>
<h1 id="實作Text-to-Speech"><a href="#實作Text-to-Speech" class="headerlink" title="實作Text-to-Speech"></a>實作Text-to-Speech</h1><h3 id="Step1-Enable-API"><a href="#Step1-Enable-API" class="headerlink" title="Step1. Enable API"></a>Step1. Enable API</h3><ul>
<li>在Google Project上啟用<code>Text-to-Speech</code>這隻API</li>
</ul>
<p><img src="Untitled.png" alt="Untitled.png"></p>
<h3 id="Step-2-Create-a-service-account"><a href="#Step-2-Create-a-service-account" class="headerlink" title="Step 2. Create a service account"></a>Step 2. Create a service account</h3><ul>
<li>建立個服務帳戶</li>
<li>把服務帳戶輸出為JWT檔，供程式呼叫驗證：<code>tts-qwiklab.json</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcloud iam service-accounts create tts-qwiklab</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PROJECT_ID=$(gcloud config get-value project 2&gt; /dev/null)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	gcloud iam service-accounts keys create tts-qwiklab.json --iam-account tts-qwiklab@<span class="variable">$PROJECT_ID</span>.iam.gserviceaccount.com</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> GOOGLE_APPLICATION_CREDENTIALS=tts-qwiklab.json</span></pre></td></tr></table></figure>

<p><img src="Untitled1.png" alt="Untitled1.png"></p>
<h3 id="Step-3-Create-synthetic-speech-from-text"><a href="#Step-3-Create-synthetic-speech-from-text" class="headerlink" title="Step 3. Create synthetic speech from text"></a>Step 3. Create synthetic speech from text</h3><ul>
<li><p>Token準備：使用當前auth token<br>gcloud auth application-default print-access-token</p>
<p>  <img src="Untitled2.png" alt="Untitled2.png"></p>
</li>
<li><p>選擇發音的語系voice source，可以參考以下<br><a href="https://cloud.google.com/text-to-speech/docs/voices" target="_blank" rel="noopener">https://cloud.google.com/text-to-speech/docs/voices</a></p>
<p>  <img src="Untitled3.png" alt="Untitled3.png"></p>
</li>
<li><p>再來就是最重要的部驟，需要生成一個json檔：<code>synthesize-text.json</code></p>
<p>  其中JSON-formatted 參數值如下，分成三大塊</p>
<ol>
<li><code>input</code> 主要生成語音的文字內容</li>
<li><code>voice</code> 生成聲音的語言、發音版本、是否使用SSML</li>
<li><code>audioConfig</code> 聲音編碼的格式</li>
</ol>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">'input'</span>:&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">'text'</span>:<span class="string">'Cloud Text-to-Speech API allows developers to include</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">           natural-sounding, synthetic human speech as playable audio in</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">           their applications. The Text-to-Speech API converts text or</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">           Speech Synthesis Markup Language (SSML) input into audio data</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">           like MP3 or LINEAR16 (the encoding used in WAV files).'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">'voice'</span>:&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">'languageCode'</span>:<span class="string">'en-gb'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">'name'</span>:<span class="string">'en-GB-Standard-A'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">'ssmlGender'</span>:<span class="string">'FEMALE'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">'audioConfig'</span>:&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">'audioEncoding'</span>:<span class="string">'MP3'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="Step-4-完成curl-json"><a href="#Step-4-完成curl-json" class="headerlink" title="Step 4. 完成curl + json"></a>Step 4. 完成curl + json</h3><ul>
<li>傳送 <code>synthesize-text.txt</code> 檔案給Google Text-to-Speech API 生成語音檔</li>
<li>使用的API Endpoint: <code>https://texttospeech.googleapis.com/v1/text:synthesize</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -H <span class="string">"Authorization: Bearer "</span>$(gcloud auth application-default <span class="built_in">print</span>-access-token) \</span></pre></td></tr><tr><td class="code"><pre><span class="line">  -H <span class="string">"Content-Type: application/json; charset=utf-8"</span> \</span></pre></td></tr><tr><td class="code"><pre><span class="line">  -d @synthesize-text.json <span class="string">"https://texttospeech.googleapis.com/v1/text:synthesize"</span> \</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &gt; synthesize-text.txt</span></pre></td></tr></table></figure>

<ul>
<li>運行結果<br>你會發現結果會以 base64-encoded 加密的文字呈現，這個其實是語音的內容(audioContent field)，因此我們需要decode text</li>
</ul>
<p><img src="Untitled4.png" alt="Untitled4.png"></p>
<h3 id="Step-5-把text轉成mp3檔"><a href="#Step-5-把text轉成mp3檔" class="headerlink" title="Step 5. 把text轉成mp3檔"></a>Step 5. 把text轉成mp3檔</h3><ul>
<li>這邊準備一隻程式tts_decode.py，可以把decode text轉換成 .mp3</li>
<li>decode的函式<code>new_file.write(decodebytes(audio_data.encode(&#39;utf-8&#39;)))</code>，最後再轉換成語音</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python tts_decode.py --input <span class="string">"synthesize-text.txt"</span> --output <span class="string">"synthesize-text-audio.mp3"</span></span></pre></td></tr></table></figure>

<ul>
<li>運行結果</li>
</ul>
<p><img src="Untitled5.png" alt="Untitled5.png"></p>
<h3 id="Step-6-驗證"><a href="#Step-6-驗證" class="headerlink" title="Step 6. 驗證"></a>Step 6. 驗證</h3><ul>
<li>開一個網頁來聽mp3， index.html</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Cloud Text-to-Speech codelab<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Output from synthesizing text:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"synthesize-text-audio.mp3"</span> /&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></pre></td></tr></table></figure>

<ul>
<li><p>run web-server<br>python -m http.server 8080</p>
<p>  <img src="Untitled6.png" alt="Untitled6.png"></p>
<p>  <img src="Untitled7.png" alt="Untitled7.png"></p>
</li>
</ul>
<h1 id="References"><a href="#References" class="headerlink" title="References:"></a>References:</h1><ol>
<li><a href="https://zh.wikipedia.org/wiki/WaveNet" target="_blank" rel="noopener">WaveNet Wiki</a></li>
<li><a href="https://www.qwiklabs.com/focuses/1290?catalog_rank=%7B%22rank%22%3A1%2C%22num_filters%22%3A0%2C%22has_search%22%3Atrue%7D&parent=catalog&search_id=6083809" target="_blank" rel="noopener">It Speaks! Create Synthetic Speech Using Cloud Text-to-Speech</a></li>
<li><a href="https://cloud.google.com/text-to-speech/" target="_blank" rel="noopener">Google Text-to-Speech</a></li>
</ol>
]]></content>
      <categories>
        <category>GCP API</category>
      </categories>
      <tags>
        <tag>GCP</tag>
        <tag>API</tag>
        <tag>texttospeech</tag>
      </tags>
  </entry>
  <entry>
    <title>[GCP] 透過Content Header 確認 Cloud CDN Cache 加速 | Through Content Header Ensoure CDN Speed up</title>
    <url>/2020/05/24/GCP-%E9%80%8F%E9%81%8EContent-Header-%E7%A2%BA%E8%AA%8D-Cloud-CDN-Cache-%E5%8A%A0%E9%80%9F-Through-Content-Header-Ensoure-CDN-Speed-up/</url>
    <content><![CDATA[<h1 id="GCP-透過Content-Header-確認-Cloud-CDN-Cache-加速-Through-Content-Header-Ensoure-CDN-Speed-up"><a href="#GCP-透過Content-Header-確認-Cloud-CDN-Cache-加速-Through-Content-Header-Ensoure-CDN-Speed-up" class="headerlink" title="[GCP] 透過Content Header 確認 Cloud CDN Cache 加速 | Through Content Header Ensoure CDN Speed up"></a>[GCP] 透過Content Header 確認 Cloud CDN Cache 加速 | Through Content Header Ensoure CDN Speed up</h1><p>Status: Completed</p>
<h2 id="Cloud-CDN-Cache"><a href="#Cloud-CDN-Cache" class="headerlink" title="Cloud CDN Cache"></a>Cloud CDN Cache</h2><ul>
<li><p>根據<a href="https://cloud.google.com/cdn/docs/caching?hl=zh-tw" target="_blank" rel="noopener">Cloud CDN</a>[1] 文件，web header需要符合以下條件才能被cache</p>
</li>
<li><p>因此，CDN 沒有針對特別檔案或副檔名啟用cache功能與否，特別要注意的是<code>Cache directive</code>這個值要為<code>public</code>，對應curl -v 結果可以看到header content-control，此欄位應有<code>public</code>才能被cache</p>
</li>
<li><p>另外，如果要讓伺服務response header 符合<code>cacheable content</code>，請確認web server設定，response header 必需加上Cache-Control → <code>public</code></p>
</li>
</ul>
<p><a href="https://blog.confirm.ch/adding-and-removing-nginx-response-headers/" target="_blank" rel="noopener">以ngnix為例</a>[2]</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Adding response headers</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">add_header X-Frame-Options SAMEORIGIN;</span></pre></td></tr><tr><td class="code"><pre><span class="line">add_header X-Content-Type-Options nosniff;</span></pre></td></tr></table></figure>

<p>Cloud CDN文件[1]</p>
<p><img src="Untitled.png" alt="Untitled.png"></p>
<h2 id="Header-驗證"><a href="#Header-驗證" class="headerlink" title="Header 驗證"></a>Header 驗證</h2><ul>
<li>察看<code>curl -v</code> 結果<ul>
<li>使用 <code>-v</code> 是為了輸出更多的結果以利了解header情況</li>
<li>-v / <code>--verbose</code> 輸出更多的訊息方便 debug</li>
</ul>
</li>
</ul>
<p><strong>Finding1</strong></p>
<ul>
<li>發現這個網站<code>header</code>沒有 <code>public</code>，因此即使使用了CDN，這個網頁也不會享有cache加速</li>
</ul>
<p><img src="Untitled1.png" alt="Untitled1.png"></p>
<p><strong>Finding2</strong></p>
<ul>
<li><a href="http://istio.io" target="_blank" rel="noopener">istio.io</a> 網站<code>header顯示</code> <code>public</code>，因此可以正常使用cache加速</li>
</ul>
<p><img src="Untitled2.png" alt="Untitled2.png"></p>
<h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><p>[1] <a href="https://cloud.google.com/cdn/docs/caching?hl=zh-tw" target="_blank" rel="noopener">https://cloud.google.com/cdn/docs/caching?hl=zh-tw</a></p>
<p>[2] <a href="https://blog.confirm.ch/adding-and-removing-nginx-response-headers/" target="_blank" rel="noopener">https://blog.confirm.ch/adding-and-removing-nginx-response-headers/</a></p>
]]></content>
  </entry>
  <entry>
    <title>[GCP] Billing 預算告警服: 選用各別Products | Billing Budget Alert By Products</title>
    <url>/2020/04/23/GCP-Billing-%E9%A0%90%E7%AE%97%E5%91%8A%E8%AD%A6%E6%9C%8D-%E9%81%B8%E7%94%A8%E5%90%84%E5%88%A5Products-Billing-Budget-Alert-By-Products/</url>
    <content><![CDATA[<h1 id="GCP-Billing-預算告警服-選用各別Products-Billing-Budget-Alert-By-Products"><a href="#GCP-Billing-預算告警服-選用各別Products-Billing-Budget-Alert-By-Products" class="headerlink" title="[GCP] Billing 預算告警服: 選用各別Products | Billing Budget Alert By Products"></a>[GCP] Billing 預算告警服: 選用各別Products | Billing Budget Alert By Products</h1><p>Status: Completed</p>
<h2 id="▌前言"><a href="#▌前言" class="headerlink" title="▌前言"></a>▌前言</h2><hr>
<ul>
<li>很多用戶對於public是又愛又恨，因為他的便利和彈性又隨時可取得資源。</li>
<li>但是常常一個不小心就用過量了，收到帳單面都綠了，套一句客戶說的話</li>
</ul>
<blockquote>
<p>我終於體驗到了雲端的恐怖之處，做什麼都要錢 XDD</p>
</blockquote>
<p>因此節流是一種方式，另外我們也要設定Budget alter，也就是預算告警！以GCP為例，Billing Alert 可以針對Products來設定告警，這點非常的貼心</p>
<h2 id="▌操作步驟"><a href="#▌操作步驟" class="headerlink" title="▌操作步驟"></a>▌操作步驟</h2><hr>
<ul>
<li>建立Budget alert之前，請先確認帳號是否擁有Billing Account Administrator權限[1][2]</li>
<li>完整說明與操作請參考[2]</li>
</ul>
<p><strong>Step1. 請進入Budgets &amp; alerts 頁面</strong></p>
<ul>
<li><p>建立一筆 Budget</p>
<p>  <img src="Untitled.png" alt="Untitled.png"></p>
</li>
</ul>
<p><strong>Step2. Budget alert 可以針對特定product進行告警</strong></p>
<ul>
<li><p>以stackdriver為例，加入products清單</p>
<p>  <img src="Untitled1.png" alt="Untitled1.png"></p>
</li>
</ul>
<p><strong>Step3. 設定預算比較值</strong></p>
<ul>
<li>Budget type 說明<ul>
<li>Specified amount：先設置一個固定金額，之後每月支出會比較這筆固定金額</li>
<li>Last month’s spend：是根據上個月的支出，當作每月比較的基準金額</li>
</ul>
</li>
</ul>
<p><img src="Untitled2.png" alt="Untitled2.png"></p>
<p><strong>Step4. 設定門檻水準</strong></p>
<p> <strong>Trigger on說明</strong></p>
<ul>
<li><p><strong>Actual：觸發是依照實際使用值</strong><br>當預算期間內累積的累計費用超過門檻值時，實際成本門檻值規則將發送通知。<br>(ex. 如果您為$ 100的預算設置了50％的實際支出警報，那麼當您在預算期內支出了$ 50時，您將收到警報通知)</p>
</li>
<li><p><strong>Forecasted ：觸發會依照系統預測使用量</strong><br>當預測使用量超過門檻時，將發送通知。<br>(ex. 如果設定$ 100的預算，並設置了110％的預測費用警報，當系統預測預算將支出超過$ 110時，將收到警報通知)</p>
<p>  <img src="Untitled3.png" alt="Untitled3.png"></p>
</li>
</ul>
<p><strong>Step5. 檢視並確認Budget是否設定成功</strong></p>
<ul>
<li>確認Logging Budget 建立完成</li>
</ul>
<p><img src="Untitled4.png" alt="Untitled4.png"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><hr>
<p>[1] <a href="https://cloud.google.com/billing/docs/how-to/billing-access#overview_of_billing_roles_in" target="_blank" rel="noopener">https://cloud.google.com/billing/docs/how-to/billing-access#overview_of_billing_roles_in</a></p>
<p>[2] <a href="https://cloud.google.com/billing/docs/how-to/budgets" target="_blank" rel="noopener">https://cloud.google.com/billing/docs/how-to/budgets</a></p>
]]></content>
      <categories>
        <category>GCP</category>
      </categories>
      <tags>
        <tag>Cost down</tag>
        <tag>Billing</tag>
        <tag>Billing Budget Alert</tag>
      </tags>
  </entry>
  <entry>
    <title>[GCP] Cloud Scheduler 統一關機VM Instance | Cloud Scheduler Saving GCP Cost</title>
    <url>/2020/02/12/GCP-Cloud-Scheduler-%E7%B5%B1%E4%B8%80%E9%97%9C%E6%A9%9FVM-Instance-Cloud-Scheduler-Saving-GCP-Cost/</url>
    <content><![CDATA[<h1 id="GCP-Cloud-Scheduler-統一關機VM-Instance-Cloud-Scheduler-Saving-GCP-Cost"><a href="#GCP-Cloud-Scheduler-統一關機VM-Instance-Cloud-Scheduler-Saving-GCP-Cost" class="headerlink" title="[GCP] Cloud Scheduler 統一關機VM Instance | Cloud Scheduler Saving GCP Cost"></a>[GCP] Cloud Scheduler 統一關機VM Instance | Cloud Scheduler Saving GCP Cost</h1><h2 id="Agenda"><a href="#Agenda" class="headerlink" title="Agenda"></a>Agenda</h2><hr>
<h2 id="前題"><a href="#前題" class="headerlink" title="前題"></a>前題</h2><p>要讓機器自動關機的方法很多，linux crontab是一種，但仔細想想它是適用於單一台機器。假設我們的情況是一個cluster，它運行多台，你當然可以寫script都讓他們自動關機</p>
<blockquote>
<p>不過用不同的關機指令或方法，有不同的關機速度像是OS level、Instance console，因為每台VM Instances內服務不同，關閉的速度當然也不同<br>因此本實作透過console level 著手達成<em>統一關機的動作</em></p>
</blockquote>
<p><img src="Untitled.png" alt="Untitled.png"></p>
<p>說明instance對於各種action的反應時間(by: GCP VM instance Modules)</p>
<h3 id="Console-Stop-關機方式"><a href="#Console-Stop-關機方式" class="headerlink" title="Console Stop 關機方式"></a>Console Stop 關機方式</h3><p>今天要使用的是Console Stop方式，停止執行個體會導致 Compute Engine 將 <code>ACPI</code> 關機訊號傳送至執行個體。現行訪客作業系統都設定為在關機之前執行乾淨關機作業以回應關機訊號。 Compute Engine 會等待一小段時間，讓訪客完成關機，然後將執行個體轉換至 <code>TERMINATED</code> 狀態</p>
<h3 id="OS-層級Shutdown-VM-instance"><a href="#OS-層級Shutdown-VM-instance" class="headerlink" title="OS 層級Shutdown VM instance"></a>OS 層級Shutdown VM instance</h3><pre><code>sudo shutdown -h now</code></pre><h3 id="使用Cloud-Scheduler來協助關機"><a href="#使用Cloud-Scheduler來協助關機" class="headerlink" title="使用Cloud Scheduler來協助關機"></a>使用Cloud Scheduler來協助關機</h3><p>簡單說它就是在GCP上的crontab，對instance來說是外部的<strong>鬧鐘</strong>。它的好處是你可以統一對GCP上所有的instance做一次性的操作。要完成這個實作，我們還需要結合<strong>Cloud Pub/Sub、Cloud Function</strong>來完整自動化開機/關機的程序</p>
<hr>
<h2 id="目標"><a href="#目標" class="headerlink" title="目標"></a>目標</h2><ol>
<li>指定VM Instance 設定<code>label</code>，設定Cloud  Pub/Sub topic</li>
<li>部署Cloud Function，使用<code>Nodo.js</code> code 去控制你的VM Instances</li>
<li>透過Cloud Scheduler建立一個時間表，使VM Instances按時間開關機</li>
</ol>
<h3 id="架構圖說明"><a href="#架構圖說明" class="headerlink" title="架構圖說明"></a>架構圖說明</h3><ul>
<li><p><a href="https://cloud.google.com/compute/docs/instances/" target="_blank" rel="noopener">Compute Engine Instance</a>：最右邊是接受控管VM Instances</p>
</li>
<li><p><a href="https://cloud.google.com/functions/docs/concepts/overview" target="_blank" rel="noopener">Cloud Functions functions</a>：承載一個簡單函式，執行開/關機程式</p>
</li>
<li><p><a href="https://cloud.google.com/pubsub/docs/overview" target="_blank" rel="noopener">Pub/Sub messages</a>：訊息傳送的角色，把VM上的label 傳送給Cloud function</p>
</li>
<li><p><a href="https://cloud.google.com/scheduler/docs/" target="_blank" rel="noopener">Cloud Scheduler jobs</a>：GCP上的定時器，時間一到會執行目標上的Cloud function</p>
<p>  <img src="Untitled1.png" alt="Untitled1.png"></p>
</li>
</ul>
<hr>
<h2 id="啟用Cloud-Scheduler-API-amp-Cloud-Function-API"><a href="#啟用Cloud-Scheduler-API-amp-Cloud-Function-API" class="headerlink" title="啟用Cloud Scheduler API &amp; Cloud Function API"></a>啟用Cloud Scheduler API &amp; Cloud Function API</h2><p>首先，要使用之前我們要先產出<code>credential</code> 給Cloud function API 和Cloud Scheduler API做使用</p>
<pre><code># Enable API
$gcloud services enable &lt;SERVICE_NAME&gt;
- cloudfunctions.googleapis.com
- cloudscheduler.googleapis.com

$gcloud services enable cloudfunctions.googleapis.com
$gcloud services enable cloudscheduler.googleapis.com

# Check Enabled Current API
$ gcloud services list --available | grep -E &apos;Scheduler | Functions&apos;
cloudfunctions.googleapis.com                         Cloud Functions API
cloudscheduler.googleapis.com                         Cloud Scheduler API</code></pre><p>執行結果看到 Scheduler, Functions都是<code>available</code></p>
<p><img src="Untitled2.png" alt="Untitled2.png"></p>
<p>你可以到GCP Console 進行設定<br>路徑如下： IAM → APIs &amp; Services → Credentials</p>
<p><img src="Untitled3.png" alt="Untitled3.png"></p>
<h2 id="怎麼樣讓Cloud-Function認得你的機器呢？-→-Labels"><a href="#怎麼樣讓Cloud-Function認得你的機器呢？-→-Labels" class="headerlink" title="怎麼樣讓Cloud Function認得你的機器呢？ →  Labels"></a>怎麼樣讓Cloud Function認得你的機器呢？ →  Labels</h2><p>這裡使用的方法是在指定的VM Instances，加上<code>labels</code>，它是一個<code>**key:value**</code>格式<br>我的要控制的cluster是kubernetes cluster，因此使用 <code>env:k8s</code> 當作labels</p>
<ul>
<li><p>使用cloud shell 新增labels，並篩選機器 label 為 <code>env:k8s</code></p>
</li>
<li><p>Kubernetes一共有3台instance，記得都要上<code>labels</code></p>
</li>
<li><p>補充一下<code>labels</code>和<code>metadata</code>是不一樣的東西喔</p>
<h1 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h1><h1 id="Labels-can-be-used-to-identify-the-instance-and-to-filter-them"><a href="#Labels-can-be-used-to-identify-the-instance-and-to-filter-them" class="headerlink" title="Labels can be used to identify the instance and to filter them."></a>Labels can be used to identify the instance and to filter them.</h1><h1 id="To-find-a-instance-labeled-with-key-value-pair-k1-v2"><a href="#To-find-a-instance-labeled-with-key-value-pair-k1-v2" class="headerlink" title="To find a instance labeled with key-value pair k1, v2"></a>To find a instance labeled with key-value pair k1, v2</h1><h1 id="可以先讀一下範例說明"><a href="#可以先讀一下範例說明" class="headerlink" title="可以先讀一下範例說明"></a>可以先讀一下範例說明</h1><p>  $gcloud beta compute instances add-labels example-instance \</p>
<pre><code>--labels=k0=v0,k1=v1</code></pre><p>  $gcloud compute instances list –filter=’labels.k1:v2’</p>
<h1 id="Label-env-k8s"><a href="#Label-env-k8s" class="headerlink" title="Label env=k8s"></a>Label env=k8s</h1><h1 id="label套用到我的環境"><a href="#label套用到我的環境" class="headerlink" title="label套用到我的環境"></a>label套用到我的環境</h1><p>  $gcloud beta compute instances add-labels k8s-master \</p>
<pre><code>--zone=us-central1-a \
--labels=env=k8s</code></pre><p>  $gcloud compute instances list –filter=’labels.env:k8s’</p>
</li>
</ul>
<p>執行結果看到<br>透過<code>labels.env:k8s</code>篩選出我們要看的VM Instance</p>
<p><img src="Untitled4.png" alt="Untitled4.png"></p>
<p>你可以到GCP Console 進行檢查<code>Labels</code></p>
<p><img src="Untitled5.png" alt="Untitled5.png"></p>
<h2 id="建立-Pub-Sub-topics"><a href="#建立-Pub-Sub-topics" class="headerlink" title="建立  Pub/Sub topics"></a>建立  Pub/Sub topics</h2><p>建立二筆topic，一個給開機用另一則是關機用，名字分別為<code>start-instance-event</code>、<code>stop-instance-event</code></p>
<pre><code># 建立二個 topics: start &amp; stop
$gcloud pubsub topics create start-instance-event
$gcloud pubsub topics create stop-instance-event

# 檢視現有的topic
$gcloud pubsub topics list
---
name: projects/tw-rd-ca-joe-huang/topics/start-instance-event
---
name: projects/tw-rd-ca-joe-huang/topics/stop-instance-event</code></pre><p>建好之後，檢視Pub/Sub發現有二筆<code>topic</code></p>
<p>代表建立成功</p>
<p><img src="Untitled6.png" alt="Untitled6.png"></p>
<h2 id="建立Start-and-Stop-Cloud-Functions"><a href="#建立Start-and-Stop-Cloud-Functions" class="headerlink" title="建立Start and Stop Cloud Functions"></a>建立Start and Stop Cloud Functions</h2><ul>
<li><p>先下載Git，看他的程式碼邏輯跟剛才測試的<code>labels</code>是一樣的</p>
</li>
<li><p>用預寫好的node.js 部署<code>Cloud Function</code></p>
<h1 id="下載-node-js-code"><a href="#下載-node-js-code" class="headerlink" title="下載 node.js code"></a>下載 node.js code</h1><h1 id="裡面有控制function-可以對instance開關機"><a href="#裡面有控制function-可以對instance開關機" class="headerlink" title="裡面有控制function 可以對instance開關機"></a>裡面有控制function 可以對instance開關機</h1><p>  git clone <a href="https://github.com/GoogleCloudPlatform/nodejs-docs-samples.git" target="_blank" rel="noopener">https://github.com/GoogleCloudPlatform/nodejs-docs-samples.git</a></p>
</li>
</ul>
<pre><code># 切換正確目錄
cd nodejs-docs-samples/functions/scheduleinstance/

# 部署Cloud Function
gcloud functions deploy startInstancePubSub \
    --trigger-topic start-instance-event \
    --runtime nodejs8</code></pre><p><code>node.js</code> 部份功能</p>
<pre><code>exports.startInstancePubSub = async (event, context, callback) =&gt; {
  try {
    const payload = _validatePayload(
      JSON.parse(Buffer.from(event.data, &apos;base64&apos;).toString())
    );
    const options = {filter: `labels.${payload.label}`}; # 用label篩選指定的vm
    const [vms] = await compute.getVMs(options);
    await Promise.all(
      vms.map(async instance =&gt; {
        if (payload.zone === instance.zone.id) {
          const [operation] = await compute
            .zone(payload.zone)
            .vm(instance.name)
            .start();                                    # start()函數來啟動vm

          // Operation pending
          return operation.promise();
        }
      })
    );</code></pre><ul>
<li><h3 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h3><h3 id="Multi-Payload"><a href="#Multi-Payload" class="headerlink" title="Multi Payload"></a>Multi Payload</h3><p>  看看能不能管理多個lael，意思就是可以管理不多的instances</p>
<p>  <img src="Untitled7.png" alt="Untitled7.png"></p>
<h2 id="node-js-6-BUG"><a href="#node-js-6-BUG" class="headerlink" title="node.js 6 BUG"></a>node.js 6 BUG</h2><p>  <strong>Error message: Code in file index.js can’t be loaded</strong></p>
<p>  <a href="https://stackoverflow.com/questions/56571460/cloud-functions-deployment-fails-function-failed-on-loading-user-code-error-m" target="_blank" rel="noopener">https://stackoverflow.com/questions/56571460/cloud-functions-deployment-fails-function-failed-on-loading-user-code-error-m</a></p>
<p>  <img src="Untitled8.png" alt="Untitled8.png"></p>
</li>
</ul>
<h2 id="設定Cloud-Scheduler"><a href="#設定Cloud-Scheduler" class="headerlink" title="設定Cloud Scheduler"></a>設定Cloud Scheduler</h2><p>如何定義一個排程時間，設定日期的規則很像<a href="http://linux.vbird.org/linux_basic/0430cron.php" target="_blank" rel="noopener">Linux crontab</a></p>
<p><a href="https://cloud.google.com/scheduler/index" target="_blank" rel="noopener">Cloud Schedule</a>列出5個欄位「分」、「時」、「天」、「月」、「週」</p>
<p><img src="https://cloud.google.com/scheduler/docs/images/schedule-fields.png" alt="https://cloud.google.com/scheduler/docs/images/schedule-fields.png"></p>
<h3 id="Cloud-Scheduler-設定例子"><a href="#Cloud-Scheduler-設定例子" class="headerlink" title="Cloud Scheduler 設定例子"></a>Cloud Scheduler 設定<strong>例子</strong></h3><ul>
<li>每分鐘執行：<code>* * * * *</code></li>
<li>每週一早上九點執行：<code>0 9 * * 1</code></li>
<li>每週早上九點執行：<code>0 9 * *</code></li>
<li>每3小時執行：<code>0 */3 * * *</code></li>
<li>每週一早上十點40分執行：<code>40 10 * * 1</code></li>
<li>每週早上十點40分執行：<code>40 10 * * *</code></li>
<li>上班工作日開機，下班時間請執行： <code>0 7,18 * * 1-5</code></li>
</ul>
<h3 id="手動測試"><a href="#手動測試" class="headerlink" title="手動測試"></a>手動測試</h3><p>建議在使用Cloud Scheduler之前，可以先手動觸發Cloud function<br>如此可以減少Scheduler設定錯誤，而造成時間等待的浪費</p>
<ul>
<li><p>注意這邊傳入function的值需要經過加密，因此使用<code>base64</code></p>
</li>
<li><p>把加密過的值帶入 —data{<code>encrpted data</code>}</p>
<h1 id="因為現在是關機的狀態，要使用Cloud-functions-call-startInstancePubSub"><a href="#因為現在是關機的狀態，要使用Cloud-functions-call-startInstancePubSub" class="headerlink" title="因為現在是關機的狀態，要使用Cloud functions call startInstancePubSub"></a>因為現在是關機的狀態，要使用Cloud functions call startInstancePubSub</h1><p>  $echo ‘{“zone”:”us-central1-a”, “label”:”env=k8s”}’ | base64<br>  eyJ6b25lIjoidXMtY2VudHJhbDEtYSIsICJsYWJlbCI6ImVudj1rOHMifQo=</p>
<h1 id="直接手動觸發-開機"><a href="#直接手動觸發-開機" class="headerlink" title="直接手動觸發(開機)"></a>直接手動觸發(開機)</h1><p>  $gcloud functions call startInstancePubSub \</p>
<pre><code>--data &apos;{&quot;data&quot;:&quot;eyJ6b25lIjoidXMtY2VudHJhbDEtYSIsICJsYWJlbCI6ImVudj1rOHMifQo=&quot;}&apos;</code></pre><p>  executionId: e7o6dafufthu</p>
<h1 id="執行function成功，幫我們開機"><a href="#執行function成功，幫我們開機" class="headerlink" title="執行function成功，幫我們開機"></a>執行function成功，幫我們開機</h1><p>  result: Successfully started instance(s)</p>
<h1 id="檢視機器狀態"><a href="#檢視機器狀態" class="headerlink" title="檢視機器狀態"></a>檢視機器狀態</h1><p>  $for vm in k8s-master k8s-node-1 k8s-node-2; do gcloud compute instances describe $vm \</p>
<pre><code>--zone us-central1-a \
| grep status; done</code></pre><p>  status: RUNNING<br>  status: RUNNING<br>  status: RUNNING</p>
</li>
</ul>
<p>執行結果看到，三台VM Instance有正常運行中</p>
<p><img src="Untitled9.png" alt="Untitled9.png"></p>
<ul>
<li><p>先看現況VM的狀態(關機)</p>
<pre><code># joe.huang @ joehuangs-MacBook-Pro in ~ on git:master x [10:29:39] C:1
$ for vm in k8s-master k8s-node-1 k8s-node-2; do gcloud compute instances describe $vm \
    --zone us-central1-a \
    | grep status; done
status: RUNNING
status: RUNNING
status: RUNNING</code></pre><p>  <img src="Untitled10.png" alt="Untitled10.png"></p>
<p>  <img src="Untitled11.png" alt="Untitled11.png"></p>
</li>
</ul>
<h3 id="正式測試"><a href="#正式測試" class="headerlink" title="正式測試"></a>正式測試</h3><ul>
<li>透過Cloud Scheduler 自動觸發 stop-dev-instances</li>
<li>方才我們驗證了Cloud function 可以正常工作， 與辨識VM Instance label: <code>env:k8s</code></li>
<li>再來就是要驗證Scheduler + Cloud function，把時間設定為<code>期望的時間</code></li>
</ul>
<blockquote>
<p>注意：<br>現在時間是<code>10:37</code>且VM處於開機狀態，我們要設定10:48 <code>關機</code></p>
</blockquote>
<p><img src="Untitled12.png" alt="Untitled12.png"></p>
<p>Cloud Shell 範本</p>
<pre><code># Sample
gcloud beta scheduler jobs create pubsub startup-dev-instances \
    --schedule &apos;0 9 * * 1-5&apos; \
    --topic start-instance-event \
    --message-body &apos;{&quot;zone&quot;:&quot;us-west1-b&quot;, &quot;label&quot;:&quot;env=dev&quot;}&apos; \
    --time-zone &apos;America/Los_Angeles&apos;

# 設定 10點48分鐘關機
gcloud beta scheduler jobs create pubsub stop-dev-instances \
    --schedule &apos;48 10 * * *&apos; \
    --topic start-instance-event \
    --message-body &apos;{&quot;zone&quot;:&quot;us-central1-a&quot;, &quot;label&quot;:&quot;env=k8s&quot;}&apos; \
    --time-zone &apos;Asia/Taipei&apos;</code></pre><p>確實執行完task喔</p>
<pre><code># joe.huang @ joehuangs-MacBook-Pro in ~ on git:master x [10:47:20]
$ for vm in k8s-master k8s-node-1 k8s-node-2; do gcloud compute instances describe $vm \
    --zone us-central1-a \
    | grep status; done
status: TERMINATED
status: TERMINATED
status: TERMINATED</code></pre><p>執行結果看到<br>三台VM Instance有已被終止運行</p>
<p><img src="Untitled13.png" alt="Untitled13.png"></p>
<h2 id="查看Cloud-Scheduler-Job-Log"><a href="#查看Cloud-Scheduler-Job-Log" class="headerlink" title="查看Cloud Scheduler Job Log"></a>查看Cloud Scheduler Job Log</h2><p>最後我們查看log，看看他的執行的過程</p>
<p>我們可以看到10:48香港時間，執行了<strong>stop-dev-instances</strong></p>
<ul>
<li>type: “type.googleapis.com/google.cloud.scheduler.logging.AttemptFinished”</li>
<li>jobName: “projects/tw-rd-ca-joe-huang/locations/asia-east2/jobs/start-stop-vm”</li>
<li>pubsubTopic: “projects/tw-rd-ca-joe-huang/topics/<code>stop-instance-event</code>“</li>
</ul>
<p><img src="Untitled14.png" alt="Untitled14.png"></p>
<h2 id="References"><a href="#References" class="headerlink" title="References:"></a>References:</h2><ol>
<li><strong><a href="https://cloud.google.com/scheduler/docs/start-and-stop-compute-engine-instances-on-a-schedule?hl=en-ushttps://cloud.google.com/scheduler/docs/start-and-stop-compute-engine-instances-on-a-schedule?hl=en-us" target="_blank" rel="noopener">Cloud scheduler</a></strong><br><a href="https://cloud.google.com/scheduler/docs/start-and-stop-compute-engine-instances-on-a-schedule?hl=en-us" target="_blank" rel="noopener">https://cloud.google.com/scheduler/docs/start-and-stop-compute-engine-instances-on-a-schedule?hl=en-us</a></li>
<li><strong><a href="https://cloud.google.com/sdk/gcloud/reference/beta/compute/instances/add-labelshttps://cloud.google.com/sdk/gcloud/reference/beta/compute/instances/add-labels" target="_blank" rel="noopener">Instances add-labels</a></strong><br><a href="https://cloud.google.com/sdk/gcloud/reference/beta/compute/instances/add-labels" target="_blank" rel="noopener">https://cloud.google.com/sdk/gcloud/reference/beta/compute/instances/add-labels</a></li>
</ol>
]]></content>
      <categories>
        <category>GCP</category>
      </categories>
      <tags>
        <tag>GCP</tag>
        <tag>Cloud Scheduler</tag>
        <tag>Google Pubsub</tag>
      </tags>
  </entry>
  <entry>
    <title>[Google API] 如何處理超過一分鐘語音檔 | Speech to Text API Headle Over 1min File</title>
    <url>/2020/05/24/Google-API-%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E8%B6%85%E9%81%8E%E4%B8%80%E5%88%86%E9%90%98%E8%AA%9E%E9%9F%B3%E6%AA%94-Speech-to-Text-API-Headle-Over-1min-File/</url>
    <content><![CDATA[<h1 id="Google-API-如何處理超過一分鐘語音檔-Speech-to-Text-API-Headle-Over-1min-File"><a href="#Google-API-如何處理超過一分鐘語音檔-Speech-to-Text-API-Headle-Over-1min-File" class="headerlink" title="[Google API] 如何處理超過一分鐘語音檔 | Speech to Text API Headle Over 1min File"></a>[Google API] 如何處理超過一分鐘語音檔 | Speech to Text API Headle Over 1min File</h1><p>Status: Completed</p>
<h2 id="▌目的"><a href="#▌目的" class="headerlink" title="▌目的"></a>▌<strong>目的</strong></h2><ol>
<li>一般使用Speech-to-Text API，如果遇到超過一分鐘檔案，如果遇到以下的錯誤訊息<br>Quota exceeded for quota metric ‘Requests’ and limit ‘Requests per minute，因為你使用到的是Transcribing short audio files</li>
<li>在選單中Transcribing long audio 可以協助你解決I <code>longrunningrecognize</code>檔案的處</li>
<li>完整的<code>Endpoint</code> <a href="https://speech.googleapis.com/v1/speech:longrunningrecognize" target="_blank" rel="noopener">https://speech.googleapis.com/v1/speech:longrunningrecognize</a></li>
</ol>
<hr>
<h2 id="▌1-語音轉換文字-API-Cloud-Speech-to-Text-API"><a href="#▌1-語音轉換文字-API-Cloud-Speech-to-Text-API" class="headerlink" title="▌1. 語音轉換文字 API | Cloud Speech-to-Text API"></a>▌1. 語音轉換文字 API | Cloud Speech-to-Text API</h2><h3 id="1-建立可以授信的-API-key"><a href="#1-建立可以授信的-API-key" class="headerlink" title="1. 建立可以授信的 API key"></a>1. 建立可以授信的 API key</h3><ul>
<li>建立一個憑證Credentials，一般信認的三式有種API Key、OAuth、Service Account</li>
<li>本次使用的API Key</li>
</ul>
<p><img src="Untitled.png" alt="Untitled.png"></p>
<ul>
<li><p>獲取Token Key</p>
<p>  <img src="Untitled1.png" alt="Untitled1.png"></p>
</li>
<li><p>完整Token 資訊</p>
<ul>
<li><p>限制<br>你的Token，可以只針對某些特定的application、HTTP、IP作使用</p>
<p><img src="Untitled2.png" alt="Untitled2.png"></p>
</li>
</ul>
</li>
<li><p>為了待會使用curl，需要做驗證<br>可以先將token設成一個變數，如此作法也較安全<br>不會因為明碼直接外洩</p>
<p>  <img src="Untitled3.png" alt="Untitled3.png"></p>
</li>
</ul>
<h3 id="2-語音檔準備"><a href="#2-語音檔準備" class="headerlink" title="2. 語音檔準備"></a>2. 語音檔準備</h3><ul>
<li>首先找一個超過1分鐘的語音檔案</li>
<li>先存放在<code>Cloud Storage</code>裡面滿並且將權限打開</li>
</ul>
<p><img src="Untitled4.png" alt="Untitled4.png"></p>
<p><img src="Untitled5.png" alt="Untitled5.png"></p>
<h2 id="2-cURL-呼叫-Speech-API"><a href="#2-cURL-呼叫-Speech-API" class="headerlink" title="2. cURL: 呼叫 Speech API"></a>2. <code>cURL</code>: 呼叫 Speech API</h2><h3 id="curl-參數說明"><a href="#curl-參數說明" class="headerlink" title="curl 參數說明"></a>curl 參數說明</h3><ul>
<li><code>-s</code> : –silent 安靜模式，不要顯示任何progress在console，即使有err也是</li>
<li><code>-X POST</code>: -X –request<ul>
<li>一般搭配 [GET|POST|PUT|DELETE|PATCH]<br>使用指定的 http method 來發出 http request</li>
</ul>
</li>
<li><code>-H</code> : 設定 request 裡所攜帶的 header</li>
<li><code>—data-binary</code>: 攜帶 HTTP POST Data</li>
<li><code>-audioChannelCount</code>: 2 聲音檔是雙聲道來源</li>
<li><code>encoding</code> 也就是語音的格式：<code>flac</code>是一種語音格式檔</li>
<li><code>languageCode</code> 語言：en-us(預式都是英文)，我把它調整為<code>zh-TW</code></li>
<li><code>@request.json</code>: 用來夾檔</li>
<li><code>?key=${API_KEY}</code>: 用來餵token</li>
<li><code>&gt; result.json</code>:  內容輸出到指定檔案</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X POST \</span></pre></td></tr><tr><td class="code"><pre><span class="line">     -H <span class="string">"Content-Type: application/json; charset=utf-8"</span> \</span></pre></td></tr><tr><td class="code"><pre><span class="line">     --data <span class="string">"&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">  'config': &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    'encoding':'FLAC',</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    'audioChannelCount': '2',</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    'languageCode': 'zh-TW'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">  &#125;,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">  'audio':&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    'uri':'gs://xxx-voices/0409-xxxx-458.flac'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">  &#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">&#125;"</span> <span class="string">"https://speech.googleapis.com/v1/speech:longrunningrecognize?key=<span class="variable">$&#123;API_KEY&#125;</span>"</span></span></pre></td></tr></table></figure>

<h2 id="3-輸出結果"><a href="#3-輸出結果" class="headerlink" title="3. 輸出結果"></a>3. 輸出結果</h2><h3 id="curl-X-POST"><a href="#curl-X-POST" class="headerlink" title="curl -X POST"></a>curl -X POST</h3><ul>
<li>因為較長的語音檔處理需要一點時間，所以會給你一組ID</li>
<li>透過curl [2]方式取回轉換的文字檔</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">curl -X POST \</span></pre></td></tr><tr><td class="code"><pre><span class="line">     -H "Content-Type: application/json; charset=utf-8" \</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="comment">--data "&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  'config': &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    'encoding':'FLAC',</span></pre></td></tr><tr><td class="code"><pre><span class="line">      'audioChannelCount': '2',</span></pre></td></tr><tr><td class="code"><pre><span class="line">      'languageCode': 'zh-TW'</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  'audio':&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    'uri':'gs://xxx-voices/0409-xxxx-458.flac'</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;" "https://speech.googleapis.com/v1/speech:longrunningrecognize?key=$&#123;API_KEY&#125;" &gt; result1.json</span></pre></td></tr><tr><td class="code"><pre><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span></pre></td></tr><tr><td class="code"><pre><span class="line">100   206    0    36  100   170     25    119  0:00:01  0:00:01 <span class="comment">--:--:--   144</span></span></pre></td></tr></table></figure>

<ul>
<li>產出的name ID取回text: <code>1947xxxxxxxxx006</code></li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># joe.huang @ joehuangs-MacBook-Pro in ~ on git:master x [23:59:15]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ cat result1.json</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  "name": "1947xxxxxxxxx006"</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><img src="Untitled6.png" alt="Untitled6.png"></p>
<h3 id="curl-H"><a href="#curl-H" class="headerlink" title="curl -H"></a>curl -H</h3><ul>
<li>使用產出的name ID取回text</li>
<li>成功將七分鐘的flac語音轉換成text文字，API會自動分段文字</li>
<li>當然後續還是有很多優化的工作要做</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># joe.huang @ joehuangs-MacBook-Pro in ~ on git:master x [0:12:24]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ curl -H "Content-Type: application/json; charset=utf-8" \</span></pre></td></tr><tr><td class="code"><pre><span class="line">     "https://speech.googleapis.com/v1/operations/1947xxxxxxxxxx006?key=$&#123;API_KEY&#125;"</span></pre></td></tr></table></figure>

<p><img src="Untitled7.png" alt="Untitled7.png"></p>
<p><img src="Untitled8.png" alt="Untitled8.png"></p>
<h2 id="▌參考"><a href="#▌參考" class="headerlink" title="▌參考"></a>▌參考</h2><ol>
<li>CURL<br><a href="https://blog.techbridge.cc/2019/02/01/linux-curl-command-tutorial/" target="_blank" rel="noopener">https://blog.techbridge.cc/2019/02/01/linux-curl-command-tutorial/</a></li>
<li><a href="https://cloud.google.com/speech-to-text/docs/async-recognize#speech_transcribe_async_gcs-protocol" target="_blank" rel="noopener">Transcribing long audio files</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>[BigQuery] 淺玩 Date-Partitioned |  Date-Partitioned Tables in BigQuery</title>
    <url>/2020/01/11/BigQuery-%E6%B7%BA%E7%8E%A9-Date-Partitioned-Date-Partitioned-Tables-in-BigQuery/</url>
    <content><![CDATA[<h1 id="BigQuery-淺玩-Date-Partitioned-Date-Partitioned-Tables-in-BigQuery"><a href="#BigQuery-淺玩-Date-Partitioned-Date-Partitioned-Tables-in-BigQuery" class="headerlink" title="[BigQuery] 淺玩 Date-Partitioned |  Date-Partitioned Tables in BigQuery"></a>[BigQuery] 淺玩 Date-Partitioned |  Date-Partitioned Tables in BigQuery</h1><p>Blog URL: <a href="https://www.qwiklabs.com/focuses/3694?parent=catalog" target="_blank" rel="noopener">https://www.qwiklabs.com/focuses/3694?parent=catalog</a><br>Status: Completed<br>Types: BigQuery, GCP</p>
<h2 id="▌什麼是Partition？"><a href="#▌什麼是Partition？" class="headerlink" title="▌什麼是Partition？"></a>▌什麼是Partition？</h2><h3 id="Partition-說明"><a href="#Partition-說明" class="headerlink" title="Partition 說明"></a>Partition 說明</h3><p>Partitioned table是原始table中擷取出來的片段的table，因為原本的table太大，而我們僅拿我們要的資料，所以可以篩選過常用且必需的資料即可。如此可以更簡單管理，且加速query的速度，而增進query的速度也是間接首你節省成本，因為BigQuery的計價是以每一次<a href="https://cloud.google.com/bigquery/pricing?hl=en-us" target="_blank" rel="noopener">query的資料量來計價</a>。</p>
<blockquote>
<p>A partitioned table is a table that is <code>divided into segments, called partitions,</code> that make it easier to manage and query your data. By dividing a large table into smaller partitions, you can improve query performance, and control costs by reducing the number of bytes read by a query.</p>
</blockquote>
<h3 id="Partition-目的"><a href="#Partition-目的" class="headerlink" title="Partition 目的"></a>Partition 目的</h3><p>過去會使用WHERE，拿時間當作條件篩選，這樣的作法同樣也是做全表的掃描，其實是很浪費資源的。如果你只是想要看某個特定時間呢？也是會跑一次全表的掃描，如果有<strong>date-partitioned tables</strong>就增加query的效率，我們僅挑出特定時間就好</p>
<blockquote>
<p>Scanning through the entire dataset everytime to compare rows against a WHERE condition is <code>wasteful</code>. This is especially true if you only really care about records for a specific period of time like:</p>
</blockquote>
<ul>
<li>All transactions for the last year</li>
<li>All visitor interactions within the last 7 days</li>
<li>All products sold in the last month</li>
<li>以百貨業來看，週年慶時期 10-11月</li>
<li>以電子業來看，Q3旺季出貨</li>
</ul>
<h2 id="▌Partition-實作"><a href="#▌Partition-實作" class="headerlink" title="▌Partition 實作"></a>▌Partition 實作</h2><ol>
<li>跑一般全表的 Query</li>
<li>建立Partition Table</li>
<li>實測 Partition Query</li>
<li>比較二次結果</li>
</ol>
<hr>
<h3 id="1-全表的-Query"><a href="#1-全表的-Query" class="headerlink" title="1. 全表的 Query"></a>1. 全表的 Query</h3><p>我們使用公開data，名為<code>data-to-insights.ecommerce.all_sessions_raw</code>，查詢四個fullVisitorId, date, city, pageTitle項目，時間限定在<code>20170708</code>，最後檢視前 5 個記錄</p>
<pre><code>SELECT DISTINCT
  fullVisitorId,
  date,
  city,
  pageTitle
FROM `data-to-insights.ecommerce.all_sessions_raw`
WHERE date = &apos;20170708&apos;
LIMIT 5</code></pre><p><img src="Untitled.png" alt="Untitled.png"></p>
<ul>
<li><p>Sample1: <code>WHERE date = &#39;20170708&#39;</code> in 1.5s (Query complete<br>(1.5 sec elapsed, 1.7 GB processed))</p>
<p>  <img src="Untitled1.png" alt="Untitled1.png"></p>
</li>
</ul>
<h3 id="Worker-timing-in-General-Query"><a href="#Worker-timing-in-General-Query" class="headerlink" title="Worker timing in General Query"></a>Worker timing in General Query</h3><p>Within each stage, workers execute each action according to the query plan. For more information on workers and interpreting results, please see our <a href="https://cloud.google.com/bigquery/query-plan-explanation?hl=en_US&_ga=2.145877300.-1489360639.1577032681#interpreting_results" target="_blank" rel="noopener">documentation</a>.</p>
<ul>
<li>Elapsed time</li>
<li>Slot time consumed</li>
<li>Bytes shuffled</li>
<li>Bytes spilled to disk</li>
</ul>
<p><img src="Untitled2.png" alt="Untitled2.png"></p>
<pre><code>SELECT DISTINCT
  date,
  fullVisitorId,
FROM `data-to-insights.ecommerce.all_sessions_raw`
WHERE date = &apos;20170708&apos;</code></pre><p><img src="Untitled3.png" alt="Untitled3.png"></p>
<ul>
<li>Job Info</li>
</ul>
<p><img src="Untitled4.png" alt="Untitled4.png"></p>
<ul>
<li><p>Execution details</p>
<p>  <img src="Untitled5.png" alt="Untitled5.png"></p>
</li>
</ul>
<h3 id="2-建立-Partition-Table"><a href="#2-建立-Partition-Table" class="headerlink" title="2. 建立 Partition Table"></a>2. 建立 Partition Table</h3><p>Partition Table是依照日期來做切割，你可以看到使用<code>PARSE_DATE()</code>，PARSE_DATE函數用於日期字段(存儲為string)，以便將其轉換為適當的日期類型進行分區。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><blockquote>
<p>Instead of scanning the entire dataset and filtering on a date field like we did in the earlier queries, we will now setup a date-partitioned table. This will allow us to completely ignore scanning records in certain partitions if they are irrelevant to our query.</p>
</blockquote>
<h3 id="PARSE-DATE-format-string-date-string"><a href="#PARSE-DATE-format-string-date-string" class="headerlink" title="PARSE_DATE(format_string, date_string)"></a>PARSE_DATE(format_string, date_string)</h3><p><strong>說明：</strong></p>
<p>使用 <strong><code>format_string</code></strong> 與日期的字串表示傳回 DATE 物件。</p>
<p>使用 <strong><code>PARSE_DATE</code></strong> 時，請注意下列幾點：</p>
<ul>
<li><em>未指定的欄位。</em>任何未指定的欄位都從 <strong><code>1970-01-01</code></strong> 開始。</li>
<li><em>區分大小寫的名稱。</em>例如 <strong><code>Monday</code></strong>、<strong><code>February</code></strong> 等的名稱都不區分大小寫。</li>
<li><em>空白字元。</em>格式字串中的一或多個連續空格字元都符合日期字串中的零或多個連續空格字元。此外，一律允許日期字串中的前置與尾隨空格字元 – 即使它們不在格式字串中也一樣。</li>
<li><em>格式優先順序。</em>當二 (或多) 個格式元素具有重疊資訊 (例如 <strong><code>%F</code></strong> 與 <strong><code>%Y</code></strong> 都影響到年) 時，最後一個格式元素一般會覆寫任何之前的格式元素。</li>
</ul>
<p>如需這個函式支援的格式元素清單，請參閱 <a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/date_functions?hl=zh-tw#supported-format-elements-for-date" target="_blank" rel="noopener">DATE 的支援格式元素</a>。</p>
<p><strong>傳回資料類型：</strong></p>
<p>DATE</p>
<pre><code>#standardSQL
 CREATE OR REPLACE TABLE ecommerce.partition_by_day
 PARTITION BY date_formatted
 OPTIONS(
   description=&quot;a table partitioned by date&quot;
 ) AS

 SELECT DISTINCT
 PARSE_DATE(&quot;%Y%m%d&quot;, date) AS date_formatted, fullvisitorId
 FROM `data-to-insights.ecommerce.all_sessions_raw`</code></pre><ul>
<li><p>執行產生一個partition</p>
<p>  <img src="Untitled6.png" alt="Untitled6.png"></p>
</li>
</ul>
<h3 id="Partition內容"><a href="#Partition內容" class="headerlink" title="Partition內容"></a>Partition內容</h3><p>分別有Schema, Details, Preview</p>
<ul>
<li>Schema<br>從PARSE_DATE(format_string, date_string)處理後，僅留下date_formatted, fullvisitorId</li>
</ul>
<p><img src="Untitled7.png" alt="Untitled7.png"></p>
<ul>
<li>Preview<br>依據date_formatted, fullvisitorId<br>從原本21,552,195 經過<code>SELECT DISICT</code>篩選剩下478,323 row</li>
</ul>
<p><img src="Untitled8.png" alt="Untitled8.png"></p>
<ul>
<li><p>Details<br>我們再來細看裡面的內容</p>
<ul>
<li><p><strong>Table size:</strong> 只剩下13.17MB</p>
</li>
<li><p><strong>Table type:</strong> 已不是<code>table</code>, <strong>而是</strong><code>Partitioned</code></p>
<p><img src="Untitled9.png" alt="Untitled9.png"></p>
</li>
</ul>
</li>
</ul>
<h3 id="Create-pb-results"><a href="#Create-pb-results" class="headerlink" title="Create_pb results"></a>Create_pb results</h3><ul>
<li><p>Job Info</p>
<p>  <img src="Untitled10.png" alt="Untitled10.png"></p>
</li>
<li><p>execution</p>
<p>  <img src="Untitled11.png" alt="Untitled11.png"></p>
</li>
<li><p>Worker timing</p>
<p>  <img src="Untitled12.png" alt="Untitled12.png"></p>
</li>
</ul>
<h2 id="3-實測-Partition-Query"><a href="#3-實測-Partition-Query" class="headerlink" title="3. 實測 Partition Query"></a>3. 實測 Partition Query</h2><p>原本目標FROM <code>data-to-insights.ecommerce.all_sessions_raw</code><br>換成data-to-insights.pb_test.partition_by_day，也就是partition</p>
<pre><code>#standardSQL
SELECT *
FROM `pb_test.partition_by_day`
WHERE date_formatted = &apos;2017-07-08&apos;

#Or
SELECT DISTINCT
  date_formatted,
  fullVisitorId,
FROM `pb_test.partition_by_day`
WHERE date_formatted = &apos;2017-07-08&apos;</code></pre><ul>
<li><p>Query results in <code>0.4s</code><br>時間僅用了0.4秒小於全表的查詢，相信你的表越大，經過partition的篩選效果會更顯著</p>
<p>  <img src="Untitled13.png" alt="Untitled13.png"></p>
<ul>
<li><p>execution details</p>
<p>  <img src="Untitled14.png" alt="Untitled14.png"></p>
</li>
<li><p>Worker timing</p>
<p>  <img src="Untitled15.png" alt="Untitled15.png"></p>
</li>
<li><p>Others query 2018-06-08</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>為什麼這麼快呢，因為只跑了37.2KB的data<br>Query complete (0.4 sec elapsed, 37.2 KB processed)<br>這次處理的37.2KB，這只是你查詢的一小小小小部份</p>
</blockquote>
<h3 id="4-結論：比較二次結果"><a href="#4-結論：比較二次結果" class="headerlink" title="4. 結論：比較二次結果"></a>4. 結論：比較二次結果</h3><p>速度結果主要取決於「Table大小」、「read time」、「compute time」，因此只要善用Patitioned table，就可以同時降低以上三個關鍵因素，不管理讀取資料或是運行時間</p>
<p><img src="Untitled16.png" alt="Untitled16.png"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h2><ol>
<li>Worker timing in General Query<br><a href="https://cloud.google.com/bigquery/query-plan-explanation?hl=en_US" target="_blank" rel="noopener">https://cloud.google.com/bigquery/query-plan-explanation?hl=en_US</a></li>
<li>Creating Date-Partitioned Tables in BigQuery<br><a href="https://www.qwiklabs.com/focuses/3694?parent=catalog" target="_blank" rel="noopener">https://www.qwiklabs.com/focuses/3694?parent=catalog</a></li>
</ol>
]]></content>
      <categories>
        <category>GCP</category>
      </categories>
      <tags>
        <tag>GCP</tag>
        <tag>BigQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>[Google API] 有靈魂的Google小姐，使用 SSML技術強化Text-to-Speech</title>
    <url>/2020/07/02/Google-API-%E6%9C%89%E9%9D%88%E9%AD%82%E7%9A%84Google%E5%B0%8F%E5%A7%90%EF%BC%8C%E4%BD%BF%E7%94%A8-SSML%E6%8A%80%E8%A1%93%E5%BC%B7%E5%8C%96Text-to-Speech/</url>
    <content><![CDATA[<h1 id="什麼是SSML-Speech-Synthesis-Markup-Language"><a href="#什麼是SSML-Speech-Synthesis-Markup-Language" class="headerlink" title="什麼是SSML(Speech Synthesis Markup Language)"></a>什麼是<a href="https://cloud.google.com/text-to-speech/docs/ssml?hl=zh-tw" target="_blank" rel="noopener">SSML(Speech Synthesis Markup Language)</a></h1><p>語音合成標記語言(SSML)可以讓語音生成更有靈魂！它是 XML-formatted標記語法，提供更多生音生成的細節，透過提供關於eg. 暫停的細節，以及應該被審查的首字母縮寫、日期、時間、縮寫或文本的音頻格式，從而允許對音頻響應進行更多客製。</p>
<h1 id="參數介紹"><a href="#參數介紹" class="headerlink" title="參數介紹"></a>參數介紹</h1><p>您可以使用 SSML 標記來自訂語音，例如加入停頓點、數字、日期與時間格式設定，以及其他發音指示。完整的標記共有12種，以下</p>
<p><img src="Untitled.png" alt="Untitled.png"></p>
<h3 id="簡介參數"><a href="#簡介參數" class="headerlink" title="簡介參數"></a>簡介參數</h3><ol>
<li><p><code>&lt;break&gt;</code>可以設定延遲若干毫秒，或是尾音變弱</p>
<ul>
<li>延遲<break time="200ms"/></li>
<li>控制尾音變弱<break strength="weak"/></li>
</ul>
</li>
<li><p><code>&lt;say-as&gt;</code> 用來處理數字，看到 “1”</p>
<ul>
<li>我們可以指定讀作ordinal “First”，而不是One</li>
</ul>
</li>
<li><p><code>&lt;sub&gt;</code> 用來處理縮寫的文字發音</p>
<ul>
<li>W3C, 我們要指定唸為”World Wide Web Consortium” 而不是W3C單一字母發音</li>
</ul>
</li>
<li><p><code>&lt;prosody&gt;</code> 除全文的pitch設定之外，你還可以針對各別句字、文字的設定pitch</p>
</li>
<li><p><code>&lt;s&gt;</code> 除了text中的句號之外，可以自已指定句字的範圍</p>
</li>
</ol>
<h3 id="SSML操作"><a href="#SSML操作" class="headerlink" title="SSML操作"></a>SSML操作</h3><ul>
<li>了解一下SSM置入的位置<br>我們可以從官方體驗頁面，可以看到標記<code>&lt;break time=&quot;400ms&quot;/&gt;</code></li>
<li>範例的應用是使句尾延遲 400ms，讓語音不要太早到下一個段落，好使聽者有時間思考</li>
</ul>
<p><img src="Untitled1.png" alt="Untitled1.png"></p>
<h1 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h1><h3 id="Step-1-Create-synthetic-speech-from-text"><a href="#Step-1-Create-synthetic-speech-from-text" class="headerlink" title="Step 1. Create synthetic speech from text"></a>Step 1. Create synthetic speech from text</h3><ul>
<li><p>Token準備：使用當前auth token<br>gcloud auth application-default print-access-token</p>
</li>
<li><p>選擇發音的語系voice source，可以參考以下<br><a href="https://cloud.google.com/text-to-speech/docs/voices" target="_blank" rel="noopener">https://cloud.google.com/text-to-speech/docs/voices</a></p>
</li>
<li><p>再來就是最重要的部驟，需要生成一個json檔：<code>synthesize-text.json</code></p>
<p>  其中JSON-formatted 參數值如下，分成三大塊</p>
<ol>
<li><code>input</code> 主要生成語音的文字內容</li>
<li><code>voice</code> 生成聲音的語言、發音版本、是否使用SSML</li>
<li><code>audioConfig</code> 聲音編碼的格式</li>
</ol>
</li>
</ul>
<h3 id="Step-2-Create-synthetic-speech-from-SSML"><a href="#Step-2-Create-synthetic-speech-from-SSML" class="headerlink" title="Step 2: Create synthetic speech from SSML"></a>Step 2: Create synthetic speech from SSML</h3><ul>
<li>範例 synthesize-ssml.json，採用了以下<br><code>&lt;speak&gt;</code>  <code>&lt;s&gt;</code>  <code>&lt;emphasis&gt;</code><br><code>&lt;prosody&gt;</code>  <code>&lt;say-as&gt;</code>  <code>&lt;break&gt;</code></li>
<li>讓整體語音聽起真像是真的人說話的感覺，對於英文來說intonation，意思就是可以讓聽眾更清楚你講話的重點</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    'input':&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        'ssml':'<span class="tag">&lt;<span class="name">speak</span>&gt;</span><span class="tag">&lt;<span class="name">s</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="tag">&lt;<span class="name">emphasis</span> <span class="attr">level</span>=<span class="string">"moderate"</span>&gt;</span>Cloud Text-to-Speech API<span class="tag">&lt;/<span class="name">emphasis</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">           allows developers to include natural-sounding</span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="tag">&lt;<span class="name">break</span> <span class="attr">strength</span>=<span class="string">"x-weak"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">           synthetic human speech as playable audio in their</span></pre></td></tr><tr><td class="code"><pre><span class="line">           applications.<span class="tag">&lt;/<span class="name">s</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="tag">&lt;<span class="name">s</span>&gt;</span>The Text-to-Speech API converts text or</span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="tag">&lt;<span class="name">prosody</span> <span class="attr">rate</span>=<span class="string">"slow"</span>&gt;</span>Speech Synthesis Markup Language<span class="tag">&lt;/<span class="name">prosody</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="tag">&lt;<span class="name">say-as</span> <span class="attr">interpret-as</span>=<span class="string">\</span>"<span class="attr">characters</span>\"&gt;</span>SSML<span class="tag">&lt;/<span class="name">say-as</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">           input into audio data</span></pre></td></tr><tr><td class="code"><pre><span class="line">           like <span class="tag">&lt;<span class="name">say-as</span> <span class="attr">interpret-as</span>=<span class="string">\</span>"<span class="attr">characters</span>\"&gt;</span>MP3<span class="tag">&lt;/<span class="name">say-as</span>&gt;</span> or</span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="tag">&lt;<span class="name">sub</span> <span class="attr">alias</span>=<span class="string">"linear sixteen"</span>&gt;</span>LINEAR16<span class="tag">&lt;/<span class="name">sub</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="tag">&lt;<span class="name">break</span> <span class="attr">strength</span>=<span class="string">"weak"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">           (the encoding used in</span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="tag">&lt;<span class="name">sub</span> <span class="attr">alias</span>=<span class="string">"wave"</span>&gt;</span>WAV<span class="tag">&lt;/<span class="name">sub</span>&gt;</span> files).<span class="tag">&lt;/<span class="name">s</span>&gt;</span><span class="tag">&lt;/<span class="name">speak</span>&gt;</span>'</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    'voice':&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        'languageCode':'en-gb',</span></pre></td></tr><tr><td class="code"><pre><span class="line">        'name':'en-GB-Standard-A',</span></pre></td></tr><tr><td class="code"><pre><span class="line">        'ssmlGender':'FEMALE'</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    'audioConfig':&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        'audioEncoding':'MP3'</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>執行代碼</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -H <span class="string">"Authorization: Bearer "</span>$(gcloud auth application-default <span class="built_in">print</span>-access-token) \</span></pre></td></tr><tr><td class="code"><pre><span class="line">  -H <span class="string">"Content-Type: application/json; charset=utf-8"</span> \</span></pre></td></tr><tr><td class="code"><pre><span class="line">  -d @synthesize-ssml.json <span class="string">"https://texttospeech.googleapis.com/v1/text:synthesize"</span> \</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &gt; synthesize-ssml.txt</span></pre></td></tr></table></figure>

<p>運行結果</p>
<p><img src="Untitled2.png" alt="Untitled2.png"></p>
<h3 id="Step-3-python-decode"><a href="#Step-3-python-decode" class="headerlink" title="Step 3. python decode"></a>Step 3. python decode</h3><ul>
<li>這邊一邊需要decode動作，來把加密的text先解密再轉換成語音</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python tts_decode.py --input <span class="string">"synthesize-ssml.txt"</span> --output <span class="string">"synthesize-ssml-audio.mp3"</span></span></pre></td></tr></table></figure>

<ul>
<li>index.html</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Cloud Text-to-Speech Demo<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Output from synthesizing text:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"synthesize-text-audio.mp3"</span> /&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Output from synthesizing SSML:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"synthesize-ssml-audio.mp3"</span> /&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></pre></td></tr></table></figure>

<h3 id="Step-4-語音驗證"><a href="#Step-4-語音驗證" class="headerlink" title="Step 4.語音驗證"></a>Step 4.語音驗證</h3><ul>
<li>最後最出2個檔案，分別是有無使用SSML生成語音，可以比較二種不同的感覺</li>
<li>因為範例把SSML運用得淋淋盡致，使得效果非常的明顯</li>
<li>如果你沒法執行程式，可以直接使用<a href="https://cloud.google.com/text-to-speech" target="_blank" rel="noopener">Google官方測試頁</a>面體驗，把Step 2代表直接貼進去</li>
</ul>
<p><img src="Untitled3.png" alt="Untitled3.png"></p>
<h1 id="References"><a href="#References" class="headerlink" title="References:"></a>References:</h1><ol>
<li><a href="https://zh.wikipedia.org/wiki/WaveNet" target="_blank" rel="noopener">WaveNet Wiki</a></li>
<li><a href="https://www.qwiklabs.com/focuses/1290?catalog_rank=%7B%22rank%22%3A1%2C%22num_filters%22%3A0%2C%22has_search%22%3Atrue%7D&parent=catalog&search_id=6083809" target="_blank" rel="noopener">It Speaks! Create Synthetic Speech Using Cloud Text-to-Speech</a></li>
<li><a href="https://cloud.google.com/text-to-speech" target="_blank" rel="noopener">Google Text-to-Speech</a></li>
</ol>
]]></content>
      <categories>
        <category>GCP API</category>
      </categories>
      <tags>
        <tag>GCP</tag>
        <tag>API</tag>
        <tag>texttospeech</tag>
        <tag>SSML</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s Kube apiserver How does api flow work</title>
    <url>/2020/02/11/K8s-Kube-apiserver-How-does-api-flow-work/</url>
    <content><![CDATA[<h1 id="K8s-Kube-apiserver-工作流程-How-does-api-flow-work"><a href="#K8s-Kube-apiserver-工作流程-How-does-api-flow-work" class="headerlink" title="[K8s] Kube-apiserver 工作流程 | How does api-flow work?"></a>[K8s] Kube-apiserver 工作流程 | How does api-flow work?</h1><h2 id="▌什麼是-Kube-apiserver？"><a href="#▌什麼是-Kube-apiserver？" class="headerlink" title="▌什麼是 Kube-apiserver？"></a>▌什麼是 Kube-apiserver？</h2><p>kube-apiserver 是 Kubernetes 最重要的核心組件之一，它的位置在master node裡面</p>
<p>主要功能就是提供cluster管理，下面會用二個例跟大家來說明</p>
<p><img src="Untitled.png" alt="Untitled.png"></p>
<p>Core Components of K8s</p>
<ul>
<li><p><strong>REST API ：</strong>包括<code>認證授權</code>、<code>數據校驗</code>以及<code>集群狀態變</code>更等</p>
</li>
<li><p><strong>通信樞紐   ：</strong>提供其他Components之間的資料交互和通信的樞紐</p>
<ul>
<li><p>樞紐指的是：其他Components，包括worker kublet, kube-proxy 與 master node等等，可以通過 API Server 查詢或修改數據</p>
</li>
<li><p>這邊要注意一個重點就是，只有 API Server 才<code>直接操作 etcd</code><br>有沒有注意到只有kube-apiserver有畫線到etcd</p>
<p>  <img src="Untitled1.png" alt="Untitled 1.png"></p>
<p>  以Client Certificates 檢視</p>
</li>
</ul>
</li>
</ul>
<h2 id="▌實例說明：以建立一個nginx為例"><a href="#▌實例說明：以建立一個nginx為例" class="headerlink" title="▌實例說明：以建立一個nginx為例"></a>▌實例說明：以建立一個nginx為例</h2><ol>
<li><p>APIServer: 是專門負責接收kubectl送出來的命令，<br>比如：我們通過kubectl 通過APIServe r告訴它，我們要創建一個service/pod </p>
<pre><code>$kubectl apply -f ngnix-service.yml</code></pre></li>
<li><p>APIServer 接收到命令後，會把<code>指令</code>和<code>參數</code>存在etcd裡面</p>
<ul>
<li>kubelet 是管理 pod，也就是管理container創建跟刪除</li>
<li>kube-proxy 主要是用來管理網路，它會透過iptables(灰色)去創立policy<br>來確保service可以向外溝通</li>
</ul>
</li>
<li><p>完整的過程即是kubelet 和 kube-proxy會一直<code>監聽</code>etcd裡面有什麼改變， 若發現有新的指令(指上面kubectl apply)，它就知道有新的service/pod 要創建，就會在相應的node上建立service/pod -</p>
<ul>
<li>k8s-node1 長出<code>pod</code> (紫色)</li>
<li>同時也因應網路的需求建立 <code>iptables</code> (灰色)</li>
</ul>
</li>
</ol>
<p><img src="Untitled2.png" alt="Untitled 2.png"></p>
<h2 id="▌實例說明2-建一個Service"><a href="#▌實例說明2-建一個Service" class="headerlink" title="▌實例說明2: 建一個Service"></a>▌實例說明2: 建一個Service</h2><ul>
<li><p>當一個service建立好時，kube-poxy會一併建立routing</p>
<p>  <img src="Untitled3.png" alt="Untitled 3.png"></p>
</li>
</ul>
<p>可以用kube log來看service建立了什麼<br>不用看完整的iptables</p>
<p><img src="Untitled4.png" alt="Untitled 4.png"></p>
<p>service配多少的ip range 可以從ps aux 看喔</p>
<p><img src="Untitled5.png" alt="Untitled 5.png"></p>
<p>iptables 看service + grep</p>
<p><img src="Untitled6.png" alt="Untitled 6.png"></p>
]]></content>
      <categories>
        <category>K8s</category>
      </categories>
      <tags>
        <tag>K8s</tag>
        <tag>kube-api</tag>
      </tags>
  </entry>
  <entry>
    <title>[Google API] 語音轉換、翻譯 API | Speech to Text Transcription with the Cloud Speech API</title>
    <url>/2020/03/16/Google-API-%E8%AA%9E%E9%9F%B3%E8%BD%89%E6%8F%9B%E3%80%81%E7%BF%BB%E8%AD%AF-API-Speech-to-Text-Transcription-with-the-Cloud-Speech-API/</url>
    <content><![CDATA[<h1 id="Google-API-語音轉換、翻譯-API-Speech-to-Text-Transcription-with-the-Cloud-Speech-API"><a href="#Google-API-語音轉換、翻譯-API-Speech-to-Text-Transcription-with-the-Cloud-Speech-API" class="headerlink" title="[Google API] 語音轉換、翻譯 API | Speech to Text Transcription with the Cloud Speech API"></a>[Google API] 語音轉換、翻譯 API | Speech to Text Transcription with the Cloud Speech API</h1><p>Status: Completed</p>
<h2 id="▌目的"><a href="#▌目的" class="headerlink" title="▌目的"></a>▌<strong>目的</strong></h2><ol>
<li>使用<code>curl</code> 發送API請求，協助轉換語音到文字 Creating a Speech API request and calling the API with curl</li>
<li>面對各國不同語言情境，可以調整語音辨語言</li>
</ol>
<hr>
<h2 id="▌1-語音轉換文字-API-Cloud-Speech-to-Text-API"><a href="#▌1-語音轉換文字-API-Cloud-Speech-to-Text-API" class="headerlink" title="▌1. 語音轉換文字 API | Cloud Speech-to-Text API"></a>▌1. 語音轉換文字 API | Cloud Speech-to-Text API</h2><h3 id="1-建立可以授信的-API-key"><a href="#1-建立可以授信的-API-key" class="headerlink" title="1. 建立可以授信的 API key"></a>1. 建立可以授信的 API key</h3><ul>
<li>建立一個憑證Credentials，一般信認的三式有種API Key、OAuth、Service Account</li>
<li>本次使用的API Key</li>
</ul>
<p><img src="Untitled.png" alt="Untitled.png"></p>
<ul>
<li><p>獲取Token Key</p>
<p>  <img src="Untitled1.png" alt="Untitled1.png"></p>
</li>
<li><p>完整Token 資訊</p>
<ul>
<li><p>限制<br>你的Token，可以只針對某些特定的application、HTTP、IP作使用</p>
<p><img src="Untitled2.png" alt="Untitled2.png"></p>
</li>
</ul>
</li>
<li><p>為了待會使用curl，需要做驗證<br>可以先將token設成一個變數，如此作法也較安全<br>不會因為明碼直接外洩</p>
<p>  <img src="Untitled3.png" alt="Untitled3.png"></p>
</li>
</ul>
<h3 id="2-準備一個語音檔Create-your-Speech-API-request"><a href="#2-準備一個語音檔Create-your-Speech-API-request" class="headerlink" title="2. 準備一個語音檔Create your Speech API request"></a>2. 準備一個語音檔Create your Speech API request</h3><p>準備一個json裡面要告知API語音的資訊</p>
<ul>
<li><p>encoding 也就是語音的格式：<code>flac</code>是一種語音格式檔</p>
</li>
<li><p>languageCode 語言：en-us(預式都是英文)</p>
<p>  <img src="Untitled4.png" alt="Untitled4.png"></p>
</li>
</ul>
<p>*補充encoding格式說明</p>
<p><a href="https://cloud.google.com/speech-to-text/docs/reference/rest/v1/RecognitionConfig" target="_blank" rel="noopener">https://cloud.google.com/speech-to-text/docs/reference/rest/v1/RecognitionConfig</a></p>
<h3 id="3-cURL-呼叫-Speech-API"><a href="#3-cURL-呼叫-Speech-API" class="headerlink" title="3. cURL: 呼叫 Speech API"></a>3. <code>cURL</code>: 呼叫 Speech API</h3><h3 id="curl-參數說明"><a href="#curl-參數說明" class="headerlink" title="curl 參數說明"></a>curl 參數說明</h3><ul>
<li><p><code>-s</code> : –silent 安靜模式，不要顯示任何progress在console，即使有err也是</p>
</li>
<li><p><code>-X POST</code>: -X –request</p>
<ul>
<li>一般搭配 [GET|POST|PUT|DELETE|PATCH]<br>使用指定的 http method 來發出 http request</li>
</ul>
</li>
<li><p><code>-H</code> : 設定 request 裡所攜帶的 header</p>
</li>
<li><p><code>—data-binary</code>: 攜帶 HTTP POST Data</p>
</li>
<li><p><code>@request.json</code>: 用來夾檔</p>
</li>
<li><p><code>?key=${API_KEY}</code>: 用來餵toke n</p>
</li>
<li><p><code>&gt; result.jso</code>n:  內容輸出到指定檔案</p>
<p>  curl -s -X POST -H “Content-Type: application/json” –data-binary @request.json <br>  “<a href="https://speech.googleapis.com/v1/speech:recognize?ey=${API_KEY}&quot;" target="_blank" rel="noopener">https://speech.googleapis.com/v1/speech:recognize?ey=${API_KEY}&quot;</a> &gt; result.json</p>
</li>
</ul>
<h3 id="4-輸出結果"><a href="#4-輸出結果" class="headerlink" title="4. 輸出結果"></a>4. 輸出結果</h3><p>將flac語音轉換成text文字，也附上轉的confidence指數高達98%，代表它的翻譯準確程度</p>
<p><img src="Untitled5.png" alt="Untitled5.png"></p>
<hr>
<hr>
<h2 id="▌2-翻譯-API-Cloud-Translation-API"><a href="#▌2-翻譯-API-Cloud-Translation-API" class="headerlink" title="▌2. 翻譯 API | Cloud Translation API"></a>▌2. 翻譯 API | Cloud Translation API</h2><h3 id="1-Create-an-API-Key"><a href="#1-Create-an-API-Key" class="headerlink" title="1. Create an API Key"></a>1. Create an API Key</h3><p>基本上跟上面的例子一樣，建一個token供API request使用</p>
<p><img src="Untitled6.png" alt="Untitled6.png"></p>
<h3 id="2-開始翻譯-Translate-Text"><a href="#2-開始翻譯-Translate-Text" class="headerlink" title="2. 開始翻譯 | Translate Text"></a>2. 開始翻譯 | Translate Text</h3><ul>
<li><p>範例一：把字串”My name is Steve” 英文翻譯成西班牙文</p>
</li>
<li><p><code>TEXT</code>：存放英文字串</p>
</li>
<li><p>這裡的空白為 </p>
<p>  #string<br>  TEXT=”My name is Steve”</p>
<h1 id="api-request"><a href="#api-request" class="headerlink" title="api request"></a>api request</h1><p>  curl “<a href="https://translation.googleapis.com/language/translate/v2?target=es&amp;key=${API_KEY}&amp;q=${TEXT}&quot;">https://translation.googleapis.com/language/translate/v2?target=es&amp;key=${API_KEY}&amp;q=${TEXT}&quot;</a></p>
</li>
<li><p>Response<br>成功幫你翻譯為西文 → “Mi nombre es Steve”</p>
<p>  <img src="Untitled7.png" alt="Untitled7.png"></p>
</li>
</ul>
<h3 id="3-多國語言翻譯"><a href="#3-多國語言翻譯" class="headerlink" title="3. 多國語言翻譯"></a>3. 多國語言翻譯</h3><p>Translation API  的另一個功能可以協助偵測不同國語言</p>
<ul>
<li><p><code>TEXT</code> 這邊設定二組字串有葡萄文跟日文</p>
</li>
<li><p><code>&amp;q</code>= 可以吃多個變數，一起使用同一次request，也算是省錢吧!?<br>其實沒有，因為計價的方式來自$20 per million characters*</p>
<p>  TEXT_ONE=”Meu nome é Steven”<br>  TEXT_TWO=”日本のグーグルのオフィスは、東京の六本木ヒルズにあります”</p>
</li>
</ul>
<pre><code>curl &quot;https://translation.googleapis.com/language/translate/v2/detect?key=${API_KEY}&amp;q=${TEXT_ONE}&amp;q=${TEXT_TWO}&quot;</code></pre><p>結果回傳<code>&quot;pt&quot;</code> 、 <code>&quot;ja&quot;</code> 代表這二組字串分別來葡萄牙語與日文</p>
<ul>
<li><p>而語文的簡碼可以參考 <a href="https://zh.wikipedia.org/wiki/ISO_639-1" target="_blank" rel="noopener">ISO-639-1</a> 所定義的各國簡碼</p>
<p>  <img src="Untitled8.png" alt="Untitled8.png"></p>
<p>  清楚版</p>
<pre><code>{
  &quot;data&quot;: {
    &quot;detections&quot;: [
      [
        {
          &quot;confidence&quot;: 0.20671661198139191,
          &quot;isReliable&quot;: false,
          &quot;language&quot;: &quot;pt&quot;
        }
      ],
      [
        {
          &quot;confidence&quot;: 0.97750955820083618,
          &quot;isReliable&quot;: false,
          &quot;language&quot;: &quot;ja&quot;
        }
      ]
    ]
  }
}</code></pre></li>
</ul>
<hr>
<h2 id="▌3-Google-Cloud-API-with-POSTMAN"><a href="#▌3-Google-Cloud-API-with-POSTMAN" class="headerlink" title="▌3. Google Cloud API with POSTMAN"></a>▌3. Google Cloud API with POSTMAN</h2><p>上述的例子都是使用curl直接request，這邊換一個postman來發出request。這邊不同的於curl的方式，我們可以把token存在option中，且json request也可以寫在body當中</p>
<h3 id="1-POSTMAN-驗證-Authorization"><a href="#1-POSTMAN-驗證-Authorization" class="headerlink" title="1. POSTMAN 驗證 | Authorization"></a>1. POSTMAN 驗證 | Authorization</h3><ul>
<li><p>Auth類型: API Key<br>作法一樣至Credentials得到一組token</p>
<ul>
<li><p>帶入API URI<br><code>https://speech.googleapis.com/v1/speech:recognize?key=AI...........o</code></p>
<p><img src="Untitled9.png" alt="Untitled9.png"></p>
</li>
</ul>
</li>
</ul>
<h3 id="2-請求-JSON"><a href="#2-請求-JSON" class="headerlink" title="2. 請求 JSON"></a>2. 請求 JSON</h3><ul>
<li><p>轉入的 json 可以直接寫在body內，原則上跟上面的例子一樣<br>告知檔案格式與flac的來源與格式</p>
<pre><code>{
  &quot;config&quot;: {
      &quot;encoding&quot;:&quot;FLAC&quot;,
      &quot;languageCode&quot;: &quot;en-US&quot;
  },
  &quot;audio&quot;: {
      &quot;uri&quot;:&quot;gs://cloud-samples-tests/speech/brooklyn.flac&quot;
  }
}</code></pre><p>  Body: JSON</p>
<ul>
<li><p>寫入body，記得也要轉換JSON</p>
<p><img src="Untitled10.png" alt="Untitled10.png"></p>
</li>
</ul>
</li>
</ul>
<h3 id="3-執行"><a href="#3-執行" class="headerlink" title="3. 執行"></a>3. 執行</h3><ul>
<li><p>response結果<br>成功將語音轉換成文字</p>
<p>  <img src="Untitled11.png" alt="Untitled11.png"></p>
</li>
</ul>
<hr>
<h2 id="▌參考"><a href="#▌參考" class="headerlink" title="▌參考"></a>▌參考</h2><ol>
<li><p>CURL<br><a href="https://blog.techbridge.cc/2019/02/01/linux-curl-command-tutorial/" target="_blank" rel="noopener">https://blog.techbridge.cc/2019/02/01/linux-curl-command-tutorial/</a></p>
</li>
<li><p>Speech to Text Transcription with the Cloud Speech API</p>
<p> <a href="https://www.qwiklabs.com/focuses/2187?catalog_rank=%7B%22rank%22%3A5%2C%22num_filters%22%3A0%2C%22has_search%22%3Atrue%7D&parent=catalog&search_id=4748950" target="_blank" rel="noopener">https://www.qwiklabs.com/focuses/2187?catalog_rank=%7B%22rank%22%3A5%2C%22num_filters%22%3A0%2C%22has_search%22%3Atrue%7D&amp;parent=catalog&amp;search_id=4748950</a></p>
</li>
<li><p>翻譯 API | Translate Text with the Cloud Translation API</p>
<p> <a href="https://google.qwiklabs.com/focuses/697?catalog_rank=%7B%22rank%22%3A2%2C%22num_filters%22%3A0%2C%22has_search%22%3Atrue%7D&parent=catalog&search_id=4767216" target="_blank" rel="noopener">Translate Text with the Cloud Translation API | Qwiklabs</a></p>
</li>
<li><p>POSTMAN with Speech API</p>
<p> <a href="https://medium.com/@pnatraj/google-cloud-api-with-postman-f4cf070e665f" target="_blank" rel="noopener">Google Cloud API with POSTMAN</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>GCP API</category>
      </categories>
      <tags>
        <tag>GCP</tag>
        <tag>API</tag>
        <tag>texttospeech</tag>
        <tag>speechtotext</tag>
        <tag>auth</tag>
      </tags>
  </entry>
  <entry>
    <title>[Istio] 多組K8s叢集，實作統一Istio 管理 | Anthos Shared Control Plane in Multi-Cluster</title>
    <url>/2020/08/23/Istio-%E5%A4%9A%E7%B5%84K8s%E5%8F%A2%E9%9B%86%EF%BC%8C%E5%AF%A6%E4%BD%9C%E7%B5%B1%E4%B8%80Istio-%E7%AE%A1%E7%90%86-Anthos-Shared-Control-Plane-in-Multi-Cluster/</url>
    <content><![CDATA[<p>多組K8s叢集管理，需要注意的重點有二件事，第一就是叢集(cluster)切換，不可或缺的工具有kubectx, kubens，有了它們就能輕鬆在多個背景及命名空間之間做轉換。再來</p>
<p>如果你需要更深入轉換整個kubernetes系統時，你可以參考</p>
<ul>
<li><code>Rancher</code> 是以UI 介面出發來集中管理多重叢集，它可以設定穿越地端與多組雲端託管的kubernetes</li>
<li><code>KQueen</code> 是open source 是由Mirantis員工所開發，提供一個共用型的自助式kubernetes</li>
<li><code>Grandener</code> 是由SAP公司所開發，多是利用kubernetes 原生API建構</li>
</ul>
<p>但是身為Google Partner，今天要跟大家介紹Anthos，透過它的跨雲地功能，一樣可以達到多組K8s叢集管理能力，而且裡面整合的Istio，可以供二組以上的叢集共用一個<code>Istio Control plane</code>。</p>
<h1 id="完整架構圖"><a href="#完整架構圖" class="headerlink" title="完整架構圖"></a>完整架構圖</h1><ul>
<li>一個完整的購物網站<code>Hipster Shop</code> 服務座落在二個cluster 分別在不同的region</li>
<li>想要透過同一組的istio去控管二邊的service</li>
<li>使用 <em>remote</em> configuration連線到單一個 Control plane(single Istio control plane)</li>
<li>實際運作remote Envoy與Control plane溝通，形成Shared control plane</li>
</ul>
<p><img src="Untitled.png" alt="Untitled.png"></p>
<h1 id="實作目的"><a href="#實作目的" class="headerlink" title="實作目的"></a>實作目的</h1><ol>
<li>首先要建立2 GKE clusters 環境</li>
<li>建立屬二個 GKE 溝通時的firewall rules ，使二個clusters可以溝通</li>
<li>於Cluster 1安裝  <code>Istio control plane</code></li>
<li>於Cluster 2安裝<code>Istio remote</code></li>
<li>使 Cluster 2 <code>Istio remote</code> 連線至Cluster 1</li>
<li>部署 the Hipster Shop multi-service application 在二個Cluster</li>
<li>確認 Hipster Shop 服務是否正常運行於二個Cluster</li>
</ol>
<h1 id="Task-1-Ready-2-GKE-Cluster"><a href="#Task-1-Ready-2-GKE-Cluster" class="headerlink" title="Task 1. Ready 2 GKE Cluster"></a>Task 1. Ready 2 GKE Cluster</h1><p>準二個Cluster</p>
<ul>
<li>A GKE cluster, named <code>cluster-1</code>, in the <code>us-east1</code> region.</li>
<li>A GKE cluster, named <code>cluster-2</code>, in the <code>us-central1</code> region.</li>
</ul>
<p><img src="Untitled1.png" alt="Untitled1.png"></p>
<h3 id="Step1-Get-credentials-of-each-GKE"><a href="#Step1-Get-credentials-of-each-GKE" class="headerlink" title="Step1. Get credentials of each GKE"></a>Step1. Get credentials of each GKE</h3><ul>
<li>要先拿到<code>credentials</code>方能進入二個Cluster</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1. config cluster-1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> CLUSTER1_NAME=cluster-1</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> CLUSTER1_ZONE=us-east1-b</span></pre></td></tr><tr><td class="code"><pre><span class="line">gcloud container clusters get-credentials <span class="variable">$CLUSTER1_NAME</span> \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    --zone <span class="variable">$CLUSTER1_ZONE</span> --project <span class="variable">$PROJECT_ID</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#2. config cluster-2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> CLUSTER2_NAME=cluster-2</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> CLUSTER2_ZONE=us-central1-b</span></pre></td></tr><tr><td class="code"><pre><span class="line">gcloud container clusters get-credentials <span class="variable">$CLUSTER2_NAME</span> \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    --zone <span class="variable">$CLUSTER2_ZONE</span> --project <span class="variable">$PROJECT_ID</span></span></pre></td></tr></table></figure>

<p><img src="Untitled2.png" alt="Untitled2.png"></p>
<h3 id="Step2-Check-cluster-configurations"><a href="#Step2-Check-cluster-configurations" class="headerlink" title="Step2. Check cluster configurations"></a>Step2. Check cluster configurations</h3><ul>
<li>check cluster config, 可以看到<ul>
<li>各別的cluster configurations</li>
<li>它們使用的key</li>
<li>server address</li>
</ul>
</li>
</ul>
<p><img src="Untitled3.png" alt="Untitled3.png"></p>
<h3 id="Step3-kubectx"><a href="#Step3-kubectx" class="headerlink" title="Step3. kubectx"></a>Step3. kubectx</h3><ul>
<li><code>kubectx</code> 是 open-source 工具，可讓user可以輕鬆切換多個cluster<br>好處就是，省去切換或合併<code>[context](Context 在 Kubernetes 裡面，切換不同的 cluster 是以 context 為單位，一個 context 裡面必需要三個元件，分別是 User、Server、Certification。這三個東西說起來也很直觀，有個使用者 (User) 必須要有憑證 (Certification) 才能連到某個 Cluster (Server)。  底下是一個 Context 所包含的內容：)</code>的功夫，所以我們選用這個好用的切換工具</li>
<li>什麼是<code>context</code>？<br>Kubernetes 裡面，切換不同的 cluster 是以 context 為單位，一個 context 裡面必需要三個元件，分別是 User、Server、Certification。這三個東西說起來也很直觀，有個使用者 (User) 必須要有憑證 (Certification) 才能連到某個 Cluster (Server)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1. Download kubectx</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">curl -sLO https://raw.githubusercontent.com/ahmetb/kubectx/master/kubectx</span></pre></td></tr><tr><td class="code"><pre><span class="line">chmod +x kubectx</span></pre></td></tr><tr><td class="code"><pre><span class="line">mv ./kubectx ./bin</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#2. kubectx read cluster-config</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#setup Var for Cluster</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectx cluster1=gke_<span class="variable">$&#123;PROJECT_ID&#125;</span>_<span class="variable">$&#123;CLUSTER1_ZONE&#125;</span>_<span class="variable">$&#123;CLUSTER1_NAME&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectx cluster2=gke_<span class="variable">$&#123;PROJECT_ID&#125;</span>_<span class="variable">$&#123;CLUSTER2_ZONE&#125;</span>_<span class="variable">$&#123;CLUSTER2_NAME&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#3. List the kubectx available contexts.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectx</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">(now is running on cluster2)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#4. Change cluster to cluster1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectx cluster1</span></pre></td></tr></table></figure>

<p><img src="Untitled4.png" alt="Untitled4.png"></p>
<h1 id="Task-2-Download-lab-files-from-a-GitHub-repo"><a href="#Task-2-Download-lab-files-from-a-GitHub-repo" class="headerlink" title="Task 2. Download lab files from a GitHub repo"></a>Task 2. Download lab files from a GitHub repo</h1><ul>
<li>接下來要安裝Google engineers開發的管理Istio工具<ul>
<li>multi-cluster</li>
<li>shared control-plane</li>
</ul>
</li>
<li>完整的<code>git</code> 請至下方查看<br><a href="https://github.com/GoogleCloudPlatform/istio-samples.git" target="_blank" rel="noopener">https://github.com/GoogleCloudPlatform/istio-samples.git</a></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1. git clone </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/GoogleCloudPlatform/istio-samples.git</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> istio-samples/multicluster-gke/single-control-plane</span></pre></td></tr></table></figure>

<p><img src="Untitled5.png" alt="Untitled5.png"></p>
<h1 id="Task-3-Create-GKE-firewall-rules-to-allow-inter-cluster-connections"><a href="#Task-3-Create-GKE-firewall-rules-to-allow-inter-cluster-connections" class="headerlink" title="Task 3. Create GKE firewall rules to allow inter-cluster connections"></a>Task 3. Create GKE firewall rules to allow inter-cluster connections</h1><ul>
<li>打開<code>firewall</code> 使二邊Cluster內的pod 可以互通</li>
<li>主要目的，是讓二邊的cluster’s <code>CIDR</code> block range 可以打通，最終<code>control plane</code>與<code>remote</code>互通</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./scripts/3-firewall.sh</span></pre></td></tr></table></figure>

<p><img src="Untitled6.png" alt="Untitled6.png"></p>
<ul>
<li>檢查<code>istio-multicluster-test-pods</code>  規則</li>
<li>有加入Igress 並同意10.16.0.0/14, 10.8.0.0/14 二組ip range</li>
</ul>
<p><img src="Untitled7.png" alt="Untitled7.png"></p>
<h1 id="Task-4-Install-the-Istio-control-plane-to-cluster-1"><a href="#Task-4-Install-the-Istio-control-plane-to-cluster-1" class="headerlink" title="Task 4. Install the Istio control plane to cluster 1"></a>Task 4. Install the Istio control plane to cluster 1</h1><ul>
<li>在cluster 1安裝Istio control plane，我們要先取得安裝檔</li>
<li>因為整個Istio control plane也是以pod型式運行，因此安裝檔會為<code>yaml</code>為主</li>
<li>取得yaml後，使用kubectl apply -f istio_master.yaml 進行部署</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1. Download Istio</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ISTIO_VERSION=<span class="variable">$&#123;ISTIO_VERSION:=1.4.2&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">curl -L https://git.io/getLatestIstio | ISTIO_VERSION=<span class="variable">$ISTIO_VERSION</span> sh -</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#2. Use helm to prepare an installation template.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cat istio-<span class="variable">$&#123;ISTIO_VERSION&#125;</span>/install/kubernetes/helm/istio-init/files/crd-* \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &gt; istio_master.yaml</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">helm template istio istio-<span class="variable">$&#123;ISTIO_VERSION&#125;</span>/install/kubernetes/helm/istio \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    --namespace istio-system &gt;&gt; istio_master.yaml</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#3. Switch to cluster1 context.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectx cluster1</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#4. Install Istio using the template, to cluster 1.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectl create ns istio-system</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">#4.1 Enable auto-proxy injection of Istio sidecars.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	kubectl label namespace default istio-injection=enabled</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">#4.2 Finally, install the control plane components.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	kubectl apply -f istio_master.yaml</span></pre></td></tr></table></figure>

<ul>
<li>可以看到很多的istio components 被建立起來<ul>
<li>envoy</li>
<li>attributemainifests</li>
<li>gateways</li>
<li>etc.</li>
</ul>
</li>
</ul>
<p><img src="Untitled8.png" alt="Untitled8.png"></p>
<h1 id="Task-5-Install-the-Istio-remote-on-cluster-2"><a href="#Task-5-Install-the-Istio-remote-on-cluster-2" class="headerlink" title="Task 5. Install the Istio remote on cluster 2"></a>Task 5. Install the Istio remote on cluster 2</h1><ul>
<li><p>Cluster 2不同的地方是要安裝的是<code>Agnet</code></p>
<ul>
<li>安裝皆是透過<code>helm</code></li>
<li>citadel node-agent</li>
<li>Envoy sidecar injector to cluster 2.</li>
</ul>
</li>
<li><p>需要template file: <code>istio_remote.yaml</code> 來跑control &amp; remote需求</p>
<p>  之前在remote components裡包含<code>helm</code>使用的<code>istio_remote.yaml</code></p>
</li>
</ul>
<h3 id="Step1-Isntall-istio-remote-by-helm-in-Cluster1"><a href="#Step1-Isntall-istio-remote-by-helm-in-Cluster1" class="headerlink" title="Step1. Isntall istio-remote by helm in Cluster1"></a>Step1. Isntall istio-remote by helm in Cluster1</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1. kubectx cluster1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectx cluster1</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#2 Extract the IPs for the cluster1 Pilot, Mixer (below called policy)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PILOT_POD_IP=$(kubectl -n istio-system get pod -l istio=pilot -o jsonpath=<span class="string">'&#123;.items[0].status.podIP&#125;'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> POLICY_POD_IP=$(kubectl -n istio-system get pod -l istio=mixer -o jsonpath=<span class="string">'&#123;.items[0].status.podIP&#125;'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> TELEMETRY_POD_IP=$(kubectl -n istio-system get pod -l istio-mixer-type=telemetry -o jsonpath=<span class="string">'&#123;.items[0].status.podIP&#125;'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"Pilot: <span class="variable">$PILOT_POD_IP</span>"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"Istio-Policy (mixer): <span class="variable">$POLICY_POD_IP</span>"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"Istio-Telemetry (mixer): <span class="variable">$TELEMETRY_POD_IP</span>"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">HELM_DIR=<span class="string">"istio-<span class="variable">$&#123;ISTIO_VERSION&#125;</span>/install/kubernetes/helm/istio"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#3 isntall istio-remote by helm </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">helm template istio-remote <span class="variable">$HELM_DIR</span> \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    --namespace istio-system \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    --values <span class="variable">$HELM_DIR</span>/values-istio-remote.yaml \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    --<span class="built_in">set</span> global.remotePilotAddress=<span class="variable">$&#123;PILOT_POD_IP&#125;</span> \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    --<span class="built_in">set</span> global.remotePolicyAddress=<span class="variable">$&#123;POLICY_POD_IP&#125;</span> \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    --<span class="built_in">set</span> global.remoteTelemetryAddress=<span class="variable">$&#123;TELEMETRY_POD_IP&#125;</span> &gt; \</span></pre></td></tr><tr><td class="code"><pre><span class="line">        istio_remote.yaml</span></pre></td></tr></table></figure>

<p><img src="Untitled9.png" alt="Untitled9.png"></p>
<h3 id="Step2-Install-Istio-remote-components-in-Cluster2"><a href="#Step2-Install-Istio-remote-components-in-Cluster2" class="headerlink" title="Step2. Install Istio remote components in Cluster2"></a>Step2. Install Istio remote components in Cluster2</h3><ul>
<li>記得要透過<code>kubectx</code>切換至cluster2</li>
<li>當然啦，也要建立專屬istio-system 使用的<code>namespace</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1. Install Istio remote components using the template, to cluster 2.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectx cluster2</span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectl create ns istio-system</span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectl apply -f istio_remote.yaml</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#2. Enable auto-proxy injection of Istio sidecars.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectl label namespace default istio-injection=enabled</span></pre></td></tr></table></figure>

<p><img src="Untitled10.png" alt="Untitled10.png"></p>
<h1 id="Task-6-Connect-cluster-2-to-cluster-1"><a href="#Task-6-Connect-cluster-2-to-cluster-1" class="headerlink" title="Task 6. Connect cluster 2 to cluster 1"></a>Task 6. Connect cluster 2 to cluster 1</h1><ul>
<li>cluster1 目前還未經設定，允許<code>cluster2</code>進行通訊</li>
<li>所以我們要針對<code>remote Cluster 2</code>，產生一個 Kubeconfig file ，然後把Secret加到Cluster 1</li>
<li>設定變數描述Cluster2的環境，包含以下<ul>
<li>name, kubecfg file, server address, istio namespace, istio service account, service account secret name, the CA cert, and token.</li>
</ul>
</li>
</ul>
<h3 id="Step1-Generate-kubeconfig-for-Cluster2"><a href="#Step1-Generate-kubeconfig-for-Cluster2" class="headerlink" title="Step1. Generate kubeconfig for Cluster2"></a>Step1. Generate kubeconfig for Cluster2</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1. Verify that you're currently using the cluster2 context.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectx cluster2</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#2. Set up multiple environment variables describing cluster2, including the name, etc.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> WORK_DIR=$(<span class="built_in">pwd</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">CLUSTER_NAME=$(kubectl config view --minify=<span class="literal">true</span> -o <span class="string">"jsonpath=&#123;.clusters[].name&#125;"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">CLUSTER_NAME=<span class="string">"<span class="variable">$&#123;CLUSTER_NAME##*_&#125;</span>"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> KUBECFG_FILE=<span class="variable">$&#123;WORK_DIR&#125;</span>/<span class="variable">$&#123;CLUSTER_NAME&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">SERVER=$(kubectl config view --minify=<span class="literal">true</span> -o <span class="string">"jsonpath=&#123;.clusters[].cluster.server&#125;"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">NAMESPACE=istio-system</span></pre></td></tr><tr><td class="code"><pre><span class="line">SERVICE_ACCOUNT=istio-multi</span></pre></td></tr><tr><td class="code"><pre><span class="line">SECRET_NAME=$(kubectl get sa <span class="variable">$&#123;SERVICE_ACCOUNT&#125;</span> -n <span class="variable">$&#123;NAMESPACE&#125;</span> -o jsonpath=<span class="string">'&#123;.secrets[].name&#125;'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">CA_DATA=$(kubectl get secret <span class="variable">$&#123;SECRET_NAME&#125;</span> -n <span class="variable">$&#123;NAMESPACE&#125;</span> -o <span class="string">"jsonpath=&#123;.data['ca\.crt']&#125;"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">TOKEN=$(kubectl get secret <span class="variable">$&#123;SECRET_NAME&#125;</span> -n <span class="variable">$&#123;NAMESPACE&#125;</span> -o <span class="string">"jsonpath=&#123;.data['token']&#125;"</span> | base64 --decode)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#3. Create a new kubeconfig </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#   for cluster 2 named cluster-2 using the environment variables.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; <span class="variable">$&#123;KUBECFG_FILE&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">apiVersion: v1</span></pre></td></tr><tr><td class="code"><pre><span class="line">clusters:</span></pre></td></tr><tr><td class="code"><pre><span class="line">   - cluster:</span></pre></td></tr><tr><td class="code"><pre><span class="line">       certificate-authority-data: <span class="variable">$&#123;CA_DATA&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       server: <span class="variable">$&#123;SERVER&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     name: <span class="variable">$&#123;CLUSTER_NAME&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">contexts:</span></pre></td></tr><tr><td class="code"><pre><span class="line">   - context:</span></pre></td></tr><tr><td class="code"><pre><span class="line">       cluster: <span class="variable">$&#123;CLUSTER_NAME&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       user: <span class="variable">$&#123;CLUSTER_NAME&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     name: <span class="variable">$&#123;CLUSTER_NAME&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">current-context: <span class="variable">$&#123;CLUSTER_NAME&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kind: Config</span></pre></td></tr><tr><td class="code"><pre><span class="line">preferences: &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">users:</span></pre></td></tr><tr><td class="code"><pre><span class="line">   - name: <span class="variable">$&#123;CLUSTER_NAME&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     user:</span></pre></td></tr><tr><td class="code"><pre><span class="line">       token: <span class="variable">$&#123;TOKEN&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">EOF</span></pre></td></tr></table></figure>

<p><img src="Untitled11.png" alt="Untitled11.png"></p>
<h3 id="Step2-Let-cluster1-the-control-plane-know-about-cluster2-the-remote"><a href="#Step2-Let-cluster1-the-control-plane-know-about-cluster2-the-remote" class="headerlink" title="Step2. Let cluster1, the control plane, know about cluster2, the remote."></a>Step2. Let cluster1, the control plane, know about cluster2, the remote.</h3><ul>
<li>上面已經為了雙cluster溝通，打通<code>firewall</code></li>
<li>現在要為彼此溝通的Auth，製作<code>secret</code><ul>
<li><code>secret</code>包含cluster-2 ‘kubeconfig’</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1. Switch to the cluster1 context.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectx cluster1</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#2. Let cluster1, the control plane, know about cluster2, the remote.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectl create secret generic <span class="variable">$&#123;CLUSTER_NAME&#125;</span> --from-file <span class="variable">$&#123;KUBECFG_FILE&#125;</span> -n <span class="variable">$&#123;NAMESPACE&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectl label secret <span class="variable">$&#123;CLUSTER_NAME&#125;</span> istio/multiCluster=<span class="literal">true</span> -n <span class="variable">$&#123;NAMESPACE&#125;</span></span></pre></td></tr></table></figure>

<p><img src="Untitled12.png" alt="Untitled12.png"></p>
<h1 id="Task-7-Deploy-the-Hipster-Shop-multi-service-application"><a href="#Task-7-Deploy-the-Hipster-Shop-multi-service-application" class="headerlink" title="Task 7. Deploy the Hipster Shop multi-service application"></a>Task 7. Deploy the Hipster Shop multi-service application</h1><ul>
<li>上面的步聚，都是準備Cluster，現在以下才是重頭戲</li>
<li>要把<code>Hipster Shop</code> 整個microservices部在二個Cluster裡面</li>
<li>然後運行統一個cluster 1 control plane，如圖所示</li>
</ul>
<p><img src="Untitled13.png" alt="Untitled13.png"></p>
<ul>
<li>看一下部署在cluseter1 的service 1內容</li>
</ul>
<p><img src="Untitled14.png" alt="Untitled14.png"></p>
<ul>
<li>再來為什麼要做remove，是因為我們要完成二個cluster的部署</li>
<li>因此還需要切換至cluster 2, 把原本cluster 1已存在的<code>pod</code>移除<ul>
<li>oadgenerator</li>
<li>cartservice</li>
<li>recommendationservice</li>
<li>redis-cart</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1. Switch to cluster1 context.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectx cluster1</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#2. Deploy all the Hipster Shop services to cluster 1:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/GoogleCloudPlatform/microservices-demo/master/release/kubernetes-manifests.yaml</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#3. Remove the deployments assigned to cluster 2:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">services2=(<span class="string">"loadgenerator"</span> <span class="string">"cartservice"</span> <span class="string">"recommendationservice"</span> <span class="string">"redis-cart"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;services2[@]&#125;</span>"</span>; <span class="keyword">do</span> kubectl delete deployment <span class="variable">$s</span>; <span class="keyword">done</span>;</span></pre></td></tr></table></figure>

<p>切換至GKE workload，可以看到Hipster Shop分部在cluster1, 2</p>
<p><img src="Untitled15.png" alt="Untitled15.png"></p>
<h3 id="Step2-Cluster2-deploy-amp-delete-service"><a href="#Step2-Cluster2-deploy-amp-delete-service" class="headerlink" title="Step2. Cluster2 deploy &amp; delete service"></a>Step2. Cluster2 deploy &amp; delete service</h3><ul>
<li>切換至<code>cluster2</code>，開始部署Hipster Shop pods</li>
<li>同樣的也要把重復的pod，從cluster移除</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#4. Switch to cluster2 context.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectx cluster2</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#5. Deploy all the Hipster Shop services to cluster 2:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/GoogleCloudPlatform/microservices-demo/master/release/kubernetes-manifests.yaml</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#6. Remove the deployments assigned to cluster 1:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">services1=(<span class="string">"emailservice"</span> <span class="string">"paymentservice"</span> <span class="string">"shippingservice"</span> <span class="string">"adservice"</span> <span class="string">"checkoutservice"</span> <span class="string">"currencyservice"</span> <span class="string">"frontend"</span> <span class="string">"productcatalogservice"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;services1[@]&#125;</span>"</span>; <span class="keyword">do</span> kubectl delete deployment <span class="variable">$s</span>; <span class="keyword">done</span>;</span></pre></td></tr></table></figure>

<p>建立</p>
<p><img src="Untitled16.png" alt="Untitled16.png"></p>
<p>移除</p>
<p><img src="Untitled17.png" alt="Untitled17.png"></p>
<h1 id="Task-8-Verify-the-Hipster-Shop-deployment"><a href="#Task-8-Verify-the-Hipster-Shop-deployment" class="headerlink" title="Task 8. Verify the Hipster Shop deployment"></a>Task 8. Verify the Hipster Shop deployment</h1><ul>
<li>確認Hipster Shop部署，各別切換至cluster1, 2</li>
</ul>
<h3 id="Step1-Verify-pod-in-each-cluster"><a href="#Step1-Verify-pod-in-each-cluster" class="headerlink" title="Step1. Verify pod in each cluster"></a>Step1. Verify pod in each cluster</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1. Switch to cluster1 context.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectx cluster1</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#2. Check cluster 1 to ensure all pods are RUNNING and READY.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectl get pods</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#3. Switch to cluster2 context.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectx cluster2</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#4. Check pods on cluster 2 to ensure all pods are RUNNING and READY.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectl get pods</span></pre></td></tr></table></figure>

<p><img src="Untitled18.png" alt="Untitled18.png"></p>
<h3 id="Step2-Check-the-Envoy-proxies-running-on-both-clusters"><a href="#Step2-Check-the-Envoy-proxies-running-on-both-clusters" class="headerlink" title="Step2. Check the Envoy proxies running on both clusters"></a>Step2. Check the Envoy proxies running on both clusters</h3><ul>
<li>重點來了，我們要依據先前架構圖設計，Control plane僅在cluster-1</li>
<li>使用<code>./istio-*/bin/istioctl</code> 進行測試<ul>
<li>因此，可以看得到<code>istioctl proxy-status</code>只有在cluster-1</li>
<li>如果跳進cluster-2看<code>istioctl proxy-status</code>是會顯示錯誤</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1. Switch to cluster1 context.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectx cluster1</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#2. Check the proxies, from cluster 1, where the control plane runs.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">./istio-*/bin/istioctl proxy-status</span></pre></td></tr></table></figure>

<ul>
<li><code>istioctl</code> 僅能在 cluser-1正常運作</li>
<li>cluser-2則否</li>
</ul>
<p><img src="Untitled19.png" alt="Untitled19.png"></p>
<h1 id="Task-9-Use-Hipster-Shop-services-running-across-multiple-clusters"><a href="#Task-9-Use-Hipster-Shop-services-running-across-multiple-clusters" class="headerlink" title="Task 9. Use Hipster Shop services running across multiple clusters"></a>Task 9. Use Hipster Shop services running across multiple clusters</h1><ul>
<li>現在已經完整雙cluster, 且有一個control-plane托管二座cluster istio系統</li>
<li>同時網站運行也是正常的，到此實作也算是完成</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1. Switch to cluster1 context.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectx cluster1</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#2. Get the Istio IngressGateway's EXTERNAL-IP.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectl get svc istio-ingressgateway -n istio-system</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#3. Browse Hipster Shop home page, at http://[EXTERNAL_IP].</span></span></pre></td></tr></table></figure>

<p><img src="Untitled20.png" alt="Untitled20.png"></p>
<h1 id="Task10-Register-Cluster-to-Anthos"><a href="#Task10-Register-Cluster-to-Anthos" class="headerlink" title="Task10: Register Cluster to Anthos"></a>Task10: Register Cluster to Anthos</h1><ul>
<li>最後，可以將二個cluster加入Anthos Service Mesh(ASM)</li>
<li>加入的方法很簡單，僅需點選<code>REGISTER</code></li>
</ul>
<p><img src="Untitled21.png" alt="Untitled21.png"></p>
<p>加入時，設定與過程</p>
<ul>
<li>建立service account</li>
<li>安裝與設定agent</li>
</ul>
<p><img src="Untitled22.png" alt="Untitled22.png"></p>
<p>同樣的步驟也把 cluster-2 加入ASM</p>
<p><img src="Untitled23.png" alt="Untitled23.png"></p>
<p>最後就可以享有ASM管理，lab過長，先以提供示意圖</p>
<p><img src="Untitled24.png" alt="Untitled24.png"></p>
<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>這個實作，完成2 GKE clusters運行在不同的regions，且使用統一個service mesh，透過cluster-1 control-plane托管。這樣的應用，非常適合實際production的環境，因為我們常講Globally deployment，概念包含的docker registry, node, pod separately，相信不久大家也會把istio centralized 加入Globally 運行一個重要的best practice。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a href="https://www.akiicat.com/2019/04/24/Kubernetes/setup-kubernetes-configuration/" target="_blank" rel="noopener">管理多個 Kubernetes Cluster：建立、切換、合併 context</a></li>
<li>Google Anthos Lab</li>
</ol>
]]></content>
      <categories>
        <category>GCP</category>
      </categories>
      <tags>
        <tag>GCP</tag>
        <tag>kubernetes</tag>
        <tag>istio</tag>
        <tag>GKE</tag>
        <tag>service mesh</tag>
        <tag>share istio contol plane</tag>
        <tag>kubectx</tag>
        <tag>Anthos</tag>
      </tags>
  </entry>
  <entry>
    <title>[Python] Flask API 後端實作 | Flask API Backend Handson</title>
    <url>/2020/03/16/Python-Flask-API-%E5%BE%8C%E7%AB%AF%E5%AF%A6%E4%BD%9C-Flask-API-Backend-Handson/</url>
    <content><![CDATA[<h1 id="Python-Flask-API-後端實作-Flask-API-Backend-Handson"><a href="#Python-Flask-API-後端實作-Flask-API-Backend-Handson" class="headerlink" title="[Python] Flask API 後端實作 | Flask API Backend Handson"></a>[Python] Flask API 後端實作 | Flask API Backend Handson</h1><h2 id="▌什麼是REST？"><a href="#▌什麼是REST？" class="headerlink" title="▌什麼是REST？"></a>▌什麼是REST？</h2><p>REST 是一種軟體架構風格，目的是幫助在各種不同軟體、程式在網路的世界中能夠互相傳遞訊息。透過統一的Protocol(HTTP 網頁協定)，程式端都可視為一個資源（resource）提供使用者使用(request)，以資源操作的概念，結合 URI、URL path 與 HTTP Method ，來傳送訊息。目的是使 URL path 更為簡潔、容易被理解，除了介面簡潔之外，RESTFul架構也有快取 cache 機制、提升 API 活用性等優點。</p>
<p><img src="Untitled.png" alt="Untitled.png"></p>
<hr>
<h2 id="1-GET-→-Hello-world"><a href="#1-GET-→-Hello-world" class="headerlink" title="1. GET → Hello world"></a>1. GET → Hello world</h2><h3 id="測試：root-path"><a href="#測試：root-path" class="headerlink" title="測試：root path"></a>測試：root path</h3><p>root path的意思就是根目錄，首先我們拿它來練習API存取的路徑，因此我們直接定義了<code>&quot;/&quot;</code>，讓它去使用Class Helloworld(Resource) ，而它的URL: <code>http://127.0.0.1:5000/</code> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/') # 一個裝飾器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">helloworld</span><span class="params">()</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">"hello world"</span></span></pre></td></tr></table></figure>

<p>建立個class，其中的method get是主要被呼叫的函式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Helloworld</span><span class="params">(Resource)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">'hello world'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">api.add_resource(Helloworld, <span class="string">'/'</span>)</span></pre></td></tr></table></figure>
<h3 id="結果：GET-http-127-0-0-1-5000"><a href="#結果：GET-http-127-0-0-1-5000" class="headerlink" title="結果：GET http://127.0.0.1:5000/"></a>結果：GET <code>http://127.0.0.1:5000/</code></h3><p>回傳hello world </p>
<p><img src="Untitled1.png" alt="Untitled1.png"></p>
<h2 id="2-POST-User"><a href="#2-POST-User" class="headerlink" title="2. POST User"></a>2. POST User</h2><h3 id="測試：POST-test"><a href="#測試：POST-test" class="headerlink" title="測試：POST test"></a>測試：POST test</h3><p>新設定一組路由到/user:  它的URL: <code>[http://127.0.0.1:5000/user](http://127.0.0.1:5000/user，目的是把json)</code></p>
<ul>
<li><p>目的是把json 格內的user, passwd存入user_list</p>
<p>  @app.route(‘/user’, methods=[‘POST’])<br>  def create_user():# 可以拿取後台傳過來的數據</p>
<pre><code>user = request.get_json() # 可以把json data傳換成字典
user_list.append(user) #然後就可以把傳進來的data存進list
return jsonify({ # 回傳也要是json的格式
    &apos;message&apos;: &apos;user created&apos;
})</code></pre></li>
<li><p>POSTMAN by json format</p>
<p>  將<code>json</code>中的user xyz 帳密一起送進API</p>
<p>  <img src="Untitled2.png" alt="Untitled2.png"></p>
</li>
</ul>
<h3 id="驗證：xyz-是否有被加入"><a href="#驗證：xyz-是否有被加入" class="headerlink" title="驗證：xyz 是否有被加入"></a>驗證：xyz 是否有被加入</h3><p>這邊也有準備一隻<code>class UserList</code>以GET方式取得user_list資料</p>
<ul>
<li><p>URL為<code>[http://127.0.0.1:5000/users](http://127.0.0.1:5000/user，目的是把json)</code></p>
<p>  class UserList(Resource):</p>
<pre><code>def get(self):
    return user_list</code></pre><p>  api.add_resource(UserList, ‘/users’)</p>
</li>
</ul>
<p>response內容確實回應了xyz 帳號與密碼</p>
<p><img src="Untitled3.png" alt="Untitled3.png"></p>
<h2 id="3-DELETE-User"><a href="#3-DELETE-User" class="headerlink" title="3. DELETE User"></a>3. DELETE User</h2><h3 id="測試：DELETE-xyz"><a href="#測試：DELETE-xyz" class="headerlink" title="測試：DELETE xyz"></a>測試：DELETE xyz</h3><p>使用即有的路由到<code>[http://127.0.0.1:5000/user](http://127.0.0.1:5000/user，目的是把json)</code> ， 但它的method 為DELETE </p>
<ul>
<li><p>同一組路由的原因是我們要找到user_list中符合的user，才能做刪除的動作</p>
<p>  @app.route(‘/user/<username>‘, methods=[‘DELETE’, ‘PUT’]) # 因為是要刪，因此要帶 &lt;參數&gt;<br>  def delete_user(username):# 注意！這裡就要有參數在裡面了，才知道要刪除誰，而這個&lt;參數&gt;是跟著path指定的&lt;參數&gt;</p>
<pre><code>user_find = None
for user in user_list:
    if user [&apos;username&apos;] == username:
        user_find = user
if not user_find:
    return jsonify(
        {&apos;message&apos;: &apos;user not found&apos;}
    )
if request.method == &apos;DELETE&apos;:
    user_list.remove(user_find)
    return jsonify(
        {&apos;message&apos;: &apos;user deleted&apos;}
)
elif request.method == &apos;PUT&apos;:
    new_passwd = request.get_json()#新的password 的對向就是json內的字典,也就是postman 拿到的raw:json
    user_list.remove(user_find)
    user_list.append(
        {
            &apos;username&apos;: username,
            &apos;password&apos;: new_passwd[&apos;password&apos;]
        }
    )
    return jsonify(
        {&apos;message&apos;: &apos;user password updated&apos;}
    )</code></pre></li>
</ul>
<h3 id="驗證1：使用postman"><a href="#驗證1：使用postman" class="headerlink" title="驗證1：使用postman"></a>驗證1：使用postman</h3><p>接下來驗證的方法，使用postman跟curl二種</p>
<p>這裡先介紹postman，如何刪除 xyz user</p>
<ul>
<li>使用postman，method改為<code>DELETE</code></li>
<li>URL + &lt;參數&gt;:<code>[http://127.0.0.1:5000/user/xyz](http://127.0.0.1:5000/user，目的是把json)</code></li>
</ul>
<p><img src="Untitled4.png" alt="Untitled4.png"></p>
<h3 id="驗證2：使用curl"><a href="#驗證2：使用curl" class="headerlink" title="驗證2：使用curl"></a>驗證2：使用curl</h3><ul>
<li><p>curl</p>
<p>  <a href="https://blog.techbridge.cc/2019/02/01/linux-curl-command-tutorial/" target="_blank" rel="noopener"></a></p>
<ul>
<li><p>curl -X POST -F <a href="https://blog.techbridge.cc/2019/02/01/linux-curl-command-tutorial/" target="_blank" rel="noopener">link</a> → useful</p>
</li>
<li><p>  curl -X POST -H “Content-Type: application/json” <a href="http://127.0.0.1:5000/user" target="_blank" rel="noopener">http://127.0.0.1:5000/user</a> -d ‘{“username”: “xyz-curl”, “password”: “xyz-curl”}’</p>
</li>
</ul>
</li>
<li><p>delete2</p>
<p>  <img src="Untitled5.png" alt="Untitled5.png"></p>
</li>
</ul>
<h2 id="4-GET-OS-library"><a href="#4-GET-OS-library" class="headerlink" title="4. GET + OS library"></a>4. GET + OS library</h2><h3 id="測試：GET-df-h"><a href="#測試：GET-df-h" class="headerlink" title="測試：GET df -h"></a>測試：GET df -h</h3><p>上面的例子都是控制user，這邊新增一筆路由<code>[http://127.0.0.1:5000/os](http://127.0.0.1:5000/user，目的是把json)</code> ， 但它的method 一樣為GET，但行為是擷取系統的空間使用率，也就是執行 <code>df -h</code></p>
<pre><code>import os, datetime, json

@app.route(&apos;/os&apos;, methods=[&apos;GET&apos;]) # 一個裝飾器
def get_df():
    out = os.popen(&apos;df -h&apos;).read()
    return jsonify(out)</code></pre><h3 id="驗證：使用postman"><a href="#驗證：使用postman" class="headerlink" title="驗證：使用postman"></a>驗證：使用postman</h3><p>透過HTTP GET 得到我本機laptop的<code>df -h</code>訊息</p>
<p>雖然說有點亂，不過基本上是一樣的</p>
<p><img src="Untitled6.png" alt="Untitled6.png"></p>
<p>原本laptop上的<code>df -h</code></p>
<p><img src="Untitled7.png" alt="Untitled7.png"></p>
<h2 id="▌參考"><a href="#▌參考" class="headerlink" title="▌參考"></a>▌參考</h2><ol>
<li><a href="https://ihower.tw/blog/archives/1542" target="_blank" rel="noopener">ihower { blogging } | 什麼是REST跟RESTful?</a></li>
<li><a href="https://tw.twincl.com/programming/*641y" target="_blank" rel="noopener">簡明RESTful API設計要點</a></li>
</ol>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>API</tag>
        <tag>python</tag>
        <tag>modules</tag>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>[Kative] 手把手 Google Kubernetes Service(GKE)  | 什麼是Service Mesh, Istio</title>
    <url>/2020/04/12/Kative-%E6%89%8B%E6%8A%8A%E6%89%8B-Google-Kubernetes-Service-GKE-%E4%BB%80%E9%BA%BC%E6%98%AFService-Mesh-Istio/</url>
    <content><![CDATA[<h1 id="Kative-手把手-Google-Kubernetes-Service-GKE-什麼是Service-Mesh-Istio"><a href="#Kative-手把手-Google-Kubernetes-Service-GKE-什麼是Service-Mesh-Istio" class="headerlink" title="[Kative] 手把手 Google Kubernetes Service(GKE)  | 什麼是Service Mesh, Istio"></a>[Kative] 手把手 Google Kubernetes Service(GKE)  | 什麼是Service Mesh, Istio</h1><p>Status: Completed</p>
<h1 id="▌前言"><a href="#▌前言" class="headerlink" title="▌前言"></a>▌前言</h1><p><strong>什麼是service mesh？</strong> </p>
<p>使用Container的網路服務，背後都會有多個程式做支持，且機會出現大量的存取行為</p>
<ul>
<li>多版號的Application：拜DevOps精神所賜更版上版的頻率，越來越順暢，因此要在不同的服務組合做A/B測試</li>
<li>負載平衡構成的連線關系：Cloud Native概念下許多的網路服務都會支持自動擴展的能力</li>
<li>身份驗證：跨服務鏈設置端到端身份驗證</li>
</ul>
<blockquote>
<p>上面幾種行為統稱為service mesh，也就是一個”鏈”<br>那麼…   誰該來管理這些鏈 Service Mesh？</p>
</blockquote>
<hr>
<h1 id="▌安裝-部署"><a href="#▌安裝-部署" class="headerlink" title="▌安裝 / 部署"></a>▌安裝 / 部署</h1><h3 id="Step1-準備-GKE-Cluster"><a href="#Step1-準備-GKE-Cluster" class="headerlink" title="Step1. 準備 GKE Cluster"></a>Step1. 準備 GKE Cluster</h3><ul>
<li>先指定cluster worker node vm的zone位置</li>
<li>透過<code>gcloud container clusters</code>建立4個node GKE</li>
<li>GKE啟用istio非常的容易，加上<code>--addons</code>即可</li>
</ul>
<pre><code># 設定vm的zone位置
gcloud config set compute/zone us-central1-f

# 建立GKE cluster
# 直接enable addons Istio
gcloud container clusters create hello-istio \
    --num-nodes 4 \
        --enable-basic-auth \
    --addons=Istio --istio-config=auth=MTLS_STRICT</code></pre><p>部署一個GKE環境</p>
<p><img src="Untitled.png" alt="Untitled.png"></p>
<h3 id="Step2-安裝-Istio-Istio-Tools"><a href="#Step2-安裝-Istio-Istio-Tools" class="headerlink" title="Step2. 安裝 Istio, Istio Tools"></a>Step2. 安裝 Istio, Istio Tools</h3><ul>
<li><p>首先取得Istio client，這邊有指定版號1.2.2</p>
</li>
<li><p>安Istio’s 核心元件 ，同時也啟用 <code>mutual TLS</code>(mTLS) 驗證給sidecars使用</p>
<p>Istio control plane 核心元件有以下</p>
</li>
<li><p><em>Pilot</em>: Handles configuration and programming of the proxy sidecars.</p>
</li>
<li><p><em>Mixer</em>: Handles policy decisions for your traffic and gathers telemetry.</p>
</li>
<li><p><em>Ingress</em>: Handles incoming requests from outside your cluster.</p>
</li>
<li><p><em>CA</em>: the Certificate Authority.</p>
</li>
</ul>
<pre><code>#1 取得Istio client
curl -L https://git.io/getLatestIstio | ISTIO_VERSION=1.2.2 sh -

#2 Add the istioctl client to your PATH:
export PATH=$PWD/bin:$PATH

#3 安裝Istio components:*Pilot, Mixer, Ingress, CA etc.*
kubectl apply -f install/kubernetes/istio-auth.yaml

#4 確認Istio 版本, 執行istio pod
kubectl get svc -n istio-system

kubectl get pods -n istio-system</code></pre><p>取得application sample code, 並測試 istio</p>
<p><img src="Untitled1.png" alt="Untitled1.png"></p>
<h1 id="▌驗證-測試"><a href="#▌驗證-測試" class="headerlink" title="▌驗證 / 測試"></a>▌驗證 / 測試</h1><h3 id="Step1-部署一個Application"><a href="#Step1-部署一個Application" class="headerlink" title="Step1. 部署一個Application"></a>Step1. 部署一個Application</h3><p>Istio作法是建立proxy sidecar 在每個pod的旁邊，istioctl kube-inject這個動作是透過原有<code>bookinfo.yaml</code>，將原有containers (procdocpage, rankings, detailed etc.)再加上<code>Istio proxy</code>的設定檔</p>
<ul>
<li><code>bookinfo.yaml</code> 除了 service 也有 deployment</li>
<li>這個是手動 inject <code>sidecar</code>，第一行只會顯示在 stdout，而第二行是合成一個指令</li>
<li>因為沒有在 namespace 下 label 設定 auto-inject，所以是手動inject</li>
<li>然後要自己先產生包含 sidecar container 的 <code>YAML</code>，再去跑kube apply</li>
</ul>
<pre><code>#1 先確認bookinfo.yaml在不在
ls samples/bookinfo/kube/bookinfo.yaml

#2 kube-inject 只會顯示在 stdout
istioctl kube-inject -f samples/bookinfo/kube/bookinfo.yaml

#3 合成一個指令，就是將括弧內的輸出當作是檔案，給前面的指令執行
# 指令說明
1. &lt;( ) 是個 linux 指令的用法
是將括弧內的輸出當作是檔案，給前面的指令執行
2. 原本 -f 後面是接檔案路徑

kubectl apply -f &lt;(istioctl kube-inject -f samples/bookinfo/platform/kube/bookinfo.yaml)</code></pre><p>部署istio, 和主要bookinfo application</p>
<p><img src="Untitled2.png" alt="Untitled2.png"></p>
<ul>
<li>檢視已加入istio config<br>發現<code>annotations</code> 足跡，有設定過sidecar.istio.io並給於版號</li>
<li>annotations 類似於labels，但它是沒有識別用途的標籤</li>
</ul>
<pre><code># 找找 Istio sidecar, along with all the configuration
# 在這個輸出檔 istioctl kube-inject -f samples/bookinfo/kube/bookinfo.yaml

metadata:
      annotations:
        sidecar.istio.io/status: &apos;{&quot;version&quot;:&quot;249fe8117967ad89e644f4ee6f775cd76fc32e399ad4faecc9541b9277053d85&quot;,&quot;initContainers&quot;:[&quot;istio-init&quot;],&quot;containers&quot;:[&quot;istio-proxy&quot;],&quot;volumes&quot;:[&quot;istio-envoy&quot;,&quot;istio-certs&quot;],&quot;imagePullSecrets&quot;:null}&apos;</code></pre><ul>
<li><p>完整istioctl kube-inject -f 內容</p>
<p>  <img src="Untitled3.png" alt="Untitled3.png"></p>
</li>
</ul>
<h3 id="Step2-確認Bookinfo-狀態"><a href="#Step2-確認Bookinfo-狀態" class="headerlink" title="Step2. 確認Bookinfo 狀態"></a>Step2. 確認Bookinfo 狀態</h3><p>確認剛剛的kube apply 有把pods, services 都長出來</p>
<pre><code># 確認 bookinfo pods, services
kubectl get services

kubectl get services</code></pre><p>比對一下productpage, ratings, reviews x3都有正常運作</p>
<p><img src="Untitled4.png" alt="Untitled4.png"></p>
<h3 id="Step3-簡介bookinfo-Application"><a href="#Step3-簡介bookinfo-Application" class="headerlink" title="Step3. 簡介bookinfo Application"></a>Step3. 簡介bookinfo Application</h3><p>部署完的<code>bookinfo.yaml，簡介</code>microservices有以下</p>
<blockquote>
<p>microservices 有四個有python, Java, Ruby, node.js：</p>
</blockquote>
<ul>
<li><strong>productpage:</strong> calls the details and reviews microservices to populate the page.</li>
<li><strong>details</strong>: contains book information.</li>
<li><strong>reviews:</strong> contains book reviews. It also calls the ratings microservice.</li>
<li><strong>ratings</strong>: contains book ranking information that accompanies a book review.</li>
</ul>
<blockquote>
<p><strong>reviews</strong> microservice 有三種版本：</p>
</blockquote>
<ul>
<li><p>Reviews <strong>v1</strong> doesn’t call the ratings service.</p>
</li>
<li><p>Reviews <strong>v2</strong> calls the ratings service, and displays each rating as 1 - 5 black stars.</p>
</li>
<li><p>Reviews <strong>v3</strong> calls the ratings service, and displays each rating as 1 - 5 red stars.</p>
</li>
<li><p>部署完的bookinfo</p>
<p>  <img src="Untitled5.png" alt="Untitled5.png"></p>
</li>
<li><p>加上Istio (Sidecar injected)<br>加上proxy sidecar 就像圖示中，在每個pod的旁邊多一顆黑色的框</p>
<p>  <img src="Untitled6.png" alt="Untitled6.png"></p>
</li>
<li><p>先前已手動加入<code>kube-inject -f</code>，代表已Istio已啟用了<br>因此完整的圖示如下</p>
<p>  <img src="Untitled7.png" alt="Untitled7.png"></p>
</li>
</ul>
<h3 id="Step4-透過-Istio-Ingress-Gateway-啟用外部存取"><a href="#Step4-透過-Istio-Ingress-Gateway-啟用外部存取" class="headerlink" title="Step4. 透過 Istio Ingress Gateway 啟用外部存取"></a>Step4. 透過 Istio Ingress Gateway 啟用外部存取</h3><ul>
<li>目前的<code>bookinfo</code>，只有cluster ip 僅限internal 溝通，若要讓外部可以存取時，需打通對外網路</li>
<li>Istio Gateway 目的，是讓你允許外部的browser可以存取bookinfo的內容</li>
<li>使用到的<code>apiVersion:[networking.istio.io/v1alpha3](http://networking.istio.io/v1alpha3)</code>，可以判斷<code>http</code>，裡面的<code>uri</code>內容</li>
<li><code>apiVersion</code>，同時也可以有<code>route</code>功能 ，因此提供<code>destination、port</code>即可達到<code>docker</code>和docker之間的細微流量管制</li>
</ul>
<p>bookinfo-gateway.yaml</p>
<pre><code># 確認 bookinfo-gateway.yaml 內容
ls samples/bookinfo/networking/bookinfo-gateway.yaml

# 啟用istio-gateway，使productpage docker可以允許對外存取
kubectl apply -f samples/bookinfo/networking/bookinfo-gateway.yaml</code></pre><p>bookinfo-gateway.yaml config如下</p>
<pre><code>apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: bookinfo
spec:
  hosts:
  - &quot;*&quot;
  gateways:
  - bookinfo-gateway
  http:
  - match:
    - uri:
        exact: /productpage
    - uri:
        prefix: /static
    - uri:
        exact: /login
    - uri:
        exact: /logout
    - uri:
        prefix: /api/v1/products
    route:
    - destination:
        host: productpage
        port:
          number: 9080</code></pre><h3 id="什麼是Envoy"><a href="#什麼是Envoy" class="headerlink" title="什麼是Envoy"></a>什麼是Envoy</h3><p>上述的istio-gateway使用到的功能，其實是源自<code>Envoy</code></p>
<ul>
<li>什麼是<code>Envoy proxy</code>，是高效的效能代理程式，功能是調解service mesh內所有的inbound、outbound 的流量</li>
<li><code>Istio</code>利用<code>Envoy</code>多項內置功能，包括<ol>
<li>dynamic service discovery / load balancing / TLS termination</li>
<li>HTTP/2 &amp; gRPC proxying / circuit breakers / health checks</li>
<li>staged rollouts with %-based traffic split / fault injection / rich metrics.</li>
</ol>
</li>
</ul>
<h3 id="Step5-連線bookinfo網頁"><a href="#Step5-連線bookinfo網頁" class="headerlink" title="Step5. 連線bookinfo網頁"></a>Step5. 連線bookinfo網頁</h3><ul>
<li>kubectl get svc 取得ingressgateway IP</li>
</ul>
<pre><code># 取得ingressgateway expose serivce IP
kubectl get svc istio-ingressgateway -n istio-system

# 設定一下個外部IP
GATEWAY_URL=35.232.223.176

# curl 測試網頁
curl -I http://${GATEWAY_URL}/productpage</code></pre><p>查看到istio-gateway service、curl 測驗結果</p>
<p><img src="Untitled8.png" alt="Untitled8.png"></p>
<p>browse 測試結果，也ok</p>
<p><img src="Untitled9.png" alt="Untitled9.png"></p>
<h1 id="▌後記"><a href="#▌後記" class="headerlink" title="▌後記"></a>▌後記</h1><h3 id="誰該來管理這些鏈-Service-Mesh？"><a href="#誰該來管理這些鏈-Service-Mesh？" class="headerlink" title="誰該來管理這些鏈 Service Mesh？"></a>誰該來管理這些鏈 Service Mesh？</h3><p><code>Service mesh</code>精神就是提倡，管理不應該留給服務本身，過去你可能會在yaml中使用network policy，使用到<code>policyTypes: Ingress</code> 加<code>labels</code>達成流量控管。但是服務和服務之間沒有一個docker能夠勝任這種自上而下的工作，而且這也不應該是他們的工作。</p>
<p>最好的做法是服務和它們所訪問的網絡之間有一個<strong>獨立的系統</strong>，也就是切割出網路管理責任，把它全都都交給<code>Istio</code>。更重要的是，採用istio之後可以有以下好處</p>
<ul>
<li>使服務本身不必處理網絡流量load balance, routing, re-try等的細節</li>
<li>為管理員提供一個<strong>抽象層：</strong>可以輕鬆地在cluster策略控制，監控和日誌，服務發現</li>
<li>提升docker安全性：通過<code>TLS</code>進行安全的服務間(docker-to-docker)通信等方面制定有關網絡流量的進階policy</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h1><p>[1] <a href="https://www.qwiklabs.com/focuses/8460?parent=catalog" target="_blank" rel="noopener">https://www.qwiklabs.com/focuses/8460?parent=catalog</a><br>[2] <a href="https://istio.io/docs/examples/bookinfo/" target="_blank" rel="noopener">https://istio.io/docs/examples/bookinfo/</a></p>
]]></content>
      <categories>
        <category>kative</category>
      </categories>
      <tags>
        <tag>GCP</tag>
        <tag>kubernetes</tag>
        <tag>istio</tag>
        <tag>GKE</tag>
        <tag>service mesh</tag>
        <tag>Cloud Native</tag>
        <tag>addons</tag>
        <tag>Pilot</tag>
        <tag>Ingress</tag>
        <tag>ingress-gateway</tag>
        <tag>envoy</tag>
      </tags>
  </entry>
  <entry>
    <title>[Linux]遺失pam_tally.so 造成ssh登入失敗</title>
    <url>/2019/09/11/Linux-%E9%81%BA%E5%A4%B1pam-tally-so-%E9%80%A0%E6%88%90ssh%E7%99%BB%E5%85%A5%E5%A4%B1%E6%95%97/</url>
    <content><![CDATA[<h1 id="Linux-遺失pam-tally-so-造成ssh登入失敗"><a href="#Linux-遺失pam-tally-so-造成ssh登入失敗" class="headerlink" title="[Linux]遺失pam_tally.so 造成ssh登入失敗"></a>[Linux]遺失pam_tally.so 造成ssh登入失敗</h1><h2 id="Linux-PAM-Issue-Lock-ssh-Login"><a href="#Linux-PAM-Issue-Lock-ssh-Login" class="headerlink" title="[ Linux ] PAM Issue Lock ssh Login"></a>[ Linux ] PAM Issue Lock ssh Login</h2><h3 id="1-Error-message"><a href="#1-Error-message" class="headerlink" title="1. Error message"></a>1. Error message</h3><p>客戶用即有 disk開一台vm，無法正常ssh<br>使用serial port 連線和logging，觀察到gcp一直嘗試把itsupport寫入group-sudoers，但無法正常ssh  (上圖是開serial port，下圖ssh error)，經檢查網路與防火牆皆正常</p>
<p><img src="Untitled.png" alt="Untitled.png"></p>
<h3 id="PAM-unable-to-open"><a href="#PAM-unable-to-open" class="headerlink" title="PAM unable to open"></a>PAM unable to open</h3><p>訊息指出PAM unable to open <code>/usr/lib64/security/pam_tally.so</code> </p>
<p><img src="Untitled1.png" alt="Untitled1.png"></p>
<h3 id="參考文件"><a href="#參考文件" class="headerlink" title="參考文件"></a>參考文件</h3><ol>
<li><p><strong>RHEL Resolution</strong></p>
<p> Redhat Solution 也對passwd: PAM unable to dlopen(/lib/security/pam_tally.so) 此提供解法<br> 對目標是<code>**passwd**</code></p>
<p> <a href="https://access.redhat.com/solutions/34749" target="_blank" rel="noopener">Login fails for non-root users with error message “passwd: PAM unable to dlopen(/lib/security/pam_tally.so) - Red Hat Customer Portal</a></p>
</li>
<li><p><strong>內地簡書對於pam linux登入失敗的處理</strong></p>
<p> 直接使用<code>pam_tally --user</code>對user解鎖</p>
<p> <a href="https://www.jianshu.com/p/3cee7c58a283" target="_blank" rel="noopener">Linux登陆失败处理功能</a></p>
</li>
</ol>
<h3 id="2-History-Trace"><a href="#2-History-Trace" class="headerlink" title="2. History Trace"></a>2. History Trace</h3><p>出問題的<code>open-vas vm</code> 關機，將<code>disk</code>掛載到其它的vm進行檢測</p>
<p>發現有對pam.d 調整，推斷出是PAM導致ssh錯誤</p>
<p><img src="Untitled2.png" alt="Untitled2.png"></p>
<h3 id="3-補齊PAM-so檔"><a href="#3-補齊PAM-so檔" class="headerlink" title="3. 補齊PAM .so檔"></a>3. 補齊PAM .so檔</h3><h3 id="作法"><a href="#作法" class="headerlink" title="作法"></a>作法</h3><ol>
<li>檢查系統報錯的檔案<code>pam_tally.so</code> ，確實缺少此檔案</li>
<li>我們檢查過disk有中有相同的so檔，名為<code>pam_tally2.so</code> </li>
<li>建立檔案連結，把<code>pam_tally2.so</code> 指給 <code>pam_tally.so</code></li>
<li>完成連結後，umount disk，在新開vm並使用即有disk</li>
<li>開機正常可正常ssh</li>
</ol>
<p>Step1:<br>檢查檔案</p>
<pre><code># 取得disk資訊，sdb是新掛進來的disk
# 而sdb1是有經過format的partition
# 我們要把/dev/sdb1 掛在新的系統上

$lsblk 

$mkdir -p /ossec
$mount /dev/sdb1 /ossec

# 設定新的根目錄
# 用意是把舊的disk當作系統碟的意思，才能對此partition進行檢測
# 切換命令提示會變成root
# 如擷圖 root@test-107

$chroot /ossec

# 根據報錯的訊息檢查pam_tally.so 檔案
# 發現遺失此檔案

$ls /usr/lib64/security/pam_tally.so</code></pre><p><img src="Untitled3.png" alt="Untitled3.png"></p>
<p>$lsblk</p>
<p><img src="Untitled4.png" alt="Untitled4.png"></p>
<p>To check pam_tally.so</p>
<p>Step2:<br>建立檔案連結<code>ln</code></p>
<p><img src="Untitled5.png" alt="Untitled5.png"></p>
<p>Step3:<br>確認剛才建立的連結檔<code>pam_tally.so</code></p>
<p><img src="Untitled6.png" alt="Untitled6.png"></p>
<p>Step4:</p>
<pre><code># 退出chroot，回到原本的系統
# 注意user變成 itsupport@test-107
$exit

# OS 層級的umount
$sudo umount /ossec

# 再進GCP console把physical disk刪除掉
# 或使用detach-disk

gcloud compute instances detach-disk &lt;YOUR_INSTANCE&gt; --disk=&lt;YOUR_DISK&gt; --zone=&lt;YOUR_ZONE&gt;</code></pre><p><img src="Untitled7.png" alt="Untitled7.png"></p>
<p>Step5:</p>
<p>可以正常ssh 連線了</p>
<p><img src="Untitled8.png" alt="Untitled8.png"></p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>PAM是保護ssh的第三把鎖，但也有可能設定不當造成ssh失效</p>
<hr>
<h2 id="Firewall-Bastion-linux-RDP-Issue"><a href="#Firewall-Bastion-linux-RDP-Issue" class="headerlink" title="[ Firewall ] Bastion-linux RDP Issue"></a>[ Firewall ] Bastion-linux RDP Issue</h2><h3 id="Firewall-套用模式有三種"><a href="#Firewall-套用模式有三種" class="headerlink" title="Firewall 套用模式有三種"></a>Firewall 套用模式有三種</h3><ol>
<li>網路中所有instance</li>
<li>指定的目標標記</li>
<li>指定的服務帳戶</li>
</ol>
<h3 id="作法-1"><a href="#作法-1" class="headerlink" title="作法"></a>作法</h3><ol>
<li>檢查這條policy是採用<code>指定的目標標記</code></li>
<li>因此vm也要套用上對應的<code>tag</code>: <code>prod-allow-rdp</code> 此firewall才會生效</li>
</ol>
<p>Step1</p>
<p><img src="Untitled9.png" alt="Untitled9.png"></p>
<p>Step2</p>
<p><img src="Untitled10.png" alt="Untitled10.png"></p>
<h3 id="結論-："><a href="#結論-：" class="headerlink" title="結論 ："></a>結論 ：</h3><p>firewall使用的目標最用方式有三種，在現在production目前都有使用中</p>
<p>要注意instance與firewall彼此的對應關系</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>SSH</tag>
        <tag>pam_tally.so</tag>
      </tags>
  </entry>
  <entry>
    <title>[Linux] 內核虛擬Bridge, veth原理與實作 | Hands on Linux Kernel: bridge, veth</title>
    <url>/2020/04/26/Linux-%E5%85%A7%E6%A0%B8%E8%99%9B%E6%93%ACBridge-veth%E5%8E%9F%E7%90%86%E8%88%87%E5%AF%A6%E4%BD%9C-Hands-on-Linux-Kernel-bridge-veth/</url>
    <content><![CDATA[<h1 id="Linux-內核虛擬Bridge-veth原理與實作-Hands-on-Linux-Kernel-bridge-veth"><a href="#Linux-內核虛擬Bridge-veth原理與實作-Hands-on-Linux-Kernel-bridge-veth" class="headerlink" title="[Linux] 內核虛擬Bridge, veth原理與實作 | Hands on Linux Kernel: bridge, veth"></a>[Linux] 內核虛擬Bridge, veth原理與實作 | Hands on Linux Kernel: bridge, veth</h1><h1 id="▌前言"><a href="#▌前言" class="headerlink" title="▌前言"></a>▌前言</h1><blockquote>
<p>目的：實作linux bridge，實驗不同namespace之互通性</p>
</blockquote>
<ul>
<li><p>什麼是<code>Linux bridge</code></p>
<p>  linux bridge是用於連接兩個不同網段的常見手法，不同網段通過bridge連接後，就如同在一個網段工作一樣。工作原理就是OSI Layer 2 Data link 進行數據包(frame)的轉發，當有數據到達時，Bridge 會根據報文中的 MAC 信息進行廣播、轉發或丟棄。完成bridge之後再透過指派IP給虛擬網卡，使二端可以互相ping通</p>
</li>
<li><p>什麼是<code>namespace</code></p>
<p>  它是Linux內核的一項功能，能夠對內核資源進行分區，以使一組process看到指定一組資源，而另一組process看到另一組資源，所以namespace是linux用來進行資源的虛擬隔離方法</p>
</li>
<li><p>什麼是<code>veth（virtual Ethernet）</code></p>
<p>  是Linux 內核支援的一種虛擬網絡設備，是虛擬的網路裝置，veth 的兩端可以採用不同的網路namespace，所以可以用來做主機和容器之間的網路通信。</p>
</li>
</ul>
<h1 id="▌建立namespace"><a href="#▌建立namespace" class="headerlink" title="▌建立namespace"></a>▌建立namespace</h1><ul>
<li>namespace是linux用來進行資源的虛擬隔離之用，</li>
<li>測試查看現有namespace，並新增一個namespace</li>
<li>採用新的namespace，並查看ip device</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出現有的namespace, netns應為network namespace縮寫</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ip netns list</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 增加一個blue namespace</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ip nets add blue</span></pre></td></tr></table></figure>

<ul>
<li><p>先列出現有的namespace，再來增加一個<code>blue namespace</code></p>
<p>  <img src="Untitled.png" alt="Untitled.png"></p>
</li>
<li><p>搭配<code>ip netns exec</code> 採用新的namespace</p>
<p>  <img src="Untitled1.png" alt="Untitled1.png"></p>
</li>
</ul>
<h1 id="▌建立veth-pair"><a href="#▌建立veth-pair" class="headerlink" title="▌建立veth pair"></a>▌建立veth pair</h1><ul>
<li>由圖1所示，要讓namespace A連到local，我們就要建立一對veth</li>
<li>再來將這一對veth，各別放到新的namespace，另一個則保留不動</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 建立一對veth(virtual-ethernet), 一個名字為a, 另一個為b</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo ip link add blue-veth<span class="_">-a</span> <span class="built_in">type</span> veth peer name blue-veth-b</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 查看local內新的veth 裝置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ip link</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 查看新的veth 裝置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo ip netns <span class="built_in">exec</span> blue ip link</span></pre></td></tr></table></figure>

<ul>
<li><p>剛建立好的<code>veth pair</code>預設會先在local端，還不會到新的namespace</p>
</li>
<li><p>第一次看到的ip link 結果可以看<code>blue-veth-a</code>, <code>blue-veth-b</code>皆存在</p>
</li>
<li><p>第二次的ip link，有指定在<code>blue namespace</code>，blue-veth-b就不會在default ip link出現</p>
<p>  <img src="Untitled2.png" alt="Untitled2.png"></p>
</li>
</ul>
<h3 id="調動blue-veth-b"><a href="#調動blue-veth-b" class="headerlink" title="調動blue-veth-b"></a>調動blue-veth-b</h3><ul>
<li>參考圖示，目的要測試新的namespace連線，因此將veth-b移動到<code>blue namespace</code></li>
<li>透過veth-a, veth-b裝置的MAC 即可以相互通信</li>
</ul>
<p><img src="Untitled3.png" alt="Untitled3.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 因此將veth-b移動到blue namespace</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo ip link <span class="built_in">set</span> blue-veth-b netns blue</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 從blue namespace查看新的veth-b裝置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ip netns <span class="built_in">exec</span> blue ip link</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 把dev lo 這個置裝喚醒</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo ip netns <span class="built_in">exec</span> blue ip link <span class="built_in">set</span> dev lo up</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 同時也把blue-veth-a, blue-veth-b 二個裝置喚醒</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo ip link <span class="built_in">set</span> dev blue-veth<span class="_">-a</span> up</span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo ip netns <span class="built_in">exec</span> blue ip link <span class="built_in">set</span> dev blue-veth-b up</span></pre></td></tr></table></figure>

<ul>
<li><p>可以看到原本的ip link 看不到<code>veth-b</code>了，現在已經轉到blue namespace底下</p>
</li>
<li><p>現在<code>veth-piar</code> 這條<strong>“鏈”</strong>已經建立起來了，代表L2數據鏈路是可以互通</p>
</li>
<li><p>不過呢，我們還是缺少了L3 ip，所以我們會增加ip進去</p>
<p>  <img src="Untitled4.png" alt="Untitled4.png"></p>
</li>
</ul>
<h1 id="▌測試namespace-連線"><a href="#▌測試namespace-連線" class="headerlink" title="▌測試namespace 連線"></a>▌測試namespace 連線</h1><p>依圖示，現在要用紅色的<code>blue-veth-b</code>, 和藍色<code>blue-veth-a</code>分別加上ip</p>
<ul>
<li>綠色方塊就是 = veth</li>
<li>橘色方塊就是local 端</li>
</ul>
<p><img src="Untitled5.png" alt="Untitled5.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1 指定dev blue-veth-a，使用ip addr add ip</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> sudo ip addr add 192.168.1.1/24 dev blue-veth<span class="_">-a</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">ip a</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#2 指定dev blue-veth-b，使用ip addr add ip</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo ip netns <span class="built_in">exec</span> blue ip addr add 192.168.1.2/24 dev blue-veth-b</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo ip netns <span class="built_in">exec</span> blue ip a</span></pre></td></tr></table></figure>

<p><img src="Untitled6.png" alt="Untitled6.png"></p>
<p>依圖示，現在要用紅色的<code>blue-veth-b</code>, 和藍色<code>blue-veth-a</code>分別加上ip</p>
<p><img src="Untitled5.png" alt="Untitled5.png"></p>
<h3 id="veth-a-ping-veth-b"><a href="#veth-a-ping-veth-b" class="headerlink" title="veth-a ping veth-b"></a>veth-a ping veth-b</h3><ul>
<li>實際上的行為，原理是linux bridge交換<code>frames</code>而已，都是等於是ping localhost</li>
<li>ping process發起<code>echo</code>請求，請求到達異地端發起<code>arp</code>請求，詢問目的地址的<code>mac</code>地址</li>
<li>透過<code>arp</code>得到ip與mac的對應方式，並根據<code>mac</code>將<code>frame</code>轉交給veth-b</li>
<li>因為內核交換數據，所以非常快僅 0.03 ms</li>
</ul>
<p><img src="Untitled7.png" alt="Untitled7.png"></p>
<h1 id="▌後記-結論"><a href="#▌後記-結論" class="headerlink" title="▌後記 / 結論"></a>▌後記 / 結論</h1><p>上面的實作是採local至一個指定<code>namespace</code>，另一個實驗是延伸二個<code>namespace</code>，如果有應用服務要跨二個<code>namespace</code>，就是依照veth-pair原理，把各別veth-a, veth-b放進指定的<code>namespace</code>即可</p>
<p><img src="Untitled8.png" alt="Untitled8.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1 增加二個namespace, 分別為ns1, ns2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[vagrant@centos7-docker ~]$ sudo ip netns add ns1</span></pre></td></tr><tr><td class="code"><pre><span class="line">[vagrant@centos7-docker ~]$ sudo ip netns add ns2</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 確認namespace</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[vagrant@centos7-docker ~]$ ip netns list</span></pre></td></tr><tr><td class="code"><pre><span class="line">ns2</span></pre></td></tr><tr><td class="code"><pre><span class="line">ns1</span></pre></td></tr><tr><td class="code"><pre><span class="line">blue (id: 0)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#2 新建一對veth-pair</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo ip link add ns1-veth<span class="_">-a</span> <span class="built_in">type</span> veth peer name ns2-veth-b</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 分派至各別的namespace</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo ip link <span class="built_in">set</span> ns1-veth<span class="_">-a</span> netns ns1</span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo ip link <span class="built_in">set</span> ns2-veth-b netns ns2</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 喚醒veth裝置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo ip netns <span class="built_in">exec</span> ns1 ip link <span class="built_in">set</span> dev ns1-veth<span class="_">-a</span> up</span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo ip netns <span class="built_in">exec</span> ns2 ip link <span class="built_in">set</span> dev ns2-veth-b up</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#3 指定IP</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo ip netns <span class="built_in">exec</span> ns1 ip addr add 10.0.0.1/16 dev ns1-veth<span class="_">-a</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo ip netns <span class="built_in">exec</span> ns2 ip addr add 10.0.0.2/16 dev ns2-veth-b</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># ping測試</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo ip netns <span class="built_in">exec</span> ns1 ping 10.0.0.2</span></pre></td></tr></table></figure>

<ul>
<li><p>測試由ns1 中的veth-a 發起ping ns2 veth-b</p>
<p>  <img src="Untitled9.png" alt="Untitled9.png"></p>
</li>
</ul>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol>
<li>Udemy <a href="https://www.udemy.com/course/docker-china/learn/lecture/6944632#overview" target="_blank" rel="noopener">https://www.udemy.com/course/docker-china/learn/lecture/6944632#overview</a></li>
<li>OVS blog <a href="https://sites.google.com/a/cnsrl.cycu.edu.tw/da-shu-bi-ji/openvswitch" target="_blank" rel="noopener">https://sites.google.com/a/cnsrl.cycu.edu.tw/da-shu-bi-ji/openvswitch</a></li>
<li>TAP, VETH <a href="http://puremonkey2010.blogspot.com/2015/05/linux-linux.html" target="_blank" rel="noopener">http://puremonkey2010.blogspot.com/2015/05/linux-linux.html</a></li>
<li>Linux Bridge <a href="https://www.twblogs.net/a/5b7eba432b717767c6ab6bb1" target="_blank" rel="noopener">https://www.twblogs.net/a/5b7eba432b717767c6ab6bb1</a></li>
<li><a href="https://www.itread01.com/content/1547012345.html" target="_blank" rel="noopener">https://www.itread01.com/content/1547012345.html</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>container</tag>
        <tag>docker</tag>
        <tag>bridge</tag>
        <tag>linux kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>[Python] PyJWT 加解密模組: encode, decode</title>
    <url>/2020/03/01/Python-PyJWT-%E5%8A%A0%E8%A7%A3%E5%AF%86%E6%A8%A1%E7%B5%84-encode-decode/</url>
    <content><![CDATA[<h1 id="Python-PyJWT-加解密模組-encode-decode"><a href="#Python-PyJWT-加解密模組-encode-decode" class="headerlink" title="[Python] PyJWT 加解密模組: encode, decode"></a>[Python] PyJWT 加解密模組: encode, decode</h1><h2 id="▌Python-JWT-Token"><a href="#▌Python-JWT-Token" class="headerlink" title="▌Python JWT Token"></a>▌Python JWT Token</h2><p><a href="https://pyjwt.readthedocs.io/en/latest/" target="_blank" rel="noopener">Welcome to PyJWT - PyJWT 1.7.1 documentation</a></p>
<p>PyJWT工具是用來encode、decode的加解密工具，使用jwt module。</p>
<p>即使Token，被擷取了也不用擔心，因為擷取的人沒有<code>SECRET</code>做decode的動作</p>
<p>使用前先導入jwt module，再傳入json格式，一個<code>key</code>、一個<code>value</code>，還有一個加密的算法<code>SECRET</code>，最後會幫你算出一個Token。</p>
<h3 id="範例1：官方入門"><a href="#範例1：官方入門" class="headerlink" title="範例1：官方入門"></a>範例1：官方入門</h3><ul>
<li>key = k123</li>
<li>value = v123</li>
<li>secret = secret</li>
<li>演算法 = HS256</li>
</ul>
<p>→ 將以上參數包成一個json格式放進encode()，encode()會幫你產出一組token</p>
<pre><code># Sample1
# encoded_jwt

import jwt

encoded_jwt = jwt.encode({&apos;k123&apos;: &apos;v123&apos;}, &apos;secret&apos;, algorithm=&apos;HS256&apos;)
encoded_jwt

jwt.decode(encoded_jwt, &apos;secret&apos;, algorithm=[&apos;HS256&apos;])</code></pre><h3 id="輸出1"><a href="#輸出1" class="headerlink" title="輸出1"></a>輸出1</h3><ol>
<li>encode( )執行產出token</li>
<li>decode( ), 解碼encode的json內容，包括secret，解出key:value值{k123 : v123}</li>
</ol>
<p><img src="Untitled.png" alt="Untitled.png"></p>
<hr>
<h3 id="範例2：帳密加密應用"><a href="#範例2：帳密加密應用" class="headerlink" title="範例2：帳密加密應用"></a>範例2：帳密加密應用</h3><ul>
<li>k = username</li>
<li>v = joe</li>
<li>secret = mykey123</li>
<li>演算法 = HS256</li>
</ul>
<p>→ 將以上參數包成一個json格式放進encode()，encode()產出另一組token</p>
<pre><code># Sample2
# Token with account, passwd

token = jwt.encode({&quot;username&quot;:&quot;joe&quot;}, &quot;mykey123&quot;, algorithm=&apos;HS256&apos;)
token
jwt.decode(token, &quot;mykey123&quot;, algorithms=&apos;HS256&apos;) #mykey123= key,value; k=mykey123</code></pre><h3 id="輸出2"><a href="#輸出2" class="headerlink" title="輸出2"></a>輸出2</h3><ol>
<li>encode( )執行產出token</li>
<li>decode( ), 解碼encode的json內容，包括secret，解出key:value值<code>{&#39;username&#39;: &#39;joe&#39;}</code></li>
</ol>
<p><img src="Untitled1.png" alt="Untitled1.png"></p>
<hr>
<h3 id="範例3：Token-Expiration"><a href="#範例3：Token-Expiration" class="headerlink" title="範例3：Token Expiration"></a>範例3：Token Expiration</h3><p>上面的範例產出的token都是永久有效的，但這邊存在一個風險。只要對方拿到token後，在慢慢try secret，終究是可以得到明碼的帳密。因此需要設計成一個有效期限，若送出request超時再取token的時候系統就會報錯。</p>
<p>因此token的使用，設定在一個有效的時間區間內。如果超過這個時間，token就等於無效的。</p>
<p>如果要在次使用token時，就得再次輸入帳密</p>
<ul>
<li>使用時間模組<code>datetime</code>  <code>timedelta</code></li>
<li>在json格式中，放進特殊的key:value → <code>{exp : date}</code><ul>
<li>超時與時間描述，提供具體的有效期間</li>
<li>“exp”: datetime.utcnow() + timedelta(minutes=1) → <code>utcnow</code> 當前時間 + <code>timedelta</code> 累加時間為1分鐘<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Sample3</span></pre></td></tr><tr><td class="code"><pre><span class="line"># Experiation</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">from datetime import datetime, timedelta</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"># add specific k &amp; value for exp</span></pre></td></tr><tr><td class="code"><pre><span class="line">token_exp &#x3D; jwt.encode(&#123;&quot;username&quot;:&quot;joe&quot;, &quot;exp&quot;: datetime.utcnow() + timedelta(minutes&#x3D;1)&#125;, &quot;mykey123&quot;, algorithm&#x3D;&#39;HS256&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">token_exp</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">jwt.decode(token_exp, &quot;mykey123&quot;, algorithe&#x3D;[&#39;HS256&#39;])</span></pre></td></tr></table></figure>
<h3 id="輸出3"><a href="#輸出3" class="headerlink" title="輸出3"></a>輸出3</h3></li>
</ul>
</li>
</ul>
<ol>
<li><p>decode( ), 第一次解碼encode的json內容，在一分鐘之內可以解出key:value值<code>{&#39;username&#39;: &#39;joe&#39;}</code></p>
<p> <img src="Untitled2.png" alt="Untitled2.png"></p>
</li>
<li><p>decode( ), 第二次解碼，已超過一分鐘的區間，故報錯回應 → <code>ExpiredSignatureError</code></p>
<p> <img src="Untitled3.png" alt="Untitled3.png"></p>
</li>
</ol>
<h2 id="▌結論："><a href="#▌結論：" class="headerlink" title="▌結論："></a>▌結論：</h2><p>應用上會將jwt包成一個API，讓user login時，而他傳入的body即是account/passwd，正確的話即可以產生一組Token，供系統登入</p>
<h2 id="▌參考"><a href="#▌參考" class="headerlink" title="▌參考"></a>▌參考</h2><ol>
<li><a href="https://pyjwt.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://pyjwt.readthedocs.io/en/latest/</a></li>
</ol>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>API</tag>
        <tag>python</tag>
        <tag>modules</tag>
        <tag>pyjwt</tag>
        <tag>jwt</tag>
      </tags>
  </entry>
  <entry>
    <title>[啟發] 2分鐘法則才能持之以恆 | 2 Minute Rule Makes Dreams Happened</title>
    <url>/2020/02/12/%E5%95%9F%E7%99%BC-2%E5%88%86%E9%90%98%E6%B3%95%E5%89%87%E6%89%8D%E8%83%BD%E6%8C%81%E4%B9%8B%E4%BB%A5%E6%81%86-2-Minute-Rule-Makes-Dreams-Happened/</url>
    <content><![CDATA[<h1 id="啟發-2分鐘法則才能持之以恆-2-Minute-Rule-Makes-Dreams-Happened"><a href="#啟發-2分鐘法則才能持之以恆-2-Minute-Rule-Makes-Dreams-Happened" class="headerlink" title="[啟發] 2分鐘法則才能持之以恆 | 2 Minute Rule Makes Dreams Happened"></a>[啟發] 2分鐘法則才能持之以恆 | 2 Minute Rule Makes Dreams Happened</h1><p>Status: Published</p>
<p>&lt;原子習慣&gt;是今年的暢銷書，網路上已有多數的書評和心得分享，皆是環繞在這四大流程(提示、渴望、回應、獎賞)，直到我到書店實際翻一下，看到這個章節，它提出的概念更契合我心，當場就直接將書買回家</p>
<p><img src="Untitled.png" alt="Untitled.png"></p>
<h2 id="目標看得太遠"><a href="#目標看得太遠" class="headerlink" title="目標看得太遠"></a>目標看得太遠</h2><p>即使知道做事要從小處做起，還是很容易一起跑就跨大步、爬山僅需記得眼前的台階，而非山頂。很多人失敗的原因，都是一開始就把目標看得太遠，反而忘記眼前必須完成的事情。</p>
<p>知所以會如此，是因為當你夢想著有所改變，很難避免讓奮興感接掌一切，到頭來就會</p>
<blockquote>
<p>試圖在太短的時間內，做太多的事</p>
</blockquote>
<p><img src="Untitled1.png" alt="Untitled1.png"></p>
<h2 id="新習慣只需二分鐘"><a href="#新習慣只需二分鐘" class="headerlink" title="新習慣只需二分鐘"></a>新習慣只需二分鐘</h2><p>書中則提到可以扺抗這種傾向最有效的方法，就是運用<strong>二分鐘法則</strong>：新習慣的開始應該要花不到兩分鐘。</p>
<p>以下舉的例子，你會發現幾乎每個習慣都可以縮減為兩分鐘的版本(有點萬事開頭起頭難的感覺)：</p>
<ol>
<li>「運動強身」變成「穿上球腳」</li>
<li>「用功讀書」變成「打開筆記本」</li>
<li>「把洗好的衣服摺好」變成「先摺好一件衣服」</li>
<li>「想要早起」變成「先離開床邊站起來」</li>
</ol>
<p>重點是盡可能<strong>讓習慣容易開始</strong>，任誰都可以靜心一分鐘、讀一頁書，或是把一件衣服摺好，如我們先前討論過的，</p>
<blockquote>
<p>這是個強而有力的策略，因為一旦開始做正確的事，要繼續做下去就比較簡單了。</p>
</blockquote>
<p><img src="Untitled2.png" alt="Untitled2.png"></p>
<p>有一個很重要的概念，就是不應該讓新習慣覺得像一種<strong>挑戰</strong>。<strong>接下來</strong>的行動可以有挑戰性，但開頭的兩分鐘應該是輕而易舉，但又總是做不到？原因是什麼？</p>
<p>你要做的是可以引導進入比較有成效的「入門習慣」。作法只要將目標依照困難度，「非常輕易」排到「非常困難」，如此就可以幫你引導到你想要的「入門習慣」</p>
<h2 id="跑馬拉松目標-→-入門習慣"><a href="#跑馬拉松目標-→-入門習慣" class="headerlink" title="跑馬拉松目標 → 入門習慣"></a>跑馬拉松目標 → 入門習慣</h2><p>對於一個初入跑馬拉松，全馬這個目標是42km 很堅「難」，跑半馬也「不簡單」，但我們先換成快走個1萬步，應該就相對「容易」吧，但這個你要做的第一件是穿上跑鞋，這就是所謂的入門習慣，也就是「<strong>兩分鐘法則」</strong>。</p>
<h2 id="如何運用「2分鐘法則」停止拖延"><a href="#如何運用「2分鐘法則」停止拖延" class="headerlink" title="如何運用「2分鐘法則」停止拖延"></a>如何運用「2分鐘法則」停止拖延</h2><p><a href="https://en.wikipedia.org/wiki/Twyla_Tharp" target="_blank" rel="noopener">Tharp, Twyla</a> | 崔拉‧夏普是當代偉大的舞者與編舞家，她把成功歸因在<strong>簡單的日常習慣，</strong>換句話說<strong>規律成就了她的一生。</strong></p>
<p>「我用一個儀式開始每一天」。她解釋到「我早上五點半起床，穿上健身服、暖腿套、運動杉，戴上帽子，然後走出我在曼哈頓的住所，招一輛計程車，請司機載我到健身房，在那裡運動二個小時。」</p>
<blockquote>
<p>我用的儀式並非每天早上在健身房健身，而是計程車。向司機告知目的地，我就完成儀式了</p>
</blockquote>
<p><img src="Untitled3.png" alt="Untitled3.png"></p>
<p>這是簡單的動作，但每天早晨用同樣的方式開啟新的一天，讓它成了習慣，讓它便於重復，<strong>重點就是要讓它很容易做</strong>。這項儀式讓她降低了我跳過或以不同的方式做的可能性，讓我的慣例軍火庫多了一項武器，也讓我少了一件要費心思考的事。」(它的意思是說，有了「搭計程車」起始動作處理掉做選擇時「分神」的問題，避免自已找各種理由不去健身)</p>
<h2 id="目標簡單一點，才是前進動能"><a href="#目標簡單一點，才是前進動能" class="headerlink" title="目標簡單一點，才是前進動能"></a>目標簡單一點，才是前進動能</h2><p>每天早上招計程車也許是個微不足道的舉動，卻是行為改變第三法則的絕佳範例。研究人員估計，我們每天的所作所為中，有40% - 50% 出於習慣。這樣的比例已經很可觀了，但習慣真正的影響卻遠大於這些數字所能表明的。</p>
<blockquote>
<p>習慣是會影響隨後有意識的決定的自動化選擇。沒錯，一個習慣可以在幾秒內完成，卻能形塑幾分鐘、甚至幾小時後的行為。</p>
</blockquote>
<p>習慣就像上高速公路前的匝道，將你引導至一條路線上，還來不及反應，你已經快速往下一個行為駛去。比起開始做一件不一樣的事，繼續做本來正在做的事似<strong>乎比較容易。(</strong>原本起手難，現在變成抽離難，這就是人性阿)</p>
<h2 id="一開始就想要完美"><a href="#一開始就想要完美" class="headerlink" title="一開始就想要完美"></a>一開始就想要完美</h2><p>人們常常一開始就企圖打造完美的習慣，但這個邏輯順序是不對的，應該要先做容易的事，並持續的做。所以要先標準化，才能最佳化。</p>
<p>從簡單的事下手：</p>
<p>這邊作者舉例</p>
<ul>
<li>穿上跑鞋(非常容易) → 走十分鐘(容易)→ (中等)→ 跑5公里(困難)→ 跑全馬(非常困難)</li>
<li>寫一句(非常容易) → 寫一段(容易)→ 寫一千字(中等)→ 寫一篇五千字(困難)→ 寫一本書(非常困難)</li>
<li>翻開筆記本(非常容易) → 用功十分鐘(容易)→ 用功三小時(中等)→ 每科都拿A(困難)→ 拿到博士學位(非常困難)</li>
</ul>
<p><img src="Untitled4.png" alt="Untitled4.png"></p>
<h2 id="刻意練習"><a href="#刻意練習" class="headerlink" title="刻意練習"></a>刻意練習</h2><p>把上面舉的例子有運動，寫作，攻讀學位，我把它</p>
<blockquote>
<p>結合兩分鐘理論與暢銷書&lt;刻意練習&gt;<br>它的公式應該是<strong>刻意完成”小”的目標</strong>。</p>
</blockquote>
<p>這邊在提供一個寫日記的例證。幾乎每個人都曾想培養此習慣，但大部份的人不是寫個幾天便放棄，就是避之唯恐不及，因為把寫日記當作是一個苦差事。其實秘訣就是在覺得費力之前停止，儘能割切好你的小目標，一定要刻寫得比自已想要得”少”，這點太重要了。英國一位知名顧問蓋瑞格‧麥基昂就是靠著”意識寫少”，來養成每天寫日記的習慣，他總是在覺得寫日記很麻煩之前停筆。</p>
<p>海明威對於寫作也有相同的見解，他說：「最棒的方式就是見好就收。」</p>
<h2 id="建立新的身份"><a href="#建立新的身份" class="headerlink" title="建立新的身份"></a>建立新的身份</h2><p>“<em>白話一點 → 期望自己想要變成那樣的人”</em></p>
<p>這類策略之所以奏效，還有另一個原因：它們強化了你想要<strong>建立的身份</strong>。如果你連續五天出現在健身房，即使每次只待兩分鐘，就是<strong>把票投給新的身分</strong>。你在乎的不是練出好身材，而是把焦點放在成為從不錯過健身的那種人。你採取最小的行動，來確保自己慢慢成為想要成為的人。 </p>
<blockquote>
<p>我們很少用這種方式看待改變<br>因為每個人都只在乎最終目標。但是，只做一下伏地挺身<br>好過完全沒運動、練吉他一分鐘好過根本不練、閱讀一分鐘好過從未展卷<br>做得比希望的少，好過什麼都沒做。</p>
</blockquote>
<p><img src="Untitled5.png" alt="Untitled5.png"></p>
<h2 id="二分鐘習慣-→-習慣塑造"><a href="#二分鐘習慣-→-習慣塑造" class="headerlink" title="二分鐘習慣 → 習慣塑造"></a>二分鐘習慣 → 習慣塑造</h2><p>到了某個程度，一旦建立習慣，每天都有起頭，你就能將兩分鐘法則與一個被我們稱為「習慣塑造」的策略結合在一起。每個當下就是把習慣往終極目標的方向升級，記住是眼前的小目標，而不是終點的那個目標。</p>
<h2 id="結論："><a href="#結論：" class="headerlink" title="結論："></a>結論：</h2><p>幾乎所有較大的生活目標都可以改造成兩分鐘的行為：</p>
<ul>
<li>我想要長壽與健康<ul>
<li>我需要擁有好的體態<ul>
<li>我需要運動<ul>
<li>我需要換上運動服 → 兩分鐘</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>我想要擁有幸福的婚姻<ul>
<li>我需要成為好伴侶<ul>
<li>我應該每天做點什麼讓另一半生活得更輕鬆<ul>
<li>我應該規畫下過的每日三餐 → 兩分鐘</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>把所有的<strong>“我想要”</strong>化作成更小的目標！每當你覺得很難堅持某個習慣時，就運用兩分鐘法則吧，這是讓習慣變得輕而易舉的簡單方法。</p>
<p>最後我分享<a href="https://www.youtube.com/watch?v=IhnGS1_VDG4&feature=emb_title" target="_blank" rel="noopener">趙小蘭</a>(美國首位華裔聯邦女部長)說過的話：</p>
<blockquote>
<p>爬山時，要專注眼前的每一個腳步<br>而不是遙想著山頂，那樣子很累。</p>
</blockquote>
<hr>
<p>即使知道做事要從小處做起，還是很容易一起跑就跨大步、爬山僅需記得眼前的台階，而非山頂。很多人失敗的原因，都是一開始就把目標看得太遠，反而忘記眼前必須完成的事情。</p>
<p>知所以會如此，是因為當你夢想著有所改變，很難避免讓奮興感接掌一切，到頭來就會</p>
<blockquote>
<p>試圖在太短的時間內，做太多的事</p>
</blockquote>
<p>書中則提到可以扺抗這種傾向最有效的方法，就是運用二分鐘法則：新習慣的開始應該要花不到兩分鐘。</p>
<p>以下舉的例子，你會發現幾乎每個習慣都可以縮減為兩分鐘的版本(有點萬事開頭起頭難的感覺)：</p>
<ol>
<li>「運動強身」變成「穿上球腳」</li>
<li>「用功讀書」變成「打開筆記本」</li>
<li>「把洗好的衣服摺好」變成「先摺好一件衣服」</li>
<li>「想要早起」變成「先離開床邊站起來」</li>
</ol>
<p>重點是盡可能<strong>讓習慣容易開始</strong>，任誰都可以靜心一分鐘、讀一頁書，或是把一件衣服摺好，而如我們先前討論過的，這是個強而有力的策略，因為一旦開始做正確的事，</p>
<blockquote>
<p>要繼續做下去就比較簡單了。</p>
</blockquote>
<p>有一個很重要的概念，就是不應該讓新習慣覺得像一種挑戰。<strong>接下來</strong>的行動可以有挑戰性，但開頭的兩分鐘應該是輕而易舉，但又總是做不到？原因是什麼？</p>
<p>你要做的是可以引導進入比較有成效的「入門習慣」</p>
<p>作法只要將目標依照困難度，「非常輕易」排到「非常困難」，如此就可以幫你引導到你想要的「入門習慣」</p>
<p><img src="Untitled6.png" alt="Untitled6.png"></p>
<h2 id="跑馬拉松目標-→-入門習慣-1"><a href="#跑馬拉松目標-→-入門習慣-1" class="headerlink" title="跑馬拉松目標 → 入門習慣"></a>跑馬拉松目標 → 入門習慣</h2><p>對於一個初入跑馬拉松，全馬這個目標是42km 很堅「難」，跑半馬也「不簡單」，但我們先換成快走個1萬步，應該就相對「容易」吧，但這個你要做的第一件是穿上跑鞋，這就是所謂的入門習慣，也就是「<strong>兩分鐘法則」</strong>。</p>
<h2 id="如何運用「2分鐘法則」停止托延-beginning"><a href="#如何運用「2分鐘法則」停止托延-beginning" class="headerlink" title="如何運用「2分鐘法則」停止托延(beginning )"></a>如何運用「2分鐘法則」停止托延(beginning )</h2><p>Tharp, Twyla | 崔拉‧夏普是當代偉大的舞者與編舞家，她把成功歸因在<strong>簡單的日常習慣，</strong>換句話說<strong>規律成就了她的一生。</strong></p>
<p>「我用一個儀式開始每一天」。她解釋到「我早上五點半起床，穿上健身服、暖腿套、運動杉，戴上帽子，然後走出我在曼哈頓的住所，招一輛計程車，請司機載我到健身房，在那裡運動二個小時。」</p>
<p>我用的儀式並非每天早上在健身房健身，而是計程車。向司機告知目的地，我就完成儀式了</p>
<p>這是簡單的動作，但每天早晨用同樣的方式開啟新的一天，讓它成了習慣，讓它便於重復，<strong>重點就是要讓它很容易做</strong>。這項儀式讓她降低了我跳過或以不同的方式做的可能性，讓我的慣例軍火庫多了一項武器，也讓我少了一件要費心思考的事。」它的意思是說，有了「搭計程車」起始動作處理掉做選擇時「分神」的問題，避免自已找各種理由不去健身。</p>
<h2 id="目標簡單一點，才是前進動能-1"><a href="#目標簡單一點，才是前進動能-1" class="headerlink" title="目標簡單一點，才是前進動能"></a>目標簡單一點，才是前進動能</h2><p>每天早上招計程車也許是個微不足道的舉動，卻是行為改變第三法則的絕佳範例。</p>
<p>研究人員估計，我們每天的所作所為中，有40% - 50% 出於習慣。這樣的比例已經很可觀了，但習慣真正的影響卻遠大於這些數字所能表明的。</p>
<h2 id="習慣會影響意識"><a href="#習慣會影響意識" class="headerlink" title="習慣會影響意識"></a>習慣會影響意識</h2><p>習慣是會影響隨後有意識的決定的自動化選擇。沒錯，一個習慣可以在幾秒內完成，卻能</p>
<blockquote>
<p>形塑幾分鐘、甚至幾小時後的行為。</p>
</blockquote>
<p>習慣就像上高速公路前的匝道，將你引導至一條路線上，還來不及反應，你已經快速往下一個行為駛去。比起開始做一件不一樣的事，繼續做本來正在做的事似<strong>乎比較容易。</strong></p>
<blockquote>
<p>原本起手難，現在變成抽離難，這就是人阿。</p>
</blockquote>
<h2 id="一下下就好啦，卻停不下來"><a href="#一下下就好啦，卻停不下來" class="headerlink" title="一下下就好啦，卻停不下來"></a>一下下就好啦，卻停不下來</h2><p>明明是一部爛電影，你還是坐著看了兩個小時；明明肚子很飽，你還是一直塞零食；本來是要看手機「一下下」，結果二十分鐘後，你仍死盯著螢幕。不假思索遵循的習慣往往就以這種方式，影響了你在思考時所做的選擇</p>
<p><img src="Untitled7.png" alt="Untitled7.png"></p>
<h2 id="決定性瞬間-選擇的力量"><a href="#決定性瞬間-選擇的力量" class="headerlink" title="決定性瞬間(選擇的力量)"></a>決定性瞬間(選擇的力量)</h2><p>決定自已下廚或是叫外賣的瞬間，決定要開車或是騎自行車的瞬間，決定要寫作還是要滑手機的瞬間。這些都是選擇都道上的岔路。</p>
<p><img src="Untitled8.png" alt="Untitled8.png"></p>
<h2 id="一開始就想要完美-1"><a href="#一開始就想要完美-1" class="headerlink" title="一開始就想要完美"></a>一開始就想要完美</h2><p>人們常常一開始就企圖打造完美的習慣，但這個邏輯順序是不對的，應該要先做容易的事，並持續的做。所以要先標準化，才能最佳化。</p>
<p>從簡單的事下手：</p>
<p>這邊作者舉例</p>
<ul>
<li>穿上跑鞋(非常容易) → 走十分鐘(容易)→ (中等)→ 跑5公里(困難)→ 跑全馬(非常困難)</li>
<li>寫一句(非常容易) → 寫一段(容易)→ 寫一千字(中等)→ 寫一篇五千字(困難)→ 寫一本書(非常困難)</li>
<li>翻開筆記本(非常容易) → 用功十分鐘(容易)→ 用功三小時(中等)→ 每科都拿A(困難)→ 拿到博士學位(非常困難)</li>
</ul>
<p><img src="Untitled9.png" alt="Untitled9.png"></p>
<h2 id="刻意練習-1"><a href="#刻意練習-1" class="headerlink" title="刻意練習"></a>刻意練習</h2><p>把上面舉的例子，我把兩分鐘理論結合暢銷書&lt;刻意練習&gt;，它的公式就是刻意完成小的目標。</p>
<p>這邊在提供一個寫日記的例證。幾乎每個人都曾想培養此習慣，但大部份的人不是寫個幾天便放棄，就是避之唯恐不及，因為把寫日記當作是一個苦差事。其實秘訣就是在覺得費力之前停止，儘能割切好你的小目標，一定要刻寫得比自已想要得”少”，這點太重要了。英國一位知名顧問x瑞格‧麥基昂就是靠著”意識寫少”，來養成每天寫日記的習慣，他總是覺得寫日記很麻煩之前停筆。</p>
<p>海明威對於寫作也有相同的見解，他說：「最棒的方式就是見好就收。」</p>
<h2 id="建立新的身份-1"><a href="#建立新的身份-1" class="headerlink" title="建立新的身份"></a>建立新的身份</h2><p>白話一點 → 期望自己想要變成那樣的人</p>
<p>這類策略之所以奏效，還有另一個原因：它們強化了你想要<strong>建立的身份</strong>。如果你連續五天出現在健身房，即使每次只待兩分鐘，就是<strong>把票投給新的身分</strong>。你在乎的不是練出好身材，而是把焦點放在成為從不錯過健身的那種人。你採取最小的行動，來確保自己慢慢成為想要成為的人。 </p>
<blockquote>
<p>我們很少用這種方式看待改變<br>因為每個人都只在乎最終目標。但是，只做一下 伏地挺身好過完全沒運動,練吉他一分鐘好過根本不練,閱讀一分鐘好過從未展卷。做 得比希望的少,好過什麼都沒做。</p>
</blockquote>
<h2 id="二分鐘習慣-→-習慣塑造-1"><a href="#二分鐘習慣-→-習慣塑造-1" class="headerlink" title="二分鐘習慣 → 習慣塑造"></a>二分鐘習慣 → 習慣塑造</h2><p>到了某個程度，一旦建立習慣，每天都有起頭，你就能將兩分鐘法則與一個被我們稱為「習慣塑造」的策略結合在一起。每個當下就是把習慣往終極目標的方向升級，記住是眼前的小目標，而不是終點的那個目標。</p>
<p><img src="Untitled10.png" alt="Untitled10.png"></p>
<h2 id="結論：-1"><a href="#結論：-1" class="headerlink" title="結論："></a>結論：</h2><p>幾乎所有較大的生活目標都可以改造成兩分鐘的行為: 我想要長壽與健康→我需要擁有好的體態-我需要運動-我需要換上運動服。 我想要擁有幸福的婚姻→我需要成為好伴侶→我應該每天做點什麼讓另一半生活 得更輕鬆!我應該規畫下過的每日三餐。</p>
<p>每當你覺得很難堅持某個習慣時,就運用兩分鐘法則吧。這是讓習慣變得輕而易 舉的簡單方法。</p>
<p>首先,要精通 該行為最小版本的前兩分鐘;接著,前進到一個中等程度的步驟,並重複那個過程| 專注於前兩分鐘,完全掌握該階段之後,再進入下一級。最後,你養成了最初希望養成 的習慣,同時仍把焦點放在它該在的地方:該行為的前兩分鐘。</p>
<p><a href="https://www.linksports.tw/post/185578195025/%E7%94%A8%E7%B0%A1%E5%96%AE%E7%9A%84%E7%BF%92%E6%85%A3%E4%BE%86%E5%BD%B1%E9%9F%BF%E4%BD%A0%E7%9A%84%E6%9C%AA%E4%BE%86" target="_blank" rel="noopener">https://www.linksports.tw/post/185578195025/用簡單的習慣來影響你的未來</a></p>
<p><a href="https://www.youtube.com/watch?v=IhnGS1_VDG4&feature=emb_title" target="_blank" rel="noopener">趙小蘭</a> | 美國首位華裔聯邦女部長趙曾說過：「爬山時，要專注眼前的每一個腳步，而不是遙想著山頂，那樣子很累。」</p>
]]></content>
      <categories>
        <category>啟發</category>
      </categories>
      <tags>
        <tag>原子習慣</tag>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>[ 啟發 ] Don&#39;t Let Best be Enemy of Better |  最好是更好的敵人</title>
    <url>/2020/02/12/%E5%95%9F%E7%99%BC-Don-t-Let-Best-be-Enemy-of-Better-%E6%9C%80%E5%A5%BD%E6%98%AF%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%95%B5%E4%BA%BA/</url>
    <content><![CDATA[<h1 id="啟發-Don’t-Let-Best-be-Enemy-of-Better-最好是更好的敵人"><a href="#啟發-Don’t-Let-Best-be-Enemy-of-Better-最好是更好的敵人" class="headerlink" title="[ 啟發 ] Don’t Let Best be Enemy of Better |  最好是更好的敵人"></a>[ 啟發 ] Don’t Let Best be Enemy of Better |  最好是更好的敵人</h1><p>近來讀了一篇很有心得的文章，特此下筆分享給大家，習得觀念是從訂閱&lt;得到&gt;app 有聲書而來的，它是吳軍老師 | 硅谷來信 | 第215封信</p>
<p>一開始看到這個主題，還不懂它的意思，直到文中提到，工作中很多時候我們無所作為不是因為不想做事，而是一根筋地追求最好(完美)，最後什麼也沒有得到。</p>
<p><img src="Untitled.png" alt="Untitled.png"></p>
<h2 id="更白話的說："><a href="#更白話的說：" class="headerlink" title="更白話的說："></a>更白話的說：</h2><p>人們時常因為一昧追求美完，而忘記自已還是原地踏步，道理很容易懂，不過也常一鼓腦兒想朝向盡善盡美境界，因為價值 = 經驗 x 時間 更是讓人有滿滿的感觸</p>
<p>雖然我們說要實現最後10%，但這並<strong>不意謂我們不可以接受部份的改進</strong>。很多時候，一個完美結果需要很<strong>多次的改進才能實現，而不是一步就位</strong>。</p>
<p>一步到位，追求完美的觀念。或許是來自工業時代的觀念，因為製造出來的產品不能有任何的瑕疪，這會影響整體的量產，最終管理學也造就了<a href="https://zh.wikipedia.org/zh-tw/%E5%85%AD%E6%A8%99%E6%BA%96%E5%B7%AE" target="_blank" rel="noopener">6 Sigma(σ)</a>，來提升品質</p>
<h2 id="保時捷-911的例子"><a href="#保時捷-911的例子" class="headerlink" title="保時捷 911的例子"></a>保時捷 911的例子</h2><p>著名保時捷911的開發者<a href="https://zh.wikipedia.org/wiki/%E6%96%90%E8%BF%AA%E5%8D%97%C2%B7%E4%BF%9D%E6%99%82%E6%8D%B7" target="_blank" rel="noopener">小保時捷</a>，是承習父親的喜愛汽車基因，而他不滿現況<a href="https://zh.wikipedia.org/wiki/%E5%A4%A7%E4%BC%97%E7%94%B2%E5%A3%B3%E8%99%AB" target="_blank" rel="noopener">福斯金龜車</a>(Volkswagen Beetle)馬力不足。也因此下定決心打造一台完美的汽車。他所創立的汽車公司最初所生產的跑車，亦是從福斯金龜車發展而來，但保時捷911更具備他所期望 → 馬力。最後他為了追求完美，成功打造一台保時捷911風靡全球，這個是工業時代的典範。</p>
<p><img src="Untitled1.png" alt="Untitled1.png"></p>
<p>你看現今911跑車是不是還保有金龜車的神韻</p>
<h2 id="軟工思維-v-s-產品疊代"><a href="#軟工思維-v-s-產品疊代" class="headerlink" title="軟工思維 v.s 產品疊代"></a>軟工思維 v.s 產品疊代</h2><p>一位在Google老員工小黃，曾待過全球衛星製造商SUSS MicroTec，IBM以及Yahoo，他身上流著純軟體工程的血液，事事都要做好規劃且開發時，必須嚴格導循軟體規範。這樣的工作思維讓他很不習新東家Yahoo環境，他看到Yahoo工程師時間一到軟體就匆忙上線，身為主管的他，跟他的下屬說明開發是要按照規範做事，但工程師回應說：「我們產品的疊代週期根本趕不上競爭對手阿」</p>
<p><img src="Untitled2.png" alt="Untitled2.png"></p>
<p>軟體工程學中的UML 關系圖</p>
<h2 id="漸進式節奏是合理的"><a href="#漸進式節奏是合理的" class="headerlink" title="漸進式節奏是合理的"></a>漸進式節奏是合理的</h2><p>我們來分析一下，在資訊時代下的產物(軟體)，其實它的召回成本不算太高，因此在工業時代的擔心其實是沒有必要的。後來小黃他到了Google也漸漸這樣的節奏，意思是說</p>
<blockquote>
<p>他已經習慣每一次工作做更好，而不是最到最好。</p>
</blockquote>
<p>在資訊時代，最有效的工作方式就是保證每一次要比先前更好，且能做到持續不斷的進步，而不是為了追求最好把工作的週期無限拖長</p>
<h2 id="iOS更新災情"><a href="#iOS更新災情" class="headerlink" title="iOS更新災情"></a>iOS更新災情</h2><p>最近iphone iOS 13自動更新，引起很多用戶反應發生系統問題，我家人也是深受其害。但讀完上面的例子，你現在可以理解在資訊時代，軟體的開發節奏似乎大於一切，突然懂了什麼…原來這就是資訊時代的節奏阿</p>
<p><img src="Untitled3.png" alt="Untitled3.png"></p>
<p>由蘋果人blog整理災情資訊: <a href="https://applealmond.com/posts/59808" target="_blank" rel="noopener">https://applealmond.com/posts/59808</a></p>
<h2 id="“目標”-與-“行動”-是不一樣的"><a href="#“目標”-與-“行動”-是不一樣的" class="headerlink" title="“目標” 與 “行動” 是不一樣的"></a>“目標” 與 “行動” 是不一樣的</h2><p>同樣的，Google有個基礎服務，這個服務每星期要更新一次，每一次更新雖然會事先規劃好需要更新的全部的功能，但到了升級前，總有別的項目不能如期交付，以至于它的不完美。</p>
<p>那怎麼辨呢？是否再等一兩天？</p>
<blockquote>
<p>Google的做法是不能等，因為永遠沒有完美的時候！</p>
</blockquote>
<p>將一個比原來更好的一點的版本按時提供給user，總比為了追求一個完美的版本，最後什麼都提供不了好得多。</p>
<h2 id="用數學打個比方"><a href="#用數學打個比方" class="headerlink" title="用數學打個比方"></a>用數學打個比方</h2><p>假如一個更好的改進可以讓我們獲得<strong>20%的收益</strong>，<strong>2次</strong>這樣的改進就能獲得40%，而我們自以為的完美最好的改進，不過是30%。</p>
<p>2 + 2 &gt; 3 的道理誰都懂，做事情不怕慢，就怕停<br>因為我們隨著時間的推進，我們發現</p>
<blockquote>
<p>過去所認為的完美，其實並不完美了</p>
</blockquote>
<h2 id="參考："><a href="#參考：" class="headerlink" title="參考："></a>參考：</h2><ul>
<li>經濟日報 <a href="https://money.udn.com/money/story/6709/3784258" target="_blank" rel="noopener">https://money.udn.com/money/story/6709/3784258</a></li>
<li>Who first said it? <a href="https://www.entrepreneur.com/article/249676" target="_blank" rel="noopener">(Don’t Let the Perfect Be the Enemy of the Good)</a></li>
</ul>
]]></content>
      <categories>
        <category>啟發</category>
      </categories>
      <tags>
        <tag>得到App</tag>
        <tag>吳軍</tag>
        <tag>voice book</tag>
      </tags>
  </entry>
  <entry>
    <title>[啟發] 偽工作者 | Pseudo Worker</title>
    <url>/2020/02/12/%E5%95%9F%E7%99%BC-%E5%81%BD%E5%B7%A5%E4%BD%9C%E8%80%85-Pseudo-Worker/</url>
    <content><![CDATA[<h1 id="啟發-偽工作者-Pseudo-Worker"><a href="#啟發-偽工作者-Pseudo-Worker" class="headerlink" title="[啟發] 偽工作者 | Pseudo Worker"></a>[啟發] 偽工作者 | Pseudo Worker</h1><p>Status: Published Medium</p>
<p>想在年前想要有個漂亮的收尾，今天分享工作效率方面的話題，來自得到App | 吳軍 | 矽谷來信 | 第001封信，不作一個偽工作者</p>
<p>很多人會覺得每天的事情太多，總是做不完，是現代人遇到的一個普遍問題，尤其是發展特別快的行業裡 (比如IT領域)的人或者創業者。唯一的解決方法恐怕就是一些事情不要做了，而不是把所有的事情湊合做完了(學習減法的智慧)，我們先來看看一個在Google的工作智慧</p>
<p><img src="Untitled.png" alt="Untitled.png"></p>
<p>img from: <a href="https://www.euronews.com/2019/04/22/two-google-employees-say-company-retaliated-after-they-organized-walkout-n997266" target="_blank" rel="noopener">euronews.com</a></p>
<h2 id="故事一"><a href="#故事一" class="headerlink" title="故事一"></a>故事一</h2><p>Google在2006年成立了中國分公司後，而Google總部一開始對中國研發團隊的評價相當低，遲遲未得到Google總部的認可，這段過程非常漫長。最初，北京3、4工程師抵不上Google Google總部的1個工程師，主要的原因就是工作沒效率。</p>
<blockquote>
<p>吳軍先生分享當時的情況：「我經過訪談，並協助分析原因。發現北京工程師們其實也挺忙的，但是產出卻不高，他們自己也很焦慮。我把一些工程師叫到會議室，讓他們把手中的工作都列了出來，他們每個人列出4~5項要做的工作，有的人可能更多一點。</p>
</blockquote>
<p>然後我問他們，如果完成了其中的一半，你們是否就不再那麼焦慮了。他們大部分人都給我肯定的回答，這也合情合理，工作少了一半，壓力也應該少一半。我告訴他們，當他們完成了兩三項任務後(一半工作)，他們手上 的任務依然是四五項，不會減少，甚至可能更多，因為新的任務又了。<br>因為這個行業行業發展太快，這和傳統軟體公司情況不一樣。」</p>
<h2 id="認真工作的認知"><a href="#認真工作的認知" class="headerlink" title="認真工作的認知"></a>認真工作的認知</h2><ul>
<li><p>傳統的軟體開發中：任務是事先定義清楚的，雖然在開發的過程中有所變動，但是變動不大，你只要在規定的時間前完成自己的模塊就可以了，隨著時間的推移，剩下的工作是越來越少。</p>
</li>
<li><p>網路公司的產品：開發則不同，它的產品是一個動態迭代的過程。無法清晰定義一個靜態的版本，新的問題總是不斷地湧現，每一個問題似乎都有必要立即解決，因此不存在一個把工作隊列清空的可能性。</p>
</li>
</ul>
<blockquote>
<p>在這樣的大背景下，一個人所追求的不應該是完成了%之幾，或者%幾十的工作，<strong><em>而是做完了哪幾件重要的事情</em></strong>。一個聰明的工作者，應該善於找到最重要的工作，並且優先完成它們 → 這是所有新員工都欠缺的技能，也是大家對於%的迷思。</p>
</blockquote>
<p>簡單的說：就是當處於工作永遠做不完的處境時，先把那些最重要的完成了。試試看，這樣你的工作狀態會不會發生改變？</p>
<p>在Google總部，新員工永遠只佔一小部分，因此很容易在有經驗的員工帶動下比較快地掌握工作 技能。而在中國，幾乎所有的工程師都是剛畢業的學生，沒有人告訴他們該怎樣工作，因此雖然大家很忙，但是卻沒有對公司的發展產生什麼重大效果。</p>
<p><img src="Untitled1.png" alt="Untitled1.png"></p>
<h2 id="什麼是偽工作者-Pseudo-Worker"><a href="#什麼是偽工作者-Pseudo-Worker" class="headerlink" title="什麼是偽工作者 | Pseudo Worker"></a>什麼是偽工作者 | Pseudo Worker</h2><p>前一陣Yahoo被<code>Verizon</code>收購了，標誌著一個時代的結束。Yahoo這個曾經被看作是網路的代名詞的公司，走到今天悲慘的地步有很多原因，其中一條就是<strong><em>他們的員工做了太多的偽工 作</em></strong>。只要看看他們產品的變化就能知道這一點，他們產品不斷地改版， 其實這些改版也不增加新功能，也沒有讓人覺得更好用，另外一方面它們也很少開發新的產品。</p>
<p>在Google內，上述這種每天應付事務性工作的人被稱為Pseudo Worker，後來Facebook學習Google的很多管理方法，也使用這種說法，而Pseudo Worker直譯出來就是…</p>
<blockquote>
<p><strong>“偽工作者” ：</strong>這些人每天 把自己搞得很忙，他們所做的工作可能也是公司裡面存在的工作。但是那些工作(也被稱為偽工作)不產生什麼效果。</p>
</blockquote>
<p><img src="Untitled2.png" alt="Untitled2.png"></p>
<p>img from: [Flickriver]( Flickriver pseudo worker - a photo on Flickriver)</p>
<h2 id="如何防止偽工作者呢"><a href="#如何防止偽工作者呢" class="headerlink" title="如何防止偽工作者呢?"></a>如何防止偽工作者呢?</h2><p>怎樣才能防止員工成為偽工作者呢？有二個方針：</p>
<ul>
<li>管理者要讓員工站在「做什麼事情能讓公司最大獲益」的基礎上去工作。如此，<strong>他們在做不完的工作中，才能動腦筋去尋找那些對公司最有幫助的事情去做</strong>，而不是簡單應付老板派下來的工作，然後向老闆交差。在一個知識型企業中，管理者不可能對員工進行事無巨細的管理，因此員工的主動性很重要。</li>
<li><strong>管理者要讓員工明白，<em>他們積極工作 (而不是消極完成任務)，最大的受益方是他們自己</em></strong>。公司裡不免有員工對自己對處境、周圍人的態度、所給予的機會等等，有不滿意的時候，這種時候，他們會消極對待工作，不自覺地成為一個不動腦筋的偽工作者。<br>有些鬼精的人，甚至會表現出一種任勞任怨的態度，也不和老闆爭執，被動地從老闆指派的工作中找一些容易的工作來做，而不是那些有挑戰的任務。當被問起為何不接有困難的任務時，他們總是推脫說時間不夠。</li>
</ul>
<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>在一間公司待一年左右，對於那些鬼精的同事總是會浮現出來，公司面對這樣的人，一般老闆還真拿他們沒有辦法，在考評時只好讓他及格。但是這些人實際上在坑自己，因為那些<strong><em>偽工作</em></strong>做得越多，個人進步就越慢，甚至能力還會倒退。這樣想或許對自已會些安慰，也算是一種警愓，另外一種打算就是快離開那裡。</p>
<p>有些時候需要換一個角度來審視我們所做的事情，就會發現，捨棄一些事情也未嘗不可。<br>再寬泛地講，其實很多人在生活中，也是不斷地把時間浪費在那些其實可做可不做的事情<br>上。最後，我想說的真的有自知的員工(我指的是那些會善用時間讓自已成長的朋友)，</p>
<p>會不停地追求有價值的事情，反而忽略那些鬼精的同仁們</p>
<blockquote>
<p>所以每當你因為總是幹也幹不完的工作而焦慮時<br>不妨試試先停下來，重新梳理一遍手邊的工作</p>
</blockquote>
<p>→ 主動地站在對公司業務幫助最大的角度！<br>→ 主動站在提升自己能力的角度！</p>
]]></content>
      <categories>
        <category>啟發</category>
      </categories>
      <tags>
        <tag>得到App</tag>
        <tag>吳軍</tag>
        <tag>voice book</tag>
      </tags>
  </entry>
  <entry>
    <title>[啟發] 主觀不比客觀差 | Subjective is more Valuable</title>
    <url>/2020/02/12/%E5%95%9F%E7%99%BC-%E4%B8%BB%E8%A7%80%E4%B8%8D%E6%AF%94%E5%AE%A2%E8%A7%80%E5%B7%AE-Subjective-is-more-Valuable/</url>
    <content><![CDATA[<h1 id="啟發-主觀不比客觀差-Subjective-is-more-Valuable"><a href="#啟發-主觀不比客觀差-Subjective-is-more-Valuable" class="headerlink" title="[啟發] 主觀不比客觀差 | Subjective is more Valuable"></a>[啟發] 主觀不比客觀差 | Subjective is more Valuable</h1><p>Status: Published</p>
<p>今天來談一個知名的話題— 主觀與客觀</p>
<p>我們經常覺得主觀不好，客觀好。當然也有很多的人會質疑有聲書觀點是否客觀。追求客觀性這件事本身是好，但是同時我們必須明白很多時候，有自已的觀點也不是件壞事。</p>
<h2 id="客觀就是好，主觀就是不好？"><a href="#客觀就是好，主觀就是不好？" class="headerlink" title="客觀就是好，主觀就是不好？"></a>客觀就是好，主觀就是不好？</h2><p>日常生活中談到主客觀的議題。</p>
<p>如果客觀性的定義本身都帶有一定的主觀性，那麼強調客觀就是好，主觀就是不好，似乎有點站不住腳</p>
<p><img src="Untitled.png" alt="Untitled.png"></p>
<p><a href="https://keydifferences.com/difference-between-objective-and-subjective.html" target="_blank" rel="noopener">https://keydifferences.com/difference-between-objective-and-subjective.html</a></p>
<p>為什麼這麼講呢？我們先來看看主觀和客觀的定義。</p>
<p>二者本身是一個哲學概念：</p>
<h2 id="客觀"><a href="#客觀" class="headerlink" title="客觀"></a><strong>客觀</strong></h2><p>先說<strong>客觀</strong>—它<strong>指觀察一件事，或者判斷一件事情的時候，不受個人思想、感受、利益等與個人有關的因素影響，以便能多保持其真實性。</strong></p>
<h2 id="主觀"><a href="#主觀" class="headerlink" title="主觀"></a>主觀</h2><p>主觀嘛，當然與客觀性相對。它指從主體自身的視角出發去看待事物，這樣的觀點或者傾向就<strong>難免受到個人意識、經驗、慾望和感受的影響</strong>，當然可能影響到對事物判斷的准確性。</p>
<p>以我在台上當講師的經驗來看，我曾經問過同學們，你們喜歡多做一些Lab(實驗)或是聽我講一些實際案例呢？就有同學希望聽到更多的實例，如此可以強化對新產品的認識，也可以縮短上手的時間成本。</p>
<h2 id="從歷史看看主客觀"><a href="#從歷史看看主客觀" class="headerlink" title="從歷史看看主客觀"></a>從歷史看看主客觀</h2><p>歷史學者則因為看到了歷史上太多好的初衷在多年後帶來的壞的結果，對很多科學的發明都非常謹慎和保守。這個問題上，並非科學家有更多的專業和知識，講話就有更大的發言權。相反的歷史學者的忠告常常是要聽的。</p>
<p>學歷史是常握一種<strong>客觀公允</strong>，而且能夠超出時代的看問題方法，用更寬更廣的角度來檢視。</p>
<h2 id="產品的客觀性"><a href="#產品的客觀性" class="headerlink" title="產品的客觀性"></a>產品的客觀性</h2><p>作者吳軍十多年前在Google負責搜尋品質相關的項目，專案的目標是把品質做好。不過什麼是好的品質？內部就有些爭議，但組識有一個共識，就是搜索結果的<strong>排名要客觀</strong>，不能像一些搜索引擎那樣，誰給多少錢，就給誰排在前面</p>
<p>在 Google工作幾年後，開始深入思考。吳軍對主觀性和客觀性的思考就源於那個時期的工作。提出在Google工作時期發生一些故事對主、客觀哲學有更深入的看法。</p>
<p>他和大家一樣從中學開始接觸馬克思<strong><a href="https://zh.wikipedia.org/zh-tw/%E5%94%AF%E7%89%A9%E4%B8%BB%E4%B9%89" target="_blank" rel="noopener">唯物主義</a></strong>的世界觀，是堅定的反對主對支持客觀的人。</p>
<h2 id="Google排名官司"><a href="#Google排名官司" class="headerlink" title="Google排名官司"></a>Google排名官司</h2><p>第一個故事是 Google是世界上永遠的樹大招風，當Google上市後就有一些小公司告Google，說Google的排名不公平，影響他們的流量。Google方面沒有向法官說明自已的排名演算法多麼客觀，反而是引用了美國憲法的第一修正案，即關於言論自由。也就是說Google不需要把排名做到<strong>絕對客觀</strong>公平，它還是可以表達自已的意願，而排名就是它的主觀意願的表達</p>
<p>這件事你聽起來可能學得很悖論(矛盾)，以追求客觀性為目標的Google，打贏司反而要靠調強主觀性</p>
<p><img src="Untitled1.png" alt="Untitled1.png"></p>
<p><a href="http://www.massaffectadvertising.com/seo-and-page-rank-which-is-more-important/" target="_blank" rel="noopener">http://www.massaffectadvertising.com/seo-and-page-rank-which-is-more-important/</a></p>
<h2 id="Google-v-s-Morgan-Stanley"><a href="#Google-v-s-Morgan-Stanley" class="headerlink" title="Google v.s Morgan Stanley"></a>Google v.s Morgan Stanley</h2><p>第二個故事是Google有幾個工程師和摩根士丹利(Morgan Stanley)和高盛集團(Goldman Sachs Group Inc.)打擂台，看誰的管理資本的回報高，最後的結果是Google工程師贏了。畢竟他們的工程素質跟Google比起來差甚多，因此要做到客觀判斷市場，並不容易。</p>
<p>這此事件帶來的收獲是，發現主觀的看法很多時候比客觀更重要。作者那時候開始定閱&lt;華爾街日報&gt;，因為除了那些所謂的客觀新聞之外，還有很強烈主觀的專欄。</p>
<h2 id="專欄價值來自主觀論述"><a href="#專欄價值來自主觀論述" class="headerlink" title="專欄價值來自主觀論述"></a>專欄價值來自主觀論述</h2><p>為什麼主觀的意見比客觀的事實更重要呢？這裡有二個原因，第一：那些所謂客觀的事情其實不過是按照某一個標準把<strong>主觀性濾除的結論</strong>，而那個標準的本身也是一種主觀。其次，</p>
<blockquote>
<p>真正的<strong>真知灼</strong>見都在所謂主觀性的看法中，這一點尤其重要。</p>
</blockquote>
<p>&lt;華爾街日報&gt;中有各種帶有主觀色彩的專欄文章，它們可能帶有偏見</p>
<blockquote>
<p><strong><em>但是它們代表一類人的看法</em></strong>。同時，你也可能讀到截然相反的觀點。</p>
</blockquote>
<p>但你可以把這些觀點綜合起來，自已好好分析，你就不難得到很多深刻的看法，思考那些客觀描述，通常是完全正確，又完全無用 。</p>
<p>其實人的主觀性是區別於動物的一個固有屬性。動物有本能，但是缺乏主觀意識，比如說一群動物的想法，常常是一樣的，但是人類不同，<strong>這原本就是應該是人的價值所在</strong></p>
<p><img src="Untitled2.png" alt="Untitled2.png"></p>
<h2 id="主觀可引導思考"><a href="#主觀可引導思考" class="headerlink" title="主觀可引導思考"></a>主觀可引導思考</h2><p>一昧從客觀，會產生一種後果，就是聽不到任何人的主觀意見，自以為是看到了一個客觀的結果，往後的思考都直接定讞。對於任何排名、評判和意見，我的看法是先看看他們的根據，看看他們思考問題的出發點，再審視他們是否說得有道理，也就是說用更寬廣的時空背景去檢視它</p>
<p>因為對主客觀，作者基本的看法是這樣的：</p>
<ol>
<li><p>世界上沒有什麼絕對的客觀，因此</p>
<blockquote>
<p>人不能偷懶，不過經思考就接受所謂權威客觀的標準</p>
</blockquote>
</li>
<li><p>主觀的意見非常重要，我們即要聽主觀的意見，<br>也要發表自已的主觀看法，而很多所謂的客觀論述不過是重復且不會引起爭議的訊息</p>
</li>
<li><p>多聽不同人的意見(主觀)，而不是僅僅相信權性的意見</p>
</li>
<li><p>做出判斷時要做到公平、公正，做事的時候要遵守規則。這項遠比糾結主觀和客觀重要得多</p>
</li>
</ol>
<h2 id="結論："><a href="#結論：" class="headerlink" title="結論："></a>結論：</h2><p>其實所謂的客觀標準本身又是極其主觀的。現在的我，很喜歡詢問別人的意見，也算是一種<a href="https://www.books.com.tw/products/0010245329" target="_blank" rel="noopener">QBQ</a>的精神，背後就是了解他真正動機是什麼？得到完整的資訊後，才能換位思考，因此就能有更多的寬容、包容，也能和差異相擁，人生更豁達</p>
<p>對於一般人會擁包客觀的原因，我認為是所見有限，主觀是有所其局限性和不隱定性，那麼就會尋找對全面穩定的觀察方式，就得借助所謂的客觀，也填充自已的知識圈。但不能因為就此結束自已的再進步的機會，所以</p>
<blockquote>
<p>客觀不能指導生活，反而恰恰應該是被主觀利用的東西</p>
</blockquote>
<p><img src="Untitled3.png" alt="Untitled3.png"></p>
<pre><code>小秘技：按著拍手可以連拍呦！！</code></pre><hr>
<h2 id="客觀就是好，主觀就是不好？-1"><a href="#客觀就是好，主觀就是不好？-1" class="headerlink" title="客觀就是好，主觀就是不好？"></a>客觀就是好，主觀就是不好？</h2><p>日常生活中談到主客觀的議題。</p>
<p>如果客觀性的定義本身都帶有一定的主觀性，那麼強調客觀就是好，主觀就是不好，似乎有點站不住腳</p>
<h2 id="產品的客觀性-1"><a href="#產品的客觀性-1" class="headerlink" title="產品的客觀性"></a>產品的客觀性</h2><p>作者在十多年前在Google負責搜尋品質相關的項目，專案的目標是把品質做好。不過什麼是好的品質？內部就有些爭議，但組識有一個共識，就是搜索結果的排名要客觀，不能像一些搜索引擎那樣，誰給多少錢，就給誰排在前面</p>
<p><img src="Untitled4.png" alt="Untitled4.png"></p>
<p>今天來談一個知名的話題— 主觀與客觀</p>
<p>我們經常覺得主觀不好，客觀好。當然也有很多的人會質疑有聲書觀點是否客觀。追求客觀性這件事本身是好，但是同時我們必須明白很多時候，有自已的觀點也不是壞事。</p>
<p>為什麼這麼講呢？我們先來看看主觀和客觀的定義。二者本身是一個哲學概念：</p>
<h2 id="客觀-1"><a href="#客觀-1" class="headerlink" title="客觀"></a><strong>客觀</strong></h2><p>先說<strong>客觀</strong>—它<strong>指觀察一件事，或者判斷一件事情的時候，不受個人思想、感受、利益等與個人有關的因素影響，以便能多保持其真實性。</strong></p>
<h2 id="主觀-1"><a href="#主觀-1" class="headerlink" title="主觀"></a>主觀</h2><p>主觀嘛，當然與客觀性相對，它指從主體自身的視角出發去看待事物，這樣的觀點或者傾向就難免受到個人意識、經驗、慾望和感受的影響，當然可能影響到對事物判斷的准確性。</p>
<p>以我在台上當講師的經驗來看，我曾經問過同學們，你們喜歡多做一些Lab(實驗)或是聽我講一些實際經驗呢？</p>
<p><img src="Untitled5.png" alt="Untitled5.png"></p>
<p>在 Google工作幾年後，開始深入思考。吳軍對主觀性和客觀性的思考就源於那個時期的工作。作者在Google工作時期發生一些故事對主、客觀哲學有更深入的看法。</p>
<p>他和大家一樣從中學開始接觸唯物主義的世界觀，是堅定的反對主對支持客觀的人。</p>
<p>第一個故事是 Google是世界上永遠的樹大招風，當Google上市後就有一些小公司告Google，說Google的排名不公平，影響他們的流量。Google方面沒有向法官說明自已的排名演算法多麼客觀，反而是引用了美國憲法的第一修正案，即關於論論自由。也就是說Google不需要把排名做到絕對客觀公平，它還是可以表達自已的意願，而排名就是它的主觀意願的表達</p>
<p><img src="Untitled6.png" alt="Untitled6.png"></p>
<p>這件事你聽起來可能學得很悖論(矛盾)，以追求客觀性為目標的Google，打贏司反而要靠調強主觀性</p>
<p>第二個故事是Google有幾個工程師和摩根士丹利(Morgan Stanley)和高盛集團(Goldman Sachs Group Inc.)打擂台，看誰的管理資本的回報高，最後的結果Google工程師贏了。</p>
<p>這個事件帶來的收獲是，發現主觀的看法很多時候比客觀更重要。吳軍那時候開始定閱&lt;華爾街日報&gt;，因為除了那些所謂的客觀新聞之外，還有很強烈主觀的專欄。</p>
<p>畢竟他們的工程素質跟Google別起來差甚多，因此要做到客觀判斷市場，並不容易</p>
<p><img src="Untitled7.png" alt="Untitled7.png"></p>
<p>為什麼主觀的意見比客觀的事實更重要呢？這裡有二個原因，第一，那些所謂客觀的事情其實不過是按照某一個標準把主觀性濾除的結，而那個標準的本身是主觀的。</p>
<p>其次，真正的真知灼見都在所謂主觀性的看法中，這一點尤其重要。</p>
<p>在&lt;華爾街日報&gt;中有各種帶有主觀色彩的專欄文章，它們可能帶有偏見，<strong><em>但是它們代表一類人的看法</em></strong>。同時，你也可能讀到截然相反的觀點。</p>
<p>但你可以把這些觀點綜合起來，自已好好分析，你就不難得到很多深刻的看法，思考那些客觀描述，通常是完全正確，又完全無用 。</p>
<p><img src="Untitled8.png" alt="Untitled8.png"></p>
<p>其實人的主觀性是區別於動物的一個固有屬性。動物有本能，但是缺乏主觀意識，比如說一群動物的想法，常常是一樣的，但是人類不同，這原本就是應該是人的價值所在</p>
<p><img src="Untitled9.png" alt="Untitled9.png"></p>
<p>一昧從客觀，會產生一種後果。最怕聽不到任何人的主觀意見，自以為是看到了一個客的結果。對於任何排名、評判和意見，我的看法是先看看他們的根據，看看他們思考問題的出發點，再審視他們是否說得有道理</p>
<p>因為對主客觀，我基本的看法是這樣的：</p>
<ol>
<li><p>世界上沒有什麼絕對的客觀，因此</p>
<blockquote>
<p>人不能偷懶，不過經思考就接受所謂權威客觀的標準</p>
</blockquote>
</li>
<li><p>主觀的意見非常重要的，我們即要聽主觀的意見，也要發表自已的主觀看法，而很多所謂的客觀論述不過是重復且不會引起爭議的訊息</p>
</li>
<li><p>多聽不同人的意見(主觀)，而不是僅僅相信權感的意見</p>
</li>
<li><p>作出判斷時要做到公平、公正，做事的時候要遵守規則。這項遠比糾結主觀和客觀重要得多</p>
</li>
</ol>
<p><img src="Untitled10.png" alt="Untitled10.png"></p>
<h2 id="結論：-1"><a href="#結論：-1" class="headerlink" title="結論："></a>結論：</h2><p>其實所謂的客觀標準本身又是極其主觀的。現在的我，很喜歡詢問別人的意見，也算是一種QBQ的精神，背後就是了解他真正動機是什麼？</p>
<p><img src="Untitled11.png" alt="Untitled11.png"></p>
<p><img src="Untitled3.png" alt="Untitled3.png"></p>
<h2 id="從歷史看看主客觀-1"><a href="#從歷史看看主客觀-1" class="headerlink" title="從歷史看看主客觀"></a>從歷史看看主客觀</h2><p>歷史學者則因為看到了歷史上太多好的初衷在多年後帶來的壞的結果，對多很多科學發明都非常謹慎和保守。這個問題上，並非科學家有更多的專業和知識，講話就有更大的發言權。相反的歷史學者的忠告常常是要聽的。</p>
<p>學歷史是常握一種客觀公允，而且能夠超出時代的看問題方法。</p>
<p><img src="Untitled12.png" alt="Untitled12.png"></p>
]]></content>
      <categories>
        <category>啟發</category>
      </categories>
      <tags>
        <tag>得到App</tag>
        <tag>吳軍</tag>
        <tag>voice book</tag>
      </tags>
  </entry>
  <entry>
    <title>[啟發] 寫作的文采 | Improving Qualities of Good Writing</title>
    <url>/2020/02/12/%E5%95%9F%E7%99%BC-%E5%AF%AB%E4%BD%9C%E7%9A%84%E6%96%87%E9%87%87-Improving-Qualities-of-Good-Writing/</url>
    <content><![CDATA[<h1 id="啟發-寫作的文采-Improving-Qualities-of-Good-Writing"><a href="#啟發-寫作的文采-Improving-Qualities-of-Good-Writing" class="headerlink" title="[啟發] 寫作的文采 | Improving Qualities of Good Writing"></a>[啟發] 寫作的文采 | Improving Qualities of Good Writing</h1><p>Status: Published Medium</p>
<h2 id="什麼是文采"><a href="#什麼是文采" class="headerlink" title="什麼是文采"></a>什麼是文采</h2><p>此次心得是來自&lt;寫作，是最好的自我投資&gt;一書中的片段內容，分享於大家。什麼是文采？往往在寫作時，都希望自已的文章可以擁有一定的水準，最好像大師們一樣。而什麼是大師們的文采？更具體一點，可能是滿滿的成語，可能是滿滿的引經據典。</p>
<p><img src="Untitled.png" alt="Untitled.png"></p>
<p>從字典上解釋：文辭方面的才華。更直觀的說法，是指它的語言帶給人<strong>審美上的愉悅感</strong>。</p>
<p>我們可以把這種審美上的愉悅分為<strong>畫面感</strong>和<strong>音律感</strong>，分別對應「看」、「聽」這兩種人類最原始的接收資訊方式</p>
<h2 id="愉悅感怎麼定義"><a href="#愉悅感怎麼定義" class="headerlink" title="愉悅感怎麼定義"></a><strong>愉悅感怎麼定義</strong></h2><blockquote>
<p><strong>愉悅感來自畫面感和音律感</strong></p>
</blockquote>
<p>我們把感官直接獲得的資訊稱為<strong>形象化資訊</strong>，另外對比的則是<strong>抽象化</strong>話。寫作需要的是形象化！把原本讀書腦中還<strong>很抽象的概念將 → 它具體化</strong>，如此自然也會讓人自更容易接受，這也是為什麼電影版&lt;哈利波特&gt;總是比看小說版的&lt;哈利波特&gt;還要多</p>
<h2 id="降低讀者理解成本"><a href="#降低讀者理解成本" class="headerlink" title="降低讀者理解成本"></a>降低讀者理解成本</h2><p>另外一個重點，一個好的作者，就應該以降低讀者的理解成本為目的。盡可能為你的讀者提供容易接受的資訊。</p>
<p>那麼要如何去降低理解成本？請記住三點</p>
<ol>
<li>語言要簡單化、口語化</li>
<li>文字要營造畫面感(塑景，讓腦中有個畫面)</li>
<li>用具體代替抽象(講一個代表物，細細描述它)</li>
</ol>
<p>先談談技巧一：其實寫作是一個把思想編輯成網狀的輸出的一個線性過程，這個過程並不容易。因為讀都的收入一句一句話吸收，因此首先我們要讓句子簡單化，你只要做一件事：修改</p>
<p>你一定聽說過，好文章都是修改出來的。這修改階段，重點是要改掉這幾個語法結構</p>
<ul>
<li>過長的子句(clause)</li>
<li>多層的邏輯，比如雙重否定</li>
<li>連續的形容詞</li>
</ul>
<p>先說明上面三種情況很容易讓讀者，為了尋找句子主軸而被迫放慢閱讀的速度，消秏掉他們的耐心。一個過長的子句，你應該要把它拆開成幾個短句。多層的邏輯則要拆成單一層的邏輯；盡量不用連續的形容詞，如果去掉形容詞會丟失語意，那就打掉原有句子結構，放棄過長的形容詞，重新安排一整句話。</p>
<h2 id="技巧一：語言要簡單化、口語化-→-閱讀節奏感"><a href="#技巧一：語言要簡單化、口語化-→-閱讀節奏感" class="headerlink" title="技巧一：語言要簡單化、口語化 → 閱讀節奏感"></a>技巧一：語言要簡單化、口語化 → 閱讀節奏感</h2><p>短句跟長句相比，還有一個優點，就是有節奏感、音律感。想想我們平時說話，一般一口氣說話不超過十個字。在文章表達中，記住，多用逗號，會讓你的文字節奏更加明快。</p>
<p>研究一下逗號的真正的用意…</p>
<h2 id="技巧二：用文字建立一幅畫"><a href="#技巧二：用文字建立一幅畫" class="headerlink" title="技巧二：用文字建立一幅畫"></a>技巧二：用文字建立一幅畫</h2><p>即然人的大腦天生更<strong>容易識別具象化</strong>(圖)的東西，而不太容易記他那些抽象化的概念。</p>
<p>那麼你就應該給讀者留下深刻印象，就得多善用<strong>文字構圖(這四個字也很抽象XD)</strong>。</p>
<p><img src="Untitled1.png" alt="Untitled1.png"></p>
<p>photo by: website:&lt; People who daydream are more intelligent: study&gt;</p>
<p>但我立馬提具體的做法，有三個思路</p>
<ol>
<li>多用動詞、名詞，少用形容詞</li>
<li>善於抓細節</li>
<li>善於用比喻(即是擬人法)</li>
</ol>
<h2 id="形容詞是疊加理解成本"><a href="#形容詞是疊加理解成本" class="headerlink" title="形容詞是疊加理解成本"></a>形容詞是疊加理解成本</h2><blockquote>
<p>因為動詞和名詞是<strong>描述具體的事物</strong>，而<strong>形容詞是描述抽象的感知</strong></p>
</blockquote>
<p>舉例來說，描述人類復雜的心理情緒，或描述事物的某動作狀態，所以形容詞是會疊高閱讀的<strong>理解成本</strong></p>
<p>書中有提到<strong>注意力寫作</strong>(前面沒有提到)要求我們使用更低的成本的詞彙，即是強調使用動詞和名詞。作者觀察到，只有在初級的寫作朋友會傾向用豪麗和模糊的形容詞。很有經驗的寫作者一定會克制對於形容詞的使用頻率，而更多的使用名詞和動詞</p>
<p>我自已的理解：我想可以從英文文法中的形容司子句，它的存在就是可有可無，也不會影響原本句子的本意，就是這樣意涵吧</p>
<h2 id="塑景-細節描寫"><a href="#塑景-細節描寫" class="headerlink" title="塑景 | 細節描寫"></a>塑景 | 細節描寫</h2><p>好的細節就好像好的材質和素料，賦予文字質感，細節描寫容易<strong>引發聯想(塑景)</strong>，讓產生帶入感，甚至達到身臨其境的效果。</p>
<p><img src="Untitled2.png" alt="Untitled2.png"></p>
<p>塑景的過程好比brianstorming，大伙把心中的idea說出來體體化</p>
<p>書中舉一個美食作家曾祺的例子</p>
<p>高郵鹹蛋的特點是質細而油多。蛋白柔嫩，不似別處的發乾，發粉，入口如嚼石灰。油多尤為別處及所不及…平常食用，一般都是敲敲「空頭」用筷子挖著吃。筷子頭一札下去。吱—— 紅油就冒出來了。</p>
<p><img src="Untitled3.png" alt="Untitled3.png"></p>
<p>photo by: Jennifer’s Kitchen: 自製漏油鹹蛋</p>
<p>你看，這段話的時候，高郵鹹蛋是否彷彿就在你的眼前，食慾都被勾起來了？</p>
<h2 id="天下雜誌也是如此"><a href="#天下雜誌也是如此" class="headerlink" title="天下雜誌也是如此"></a>天下雜誌也是如此</h2><p>另外我自已也訂閱&lt;天下雜誌&gt;，長期閱讀下有觀察到每期的人物採訪亦或是故事報導，文章的開頭都有一段的場景描述，如擷圖：位於三峽區，小小兩公頃的廠區，堆滿了改裝的機器與上千個油槽…</p>
<p><img src="Untitled4.png" alt="Untitled4.png"></p>
<p>photo by: &lt;天下雜誌 2019 10月刊&gt;</p>
<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>讀完這篇文章，你可以知道用<strong>畫面感和音律感</strong>來提升你的文章水準，而好的文章品是易讀和易理理，使用的手段可以用控制文章結構提高閱讀節奏感，另外由不同的面向細細描述一種事物，也容易讓讀者腦中塑景，使其更深入期境。</p>
<h2 id="TOPIC-1-有具像化，也有抽象化，我們談表達…"><a href="#TOPIC-1-有具像化，也有抽象化，我們談表達…" class="headerlink" title="TOPIC 1:有具像化，也有抽象化，我們談表達…"></a>TOPIC 1:有具像化，也有抽象化，我們談表達…</h2><p>refer 羅胖文章</p>
<h2 id="TOPIC-2-中文和英文的逗號"><a href="#TOPIC-2-中文和英文的逗號" class="headerlink" title="TOPIC 2: 中文和英文的逗號"></a>TOPIC 2: 中文和英文的逗號</h2><hr>
<p><img src="Untitled5.png" alt="Untitled5.png"></p>
<p><img src="Untitled6.png" alt="Untitled6.png"></p>
]]></content>
      <categories>
        <category>啟發</category>
      </categories>
      <tags>
        <tag>book</tag>
        <tag>寫作</tag>
      </tags>
  </entry>
  <entry>
    <title>[啟發] 如何斷除壞習慣 | To Break Bad Habits</title>
    <url>/2020/02/12/%E5%95%9F%E7%99%BC-%E5%A6%82%E4%BD%95%E6%96%B7%E9%99%A4%E5%A3%9E%E7%BF%92%E6%85%A3-To-Break-Bad-Habits/</url>
    <content><![CDATA[<h1 id="啟發-如何斷除壞習慣-To-Break-Bad-Habits"><a href="#啟發-如何斷除壞習慣-To-Break-Bad-Habits" class="headerlink" title="[啟發] 如何斷除壞習慣 | To Break Bad Habits"></a>[啟發] 如何斷除壞習慣 | To Break Bad Habits</h1><p>Blog URL: <a href="https://drive.mindmup.com/map/1IkHfIjj0-XzhLBl_TNJLgjMhtEwER7jY" target="_blank" rel="noopener">https://drive.mindmup.com/map/1IkHfIjj0-XzhLBl_TNJLgjMhtEwER7jY</a><br>Status: Published<br>text convert: <a href="https://drive.google.com/drive/folders/1qIKKayDH0S7G5dyX3-3ImW3WiqgrSKwH" target="_blank" rel="noopener">https://drive.google.com/drive/folders/1qIKKayDH0S7G5dyX3-3ImW3WiqgrSKwH</a></p>
<p>生活中有許多的壞習慣，比說無限上綱的滑手機，看東森新聞XDD。但要如何讓壞習慣不可能發生？我從 &lt;原子習慣&gt; 得到的啟發，我們先看一個故事，1830年《鐘樓怪人》的作者<a href="https://zh.wikipedia.org/wiki/%E7%BB%B4%E5%85%8B%E5%A4%9A%C2%B7%E9%9B%A8%E6%9E%9C" target="_blank" rel="noopener">雨果</a>，他面臨一個不可能的截稿期限，他要在一年內完成作品。</p>
<p>為了對抗拖延的惡習，阻止娛樂活動，雨果想出一個怪招，他請助理把他所有的衣服都鎖進一個大櫃子裡，除了一條大披巾，他沒有東西可穿。既然沒有能穿出門的衣服，1830年未他就整整待在書房瘋狂寫作，結果大作《鐘樓怪人》就在1831年1月出版</p>
<blockquote>
<p>有時候，成功的關鍵除了讓好習慣變得容易執行之外<br>更重要的是把壞習慣變困難。</p>
</blockquote>
<p><img src="Untitled.png" alt="Untitled.png"></p>
<p>這是行為改變第三法則的反轉：「<strong>試行動困難無比」</strong>。如果發現自己一直難以貫徹計畫，我們可以效法雨果，藉由創造心理學家所謂的「承諾機制」，增加壞習慣的難度。</p>
<hr>
<h2 id="承諾機制"><a href="#承諾機制" class="headerlink" title="承諾機制"></a><strong>承諾機制</strong></h2><p>當雨果把衣服都鎖起來，好讓自己專心寫作<br>就是創造了一個承諾機制，那什麼是？我們先談談定義</p>
<blockquote>
<p><strong><em>承諾機制是用當下做的選擇來控制未來的行為</em></strong>。這是鎖定未來行為，把你跟好習慣綁在一起，並讓你遠離惡習的一個方法。</p>
</blockquote>
<p>生活中有很多方法可以創造<em>承諾機制</em>。你可以買獨立包裝而非家庭號的食物，來減低過度飲食的機率，出門時會刻意不帶錢包，以免被誘惑去買速食。</p>
<blockquote>
<p>而承諾機制之所以有用<br>是因為它可以在你淪為誘惑的受者之前，好好利用良好的意圖</p>
</blockquote>
<h2 id="善用科技"><a href="#善用科技" class="headerlink" title="善用科技"></a><strong>善用科技</strong></h2><p>讓好習慣自動化，並消除壞習慣，方法很多，通常都跟善用科技有關。因此承諾機制常搭配科技的輔助，比方說科技能讓原本困難、惱人與複雜的行動，變得輕鬆、無痛且簡單。</p>
<ul>
<li>醫療：連續處方箋的藥可以自動續領</li>
<li>理財：透過自動提撥特定比例的薪資，來為退休生活存錢</li>
<li>用餐：送餐服務也可以幫你採購食材</li>
<li>生產力：可以用網站封鎖工具阻斷社群媒體的瀏覽</li>
</ul>
<h2 id="iPhone-Screen-Time-限制App使用"><a href="#iPhone-Screen-Time-限制App使用" class="headerlink" title="iPhone Screen Time 限制App使用"></a>iPhone Screen Time 限制App使用</h2><p><strong>消除壞習慣，</strong>我自已也有一套方法，<strong>克制自已使用手機</strong>，比方說iPhone內建的 Screen Time功能，透過它我限制使用Line、Instagram、Facebook的使用間間，我設定為一天僅可以用45分鐘。對於筆電上的Line我則啟用自動鎖定模式，若三分鐘未使用就需要重新輸入一次密碼。</p>
<p>我還聽到更狠的是，透過插座定時器，裝在網路路由上，時間到就斷電，即是斷網路的概念，如果家有中有重點網路成隱的朋友，我是可以協助安裝XD</p>
<p><img src="Untitled1.png" alt="Untitled1.png"></p>
<h2 id="自動化的缺點"><a href="#自動化的缺點" class="headerlink" title="自動化的缺點"></a>自動化的缺點</h2><p>當然，科技的力量也可能對我們不利。瘋狂追劇之所以變成習慣，是因為比起繼續盯著螢幕，你要投注更多心力才能停止看劇要看下一集，你連按個鈕都不用！Netfix 或YouTube 會自動為你播放，你只要保持眼睛張開就可以了(你看看多自動化阿)。</p>
<p>科技帶來某種程度的方便，讓你可以滿足最微小的突發奇想與欲望。稍微覺得有點餓，就能把食物仙到家門口，或是稍微覺得有點無聊，就能迷航於廣闊的社群媒體之海。 當滿足欲望所需的努力基本上趨近於零，你會發現自己不知不覺陷入當下浮現的任何衝動。</p>
<blockquote>
<p>自動化的缺點，就是可能會讓我們從一項簡單任務到另一項簡單任務</p>
</blockquote>
<p><img src="Untitled2.png" alt="Untitled2.png"></p>
<p>但我發現自己只要一有空閒，就會被社群媒體吸引，只要出現</p>
<blockquote>
<p><strong><em>毫秒的無聊</em></strong>就能讓我拿起手機。我們很容易把這些小小的分心美化成「休息一下」，但長久累積下來，會變成嚴重的問題。「只要再一分鐘」的心態一直摸著我，阻礙我去做任何重要的事。</p>
</blockquote>
<h2 id="大絕招，改密碼"><a href="#大絕招，改密碼" class="headerlink" title="大絕招，改密碼"></a>大絕招，改密碼</h2><p>再來是作者的親身經歷，寫這本書的那一年，試驗了一個時間管理策略：請他的助理每週一會改掉我所有社群媒體帳號的密碼，讓作者無法登入，於是呢整個期間，就能不受干擾地工作。</p>
<p>助理會在週五把新的密碼寄給作者，使其在週末盡情享用社群媒體，可到了週一，她會再次更改密碼。這個方法你也可以找個朋友或家人合作，每週為彼此重設密碼。</p>
<p>六年前，還是替代役的我，也迷上最火紅的英雄聯盟 | LOL，當然也是請女友(現任的老婆)幫我修改密碼，從此之就沒有登入過遊戲了，要斷絕壞習慣就要給一次痛快！</p>
<p><img src="Untitled3.png" alt="Untitled3.png"></p>
<hr>
<h2 id="結論："><a href="#結論：" class="headerlink" title="結論："></a>結論：</h2><p>很多書本教你如何建立起好習慣，但好的書同時也不忘教你如何遠離壞習慣，因為我們不可永遠保持著正念，總要用些方法幫自已自然地遠離惡習。</p>
<p>科技為你所用時，自動化能讓好習慣變得無可避免，但科技也可能滋長壞習慣。了解壞習慣產生之前，早一步意識到它，這是鎖定未來行為，而不是依賴當下意志力的終極之道。</p>
<p>透過運用<strong>承諾機制</strong>、<strong>策略性的一次性選擇</strong>，你可以打造一個<strong>充滿必然性</strong>的環境，在這個空間裡，好習慣不再只是你希望的結果，而是幾乎保證會發生的結果。</p>
]]></content>
      <categories>
        <category>啟發</category>
      </categories>
      <tags>
        <tag>得到App</tag>
        <tag>吳軍</tag>
        <tag>voice book</tag>
      </tags>
  </entry>
  <entry>
    <title>[啟發] 為什麼投資會賺錢</title>
    <url>/2020/02/12/%E5%95%9F%E7%99%BC-%E7%82%BA%E4%BB%80%E9%BA%BC%E6%8A%95%E8%B3%87%E6%9C%83%E8%B3%BA%E9%8C%A2/</url>
    <content><![CDATA[<h1 id="啟發-為什麼投資會賺錢"><a href="#啟發-為什麼投資會賺錢" class="headerlink" title="[啟發] 為什麼投資會賺錢"></a>[啟發] 為什麼投資會賺錢</h1><p>Status: Published Medium</p>
<p>今天的分享來自得到App | 吳軍谷歌方法論 | 146封信，說明了亞洲人炒房的始未，更用經濟學解釋了股市，會何長期來看要做多，而不能做空！</p>
<p><img src="Untitled.png" alt="Untitled.png"></p>
<h2 id="從盲從的人，變成了自由的人。"><a href="#從盲從的人，變成了自由的人。" class="headerlink" title="從盲從的人，變成了自由的人。"></a>從盲從的人，變成了自由的人。</h2><p>今天和明天，我們就來聊聊在投資中某些方面是站不住腳的，幾乎幾乎是永恆的真理，對於那些永恆的真理，其背後的原因是什麼？知道了裡面的原因，我們就從 被動狀態變成了主動狀態，從盲從的人，變成了自由的人。</p>
<p>在一般人看來，投資必然有 回報，這是天經地義的事情。但是，很多人認為理所當然的事情，未必正確，而即便是那些我們每天都在使用的正確的結論，絕大部分人也不知道是為什麼？</p>
<p>今天和明天，我們就來聊聊在投資中哪些結論是站不住腳的，哪些幾乎是永恆的真理，對於那些永恆的真理，其背後的原因是什麼?知道了裡面的原因，我們就從被動狀態變成了主動| 狀態，從盲從的人，變成了自由的人。</p>
<h2 id="美洲發現了大銀礦"><a href="#美洲發現了大銀礦" class="headerlink" title="美洲發現了大銀礦"></a>美洲發現了大銀礦</h2><p>從歷史談財富的來源，先講講財富從哪裡來？</p>
<p>財富只有兩個來源「創造」、「掠奪」</p>
<p>從長遠本身，通過<strong>創造</strong>能獲得的財物富到遠比通過<strong>掠奪</strong>獲得的多得多。我們過對殖民時代有一個誤解，認為早期資本主義的財富是靠掠奪而來的。其實稍微有點一點頭腦的人可以算一筆賬，無論是非洲，美洲還是澳大利亞土著人，由於生產力極度低下，積累的那點財富少得可憐。甚至是後來西班牙人在美洲發現了大銀礦，接近乎掠奪獲得的財富，但是那些財富和英，荷重新創造的財富分配，只不過是九牛一毛，這也是後來為什麼葡萄牙和西班牙衰落，英，荷崛起的成就。</p>
<p><img src="Untitled1.png" alt="Untitled1.png"></p>
<p>另外，西班牙人開採的白銀，大約有1/3運到了中國買商品，這麼多錢所購買的商品不過是中國生產的很小一部分而已。對於資本主義的發跡，馬克思和恩格斯有句話說得特別到位</p>
<blockquote>
<p>在不到100年的時間裡，資產類別創造的生產力比過去一切時代創造的全部積累還要多，還要”大”。這揭示了我們財富的來源之謎</p>
</blockquote>
<h2 id="談談「掠奪」"><a href="#談談「掠奪」" class="headerlink" title="談談「掠奪」"></a>談談「掠奪」</h2><p>但是今天，人們已經無法直接去掠奪金銀了，但是依然有人通過掠奪獲得財富。什麼財富具有掠奪這種性質呢？其實非常多，比如像歐洲養了非常多的具有勞動能力卻在家吃福利，過得比工薪階層還要好的人，他們其實是在掠奪財</p>
<p>當然，對於東亞人和很多戰敗國家的人(比如德國)來講，在房地產上所獲得的財富也屬於這一類。在這些地區，大部分人主要的財富增長是來自於房地產的增值。房地產為什麼會增值呢?</p>
<blockquote>
<p>其實這部分價值(主要是土地的價值) 本身已經存在了，只是在開發房地產之前沒有量化度量而已</p>
</blockquote>
<p>這就像你家裡祖上留下一個花瓶，擺放了一百年也沒有人覺得它有什麼用， 忽然有一天佳士得的人跑來說，它值一個億， 於是你就有了一個億。</p>
<blockquote>
<p>土地的價值也是如此。這部分財富已經存在 了，就是沒有分配而已。後來土地可以變現後的價值是怎麼分配的呢？</p>
</blockquote>
<p>實際上誰有本事拿到就是誰的(掠奪的特點)。早期房地產開發商拿到了批零差價，而早期買房子的人實際上相當於拿到了零售的利潤說白了就是誰跑去拿，財富就給了誰。</p>
<h2 id="談談「勞動創造」"><a href="#談談「勞動創造」" class="headerlink" title="談談「勞動創造」"></a>談談「勞動創造」</h2><p>財富的第二個來源是靠勞動創造，這也是長期來講最可靠的來源。債券、股票和房地產投資能夠獲得回報的主要原因，是因為它們<em>參與了創造財富的過程</em></p>
<blockquote>
<p>從本質上講，投資獲利能夠成立的唯一原因：<br>就是生產力是不斷發展的，從長遠來講是經濟能夠增長！</p>
</blockquote>
<h2 id="資本的作用是什麼呢"><a href="#資本的作用是什麼呢" class="headerlink" title="資本的作用是什麼呢?"></a>資本的作用是什麼呢?</h2><p>對於一個企業的主人來講，資本的作用是什麼呢？它可以加速獲利的速度。比如一個公司有 1億的規模，一年可以獲利2000萬(20%)， 如果它有2個億，將規模擴大一倍，在理想狀態下，它可以獲得4000萬利潤。如果僅僅是通過自然增長擴大規模，那麼它的商業增長速度就很慢。</p>
<p><img src="Untitled2.png" alt="Untitled2.png"></p>
<p>那麼簡單的辦法就是它借來一個億，賺了額外的2000萬之後，將其中一部分利潤(比如一半)提供給資本所有者。至於需要付給資本的所有者多少錢，就看資本本身是多麼稀缺的資源了。如果兩個競爭對手都需要這一個億的現金，那麼他們開出的價格就高。反過來，如果有兩個銀行家都想給一個工廠主貸款，銀行家們就不得不接受低利息。這就是企業貸款，以及後來能夠流通的企業債券的由來。顯然，當資本太多時，回報就一定 下降。明白這一點，就容易看清中國經濟上的 一些現象了。</p>
<h2 id="利益的分配-股票的由來"><a href="#利益的分配-股票的由來" class="headerlink" title="利益的分配 | 股票的由來"></a>利益的分配 | 股票的由來</h2><p>當然有人會問，憑什麼經濟發展了，提供資本的人需要參加利益的分配呢？或者說創造財富的人為什麼必須把相當大的一部分利潤分給投資人呢?</p>
<blockquote>
<p>過去在中國普遍流行這樣一個經濟學觀點，就是<strong>利潤</strong>僅來自於勞動者的勞動 (即所謂的剩餘價值)，資本對於此沒有貢獻，因此資本不該參加分配利潤。</p>
</blockquote>
<p><img src="Untitled3.png" alt="Untitled3.png"></p>
<p>當然利益的分配的一種方式就是，一部分工廠主或者商人願意出讓一部分<strong><em>所有權</em></strong>獲得現金，而不借貸款，這就是後來股票的由來。 “股票”一詞的英文“stock”原意是存量，就是商人和工廠老闆所有的資產的代名詞。</p>
<blockquote>
<p>通常貨款和債券的回報是事先談好的且固定的。而股票的回報則是隨著一個公司贏利能力而變化的，如果創造財富的能力在增加， 那​​麼它的存量就值錢，資本的回報就增加。</p>
</blockquote>
<p>**總之資本是需要獲得回報的，這是錢能夠生錢的原因和合法性所在。</p>
<p>對於一個國家，情況也是如此，假如經濟發展的速度是10%，也就是說它今年比去年多創造了10%的財富，那麼創造這些財富的公司(或者其他機構)的價值，也應該相應增長。因此，從這個角度講，股市從長期來看永遠是向上走的，這是投資時少數幾個幾乎永遠成立的結論。正是因為如此，巴菲特才不建議做空股市，因為這是和客觀規律相違背的，也正是因為如此，那些堅持在股市上長期不斷投資的人都賺到錢了，如果你是一般等閒之輩的，就不要輕易做空股票。</p>
<hr>
<h2 id="結論："><a href="#結論：" class="headerlink" title="結論："></a>結論：</h2><p>早期沒有錢買房人的人，對不起。你沒有資格參加利益分配，但這種屬於一次或的掠奪財。如果此生沒機會參加，你倒是可以好好善用資本與勞動創造的循環，也就是投資！</p>
<p>讀了完資本跟利益的相關性，以及長期來看經濟向上的理由是緣自於「勞動創造」與「資本回創」，二大雙引擎，投資賺取利益的的循環就不會停下來。而擁有資本的人，它對社會上的任務就是不斷形這個流水，源源不絕倒進市場，他們的責任就是把賺到的錢在放入到社會，招來更多的生意跟受雇者，想想我們常說的M型化社會，其中一個意思是說大部份的錢集中到資本家身上，其實是一種善用活水的力量，他們把經驗跟火力撐起下一個經濟體，只是人們不喜歡總是住在大企業所建的規擇裡罷了。</p>
<hr>
<h2 id="股票的由來"><a href="#股票的由來" class="headerlink" title="股票的由來"></a>股票的由來</h2><p>當然，一部分工廠主或者商人願意出讓一部分 所有權獲得現金，而不借貸款，這就是後來股 票的由來。 “股票”一詞的英文“stock”原意是 | 存量，就是商人和工廠老闆所有的資產的代名詞。</p>
<p>通常，貨款和債券的回報是事先談好的， 固定的。而股票的回報則是隨著一個公司贏利 能力而變化的，如果創造財富的能力在增加， 那​​麼它的存量就值錢，資本的回報就增加。但 是，不論是發行股票，還是藉貸款，總之資本 是需要獲得回報的，這是錢能夠生錢的原因和 合法性所在。<br>對於一個國家，情況也是如此，假如經濟發展的速度是10%，也就是說它今年比去年多創造了10%的財富，那麼創造這些財富的公司(或者其他機構)的價值，也應該相應增長。因 此，從這個角度講，股市從長期來看永遠是向 上走的，這是投資時少數幾個幾乎永遠成立的 結論。正是因為如此，巴菲特才不建議做空股 | 市，因為這是和客觀規律相違背的，也正是因 為如此，那些堅持在股市上長期不斷投資的人 都掙到錢了。</p>
<h2 id="為什麼在全世界美國股市上漲比較快呢"><a href="#為什麼在全世界美國股市上漲比較快呢" class="headerlink" title="為什麼在全世界美國股市上漲比較快呢?"></a>為什麼在全世界美國股市上漲比較快呢?</h2><p>這裡面有兩個根本原因，首先是它的股市監管好， 風險小，而投資是要考慮風險的。根據我們之 前講的夏普比率，風險小的地方，這個比率就 會高，大家就願意投資，就會推高股市。<br>第二，也是最根本的，美國大部分上市公司都是國際化公司，標普500指數的成分股公司半的收入來自海外，通常美國GDP如果上漲1%，標普500指數能上漲2-3 %，這些放大效益主要來自於海外的利潤。此外，由於美國國產格採用退市製度，從2000年到2016年，退市公司的數量比上市公司的數量還略多，因此上市公司的資質較好，它們利潤的增長比未上市公司更快。只有保持上市公司的質量，股市才 能快速增長。<br>我們可以對比兩種不同的股市，一種是永遠只 保留10000家最好的公司，不合格的堅決淘 汰，可以想像這種股市的增長就會非常快。另 一一開始皇這nnon家上市公司 但見不</p>
<h2 id="美股的監管與下市機制"><a href="#美股的監管與下市機制" class="headerlink" title="美股的監管與下市機制"></a>美股的監管與下市機制</h2><p>美股收益主要來自於海外的利潤。此外，由於美國嚴格採用”下市製度”，從2000年到2016年，<em>下市公司的數量比上市公司的數量還略多</em>，因此上市公司的品資較好，它們利潤的增長比未上市公司更快。只有保持上市公司的質量，股市才能快速增長。</p>
<p>我們可以對比兩種不同的股市</p>
<ul>
<li>一種是永遠只保留10000家最好的公司，不合格的堅決淘汰，可以想像這種股市的增長就會非常快。</li>
<li>第二種一開始是這10000家上市公司，但是不淘汰，很快這裡面很多家因為各種原因變得沒有競爭力了，甚至一半的公司幾乎沒有利潤，即使這時候加入2000家新的好公司，股市規模變成12000家，這種股市的表現一定不如第一種好，因為它有5000家公司在裡面。</li>
</ul>
<p>由於產業更新非常快，一個公司能夠20年經營得不錯都是件非常困難的事情，因此，沒有淘汰機制的股市表現一定好不了。</p>
<p>理解了投資會有回報的本質，你就應該對(債</p>
<hr>
]]></content>
      <categories>
        <category>啟發</category>
      </categories>
      <tags>
        <tag>得到App</tag>
        <tag>吳軍</tag>
        <tag>voice book</tag>
      </tags>
  </entry>
  <entry>
    <title>[啟發] 讀書目的 v.s 滑手機目的 | The Propose between Reading and Phubbing</title>
    <url>/2020/02/12/%E5%95%9F%E7%99%BC-%E8%AE%80%E6%9B%B8%E7%9B%AE%E7%9A%84-v-s-%E6%BB%91%E6%89%8B%E6%A9%9F%E7%9B%AE%E7%9A%84-The-Propose-between-Reading-and-Phubbing/</url>
    <content><![CDATA[<h1 id="啟發-讀書目的-v-s-滑手機目的-The-Propose-between-Reading-and-Phubbing"><a href="#啟發-讀書目的-v-s-滑手機目的-The-Propose-between-Reading-and-Phubbing" class="headerlink" title="[啟發] 讀書目的 v.s 滑手機目的 | The Propose between Reading and Phubbing"></a>[啟發] 讀書目的 v.s 滑手機目的 | The Propose between Reading and Phubbing</h1><p>Status: Published</p>
<p>今天的分享主來自&lt;得到 App&gt; 吳軍 | 硅谷來信 | 219封信，談的是閱讀的目的。在開始之前先給你講二個故事，有一天下午作者在小鎮中的圖書館遇見了老奶奶，她借了一本&lt;哈利. 波特&gt;，作者問她“您喜歡看這種書？“，老奶奶說，是她自已想讀一讀</p>
<p><img src="Untitled.png" alt="Untitled.png"></p>
<h2 id="祖孫間的哈利波特"><a href="#祖孫間的哈利波特" class="headerlink" title="祖孫間的哈利波特"></a>祖孫間的哈利波特</h2><p>原來，她發現自已已經和過去疼愛有加的孫子陷入無話可說的尷尬境地。每當她打電話詢問孫子的生活情況，對房的回答僅幾個字：「挺好的」。有一天她問起來了孫子在看什麼書。孫子說剛開始看&lt;哈利.波特&gt;。</p>
<p>這位祖母也決定看看第一冊，看完之後，他們祖孫之間開始有了話題。</p>
<p>這位老奶奶和孫子雖有血緣關係，但其實沒有什麼共同之處，除老人的舐犢情深之外，他們又多聊天的話題，關係也更親近了</p>
<p><img src="Untitled1.png" alt="Untitled1.png"></p>
<h2 id="借書可以化競爭為友"><a href="#借書可以化競爭為友" class="headerlink" title="借書可以化競爭為友"></a>借書可以化競爭為友</h2><p>富蘭克林在他的自傳中講，他曾經有個頗有影響力政治對手，于是他想把那個人爭取過來。我們一般能想到的辨法是好言相勸，曉以之理，誘之以利，或是懇求對方。但是富蘭克林的方法郤很獨創，他去向對方借書，而對方還真的借給了他，最二個人成為了朋友。</p>
<p>為什麼借書這件事在當時的情況下非常可行？因為說明了至少二個人有共同的語言</p>
<blockquote>
<p>在此基礎上，談合作也好，談利益也罷，才搭得上話</p>
</blockquote>
<p>致于什麼惺惺相惜，那是深度交流後的結果。</p>
<h2 id="閱讀的目的"><a href="#閱讀的目的" class="headerlink" title="閱讀的目的"></a>閱讀的目的</h2><p>今天，我們閱讀不僅僅是為了交朋友，而是為了改變生活方式 ，當網路出現時，我們很容易就能夠獲取知識</p>
<blockquote>
<p>現在我們每天給自已安排的行程非常滿，一直在抱怨自已太忙，但並不清楚時間都花到哪裡去了。</p>
</blockquote>
<p>我們總是在買一些不需要的東西，然後因為它們堆滿了房間，塞滿了抽屜而心煩。我們有很多提高效率的工具，但是郤難以擁有充足而優質的睡眠。</p>
<blockquote>
<p>我們許許多多的「熟人」加了LINE，但是能說點真心話的朋友越來越少</p>
</blockquote>
<p>我們每天刷手機FB、IG、各種消息，但是那些內容我們什麼也沒有記住，也沒有對我們產生任何影響。</p>
<h2 id="滑手機背後的恐懼"><a href="#滑手機背後的恐懼" class="headerlink" title="滑手機背後的恐懼"></a>滑手機背後的恐懼</h2><p>其實這樣現象的背後透露著一種恐懼</p>
<blockquote>
<p>生怕自已錯過些什麼。不論我們身在何處，總怕沒有看到某一條消息，錯過了什麼機會。</p>
</blockquote>
<p>一個人總希望能經歷更多好玩的事情，看到更多的風景，品嚐到更多的美食，等等。我們把它稱為快節奏，但這其實是沒有節奏。</p>
<p><img src="Untitled2.png" alt="Untitled2.png"></p>
<h2 id="失去自主能力的感覺"><a href="#失去自主能力的感覺" class="headerlink" title="失去自主能力的感覺"></a>失去自主能力的感覺</h2><p>&lt;不滑手機會怎樣嗎？&gt; 這篇Blog很深刻了記錄滑手機時的前後心境，我們不妨來看看：</p>
<p>「人到中年之後，當你的生活有了擺脫不了的壓力，突破不了的困難，每當想逃避時，有樣東西能讓你暫時忘記煩憂，就很容易對不好的東西上癮，<strong>一種失去自主能力的感覺</strong>，這也就是我們中年人常常看起來很廢的原因吧！」</p>
<h2 id="未經審視的人生"><a href="#未經審視的人生" class="headerlink" title="未經審視的人生"></a>未經審視的人生</h2><p>蘇格拉底臨死前說未經審視的人生不值得度過，而審視人生需要有閒暇。我們今天有很多獲取知識的管道，但是它們不能幫助我們審視人生，因為它們不能給我們帶來閒暇，反而讓我們更加沒有閒暇來思考。</p>
<h2 id="讀書可以”慢下來"><a href="#讀書可以”慢下來" class="headerlink" title="讀書可以”慢下來"></a>讀書可以”慢下來</h2><p>讀書則不同，尤其是在閱讀紙本時，我們必須有比較長的一段時間，不做其它的事情，這樣才能讀進去，正因為是不得把手邊的事情先放一邊，才能夠審視人生。因此作者看來，閱讀是一件協助檢審人生的活動。</p>
<h2 id="寫下來可以”更慢"><a href="#寫下來可以”更慢" class="headerlink" title="寫下來可以”更慢"></a>寫下來可以”更慢</h2><p>其實我很鼓勵大家寫作，很多時候當思緒亂了，想找個人抒發心情，當下找不到傾訴對向時，如果你有寫作的習慣，會發現在寫作的同時，思緒會慢下來，順便整理一下心情，思緒同樣也有個出口，您不妨試試</p>
<p><img src="Untitled3.png" alt="Untitled3.png"></p>
<h2 id="結論："><a href="#結論：" class="headerlink" title="結論："></a>結論：</h2><p>多年來很多人包括我，開始注意自已使用手機的習慣。起初文章是說明閱讀的好處，但讓我最具啟發的地方是：讓我終於明白這個<strong>深層的答案</strong>，刷手機的原因是<strong>生怕自已錯過些什麼。</strong>這個答案太衝擊，直接點出人性</p>
<p>人類是個群體動物，進化到現今生存就要合作與溝通，心理也不免會隨時想接收新的訊息，建立待下次和別人溝通、合作的基礎，這點是否跟<strong>祖孫間的哈利波特</strong>故事十分相近呢？</p>
<hr>
<p>今天的分享主來自&lt;得到 App&gt; 吳軍 | 硅谷來信 | 219封信，談的是閱讀的目的。在開始之前先給你講二個故事，有一天下午作者在小鎮中的圖書館遇見了老奶奶，她借了一本&lt;哈利. 波特&gt;，作者問她“您喜歡看這種書？“，老奶奶說，是她自已想讀一讀</p>
<h2 id="祖孫間的哈利波特-1"><a href="#祖孫間的哈利波特-1" class="headerlink" title="祖孫間的哈利波特"></a>祖孫間的哈利波特</h2><p>原來，她發現自已已經和過去疼愛有加的孫子陷入無話可說的尷尬境地。每當她打電話詢問孫子的生活情況，對房的回答僅幾個字：「挺好的」。有一天她問起來了孫子在看什麼書。孫子說剛開始看&lt;哈利.波特&gt;。</p>
<p>這位祖母也決定看看第一冊，看完之後，他們祖孫之間開始有了話題。</p>
<p>這位老奶奶和孫子雖有血緣關係，但其實沒有什麼共同之處，除老人的舐犢情深之外，他們又多聊天的話題，關係也更親近了</p>
<p><img src="Untitled4.png" alt="Untitled4.png"></p>
<h2 id="借書可以化競爭為友-1"><a href="#借書可以化競爭為友-1" class="headerlink" title="借書可以化競爭為友"></a>借書可以化競爭為友</h2><p>富蘭克林在他的自傳中講，他曾經有個頗有影響力政治對手，于是他想把那個人爭取過來。我們一般能想到的辨法是好言相勸，曉以之理，誘之以利，或是懇求對方。但是富蘭克林的方法郤很獨創，他去向對方借書，而對方還真的借給了他，最二個人成為了朋友。</p>
<p>為什麼借書這件事在當時的情況下非常可行？因為說明了至少二個人有共同的語言</p>
<blockquote>
<p>在此基礎上，談合作也好，談利益也罷，才搭得上話</p>
</blockquote>
<p>致于什麼惺惺相惜，那是深度交流後的結果。</p>
<p>Ｘ</p>
<p><img src="Untitled5.png" alt="Untitled5.png"></p>
<h2 id="閱讀的目的-1"><a href="#閱讀的目的-1" class="headerlink" title="閱讀的目的"></a>閱讀的目的</h2><p>今天，我們閱讀不僅僅是為了交朋友，而是為了改變生活方式 ，當網路出現時，我們很容易就能夠獲取知識</p>
<blockquote>
<p>現在我們每天給自已安排的行程非常滿，一直在抱怨自已太忙，但並不清楚時間都花到哪裡去了。</p>
</blockquote>
<p>我們總是在買一些不需要的東西，然後因為它們堆滿了房間，塞滿了抽屜而心煩。我們有很多提高效率的工具，但是郤難以擁有充足而優質的睡眠。</p>
<blockquote>
<p>我們許許多多的「熟人」加了LINE，但是能說點真心話的朋友越來越少</p>
</blockquote>
<p>我們每天刷手機FB、IG、各種消息，但是那些內容我們什麼也沒有記住，也沒有對我們產生任何影響。</p>
<h2 id="滑手機背後的恐懼-1"><a href="#滑手機背後的恐懼-1" class="headerlink" title="滑手機背後的恐懼"></a>滑手機背後的恐懼</h2><p><img src="Untitled6.png" alt="Untitled6.png"></p>
<p>其實這樣現象的背後透露著一種恐懼</p>
<blockquote>
<p>生怕自已錯過些什麼。不論我們身在何處，總怕沒有看到某一條消息，錯過了什麼機會。</p>
</blockquote>
<p>一個人總希望能經歷更多好玩的事情，看到更多的風景，品嚐到更多的美食，等等。我們把它稱為快節奏，但這其實是沒有節奏。</p>
<h2 id="失去自主能力的感覺-1"><a href="#失去自主能力的感覺-1" class="headerlink" title="失去自主能力的感覺"></a>失去自主能力的感覺</h2><p>&lt;不滑手機會怎樣嗎？&gt; 這篇Blog很深刻了記錄滑手機時的前後心境，我們不妨來看看：</p>
<p>「人到中年之後，當你的生活有了擺脫不了的壓力，突破不了的困難，每當想逃避時，有樣東西能讓你暫時忘記煩憂，就很容易對不好的東西上癮，<strong>一種失去自主能力的感覺</strong>，這也就是我們中年人常常看起來很廢的原因吧！」</p>
<h2 id="未經審視的人生-1"><a href="#未經審視的人生-1" class="headerlink" title="未經審視的人生"></a>未經審視的人生</h2><p>蘇格拉臨死前說未經審視的人生不值得度過，而審視人生需要有閒暇。我們今天有很多獲取知識的管道，但是它們不能幫助我們審視人生，因為它們不能給我們帶來閒暇，反而讓我們更加沒有閒暇來思考。</p>
<h2 id="讀書可以”慢下來-1"><a href="#讀書可以”慢下來-1" class="headerlink" title="讀書可以”慢下來"></a>讀書可以”慢下來</h2><p>讀書則不同，尤其是在閱讀紙本時，我們必須有比較長的一段時間，不做其它的事情，這樣才能讀進去，正因為是不得把手邊的事情先放一邊，才能夠審視人生。因此作者看來，閱讀是一件協助檢審人生的活動。</p>
<h2 id="寫下來可以”更慢-1"><a href="#寫下來可以”更慢-1" class="headerlink" title="寫下來可以”更慢"></a>寫下來可以”更慢</h2><p>其實我很鼓勵大家寫作，很多時候當思緒亂了，想找個人抒發心情，當下找不到傾訴對向時，如果你有寫作的習慣，會發現在寫作的同時，思緒會慢下來，順便整理一下心情，思緒同樣也有個出口，您不妨試試</p>
<h2 id="結論：-1"><a href="#結論：-1" class="headerlink" title="結論："></a>結論：</h2><p>多年來很多人包括我，開始注意自已使用手機的習慣。起初文章是說明閱讀的好處，但讓我最具啟發的地方是：讓我終於明白這個<strong>深層的答案</strong>，刷手機的原因是<strong>生怕自已錯過些什麼。</strong>這個答案太衝擊，直接點出人性</p>
<p>人類是個群體動物，進化到現今生存就要合作與溝通，心理也不免會隨時想接收新的訊息，建立待下次和別人溝通、合作的基礎，這點是否跟<strong>祖孫間的哈利波特</strong>故事十分相近呢？</p>
<p><img src="Untitled7.png" alt="Untitled7.png"></p>
<p><img src="Untitled8.png" alt="Untitled8.png"></p>
<h2 id="失去自主能力的感覺-2"><a href="#失去自主能力的感覺-2" class="headerlink" title="失去自主能力的感覺"></a>失去自主能力的感覺</h2><p>&lt;不滑手機會怎樣嗎？&gt; 這篇文章很深刻了記錄滑手機時的前後心境，我們不房來看看：「人到中年之後，當你的生活有了擺脫不了的壓力，突破不了的困難，每當想逃避時，有樣東西能讓你暫時忘記煩憂，就很容易對不好的東西上癮，<strong>一種失去自主能力的感覺</strong>，這也就是我們中年人常常看起來很廢的原因吧！」</p>
]]></content>
      <categories>
        <category>啟發</category>
      </categories>
      <tags>
        <tag>得到App</tag>
        <tag>吳軍</tag>
        <tag>voice book</tag>
      </tags>
  </entry>
  <entry>
    <title>[啟發] 量化科學的一日之計 | An hour in the morning is worth two in the evening</title>
    <url>/2020/02/12/%E5%95%9F%E7%99%BC-%E9%87%8F%E5%8C%96%E7%A7%91%E5%AD%B8%E7%9A%84%E4%B8%80%E6%97%A5%E4%B9%8B%E8%A8%88-An-hour-in-the-morning-is-worth-two-in-the-evening/</url>
    <content><![CDATA[<h1 id="啟發-量化科學的一日之計-An-hour-in-the-morning-is-worth-two-in-the-evening"><a href="#啟發-量化科學的一日之計-An-hour-in-the-morning-is-worth-two-in-the-evening" class="headerlink" title="[啟發] 量化科學的一日之計 | An hour in the morning is worth two in the evening"></a>[啟發] 量化科學的一日之計 | An hour in the morning is worth two in the evening</h1><p>Status: Published Medium</p>
<h2 id="常言道：一日之計在於晨"><a href="#常言道：一日之計在於晨" class="headerlink" title="常言道：一日之計在於晨"></a>常言道：一日之計在於晨</h2><p>世界上很多道理，你一聽覺得它肯定對，那你為什麼不去執行呢？可能是你還未察覺到他的重要性，<strong>一日之計在於晨</strong>，說得是學習和工作一定要抓緊早上的時光。可是早上覺得有精神到底是一種感覺呢，還是真有什麼明顯的影響呢？</p>
<p>光有知道這個道理是不行的，我們還需要知道這個道理重要程度，是不是真值得我們調整做事的優先級別，因此你需要有實證有量化分析，這就是</p>
<blockquote>
<p><strong>科學方法</strong> 和傳統智慧的差別</p>
</blockquote>
<p>本文是讀完&lt;得到&gt;app | 萬維鋼老師的 | &lt;見機&gt; 這門課心得，課堂參考2018出版的&lt;見機：完美的科學秘密&gt; (When The Scientific Secrets of Perfect Timing)內容，作者透過大量數據來解釋人們如何使用的時間，並提醒人們使用時間才有效率</p>
<p><img src="Untitled.png" alt="Untitled.png"></p>
<p><a href="https://www.books.com.tw/products/F014128997" target="_blank" rel="noopener">https://www.books.com.tw/products/F014128997</a></p>
<h2 id="一日之中的高低潮"><a href="#一日之中的高低潮" class="headerlink" title="一日之中的高低潮"></a>一日之中的高低潮</h2><p>下圖是紐約時報的報導，X軸是一天之中的時刻，Y軸代表的是情緒，總得來說人們在週未的情緒普遍上較好，另外一個觀察是不論是那一天，情緒變化的曲線型狀都非常相似</p>
<p>早上起來七八點鐘是情緒的高峰，這時候大家說話比較正面，之後人們的情緒變化會慢慢變低落，到下午五點左右達到最低潮(等下班)。而晚上，人們的情緒又開始回升，到了午夜又達到一個高峰，您不妨可以檢視自已是有吻合這樣的情緒浮動</p>
<p><img src="Untitled1.png" alt="Untitled1.png"></p>
<p><a href="https://stoweboyd.com/post/10862664306/moods-on-twitter-follow-biological-rhythms-study" target="_blank" rel="noopener">https://stoweboyd.com/post/10862664306/moods-on-twitter-follow-biological-rhythms-study</a></p>
<h2 id="研究指出：情緒變化三個時段"><a href="#研究指出：情緒變化三個時段" class="headerlink" title="研究指出：情緒變化三個時段"></a>研究指出：情緒變化三個時段</h2><p>人的下丘腦之中有個視交叉核，負責整個不同時段的荷爾蒙分佈，其實這就是我們的生理時鐘。而情緒，顯然是受到時生理時鐘的影響。</p>
<p>總結來說，我們可以把一天的之中的情緒變化分為三段：</p>
<blockquote>
<p>上午達到高峰，下午經歷低潮，晚上出現反彈</p>
</blockquote>
<h2 id="集中精神的時機點"><a href="#集中精神的時機點" class="headerlink" title="集中精神的時機點"></a>集中精神的時機點</h2><p><a href="https://www.thenewslens.com/article/88323" target="_blank" rel="noopener">大腦有二種思維模式</a>：一種是<strong>集中思維</strong>，需要你嚴格按照規則執行，比如說做數學題。集中思維要求大腦處於機靈的狀態，集中注意力。另一種是<strong>發散思維</strong>，適合創造性的活動，注意力不集，混亂一點反而更好。若依照上面的統計結果：<strong>你最好在上午從事集中思維，下午從事發散思維</strong>。</p>
<p><img src="Untitled2.png" alt="Untitled2.png"></p>
<p>「專注模式」和「發散模式」 <a href="https://www.thenewslens.com/article/88323" target="_blank" rel="noopener">https://www.thenewslens.com/article/88323</a></p>
<h2 id="粹鍊過的大數據結論"><a href="#粹鍊過的大數據結論" class="headerlink" title="粹鍊過的大數據結論"></a>粹鍊過的大數據結論</h2><p>相信或不相信科學結果是主觀的決定。但你都不知道的生理反應，數據則會說話。會有人說，難到我早上自已起來精力好不好，什麼時候適合做什麼自已還不知道嗎？為什麼要聽研究報告說的話？</p>
<p>你可能真的不知道，但你肯定有個印象，你沒做過量化分析，也許你感覺上午精力更好，但是你不知道有多少，你不知道值不值得為此改變作習，改變工作安排</p>
<h2 id="量化應用在運動"><a href="#量化應用在運動" class="headerlink" title="量化應用在運動"></a>量化應用在運動</h2><p>現在很流行的量化自我的運動，誰誰誰每天跑了幾公里，把距離分享到社交網路，還要和朋友比較一驟。但社交可不是量化自我的真正的本義，量化自我是一種科學的方法，它的真正目的是為了了解自已、研究自已、對自已做出更好的安排</p>
<h2 id="高手善於觀察自已"><a href="#高手善於觀察自已" class="headerlink" title="高手善於觀察自已"></a>高手善於觀察自已</h2><p>科學的價值是什麼。別人是用分析了四億條twitter和26000個con-call才得出這些結論，而且給你提供了一個度。有這個度(量)，我們才談得上是科學決策</p>
<p>量化分析是高手必備的能力。你到底是白天雲雀還是夜間貓頭鷹？自已做個量化分析，看看你在一天中的高峰，低潮和反彈期到底是在什麼時候，並好好的利你的有限時間吧</p>
<p><img src="Untitled3.png" alt="Untitled3.png"></p>
<p>不管心情怎麼變化，都要認識、掌握自已 photo by medium.com</p>
<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>人的情緒和認知能力在一天之中有明顯的變化，可以分為高峰、低潮和反彈三個時段。你必須</p>
<blockquote>
<p>了解自已的這三個時間都在什麼候，對各種任務給予合理的安排</p>
</blockquote>
<h3 id="參考："><a href="#參考：" class="headerlink" title="參考："></a>參考：</h3><ul>
<li>&lt;得到&gt;app | 萬維鋼老師 | &lt;見機&gt;</li>
<li><a href="https://stoweboyd.com/post/10862664306/moods-on-twitter-follow-biological-rhythms-study" target="_blank" rel="noopener">Moods on Twitter Follow Biological Rhythms, Study Find - NYTimes.com</a></li>
<li><a href="https://www.thenewslens.com/article/88323" target="_blank" rel="noopener">《深度學習的技術》：從「專注模式」切換到「發散模式」</a></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>啟發</category>
      </categories>
      <tags>
        <tag>得到App</tag>
        <tag>吳軍</tag>
        <tag>voice book</tag>
      </tags>
  </entry>
  <entry>
    <title>[投資] 社會價值 v.s 會滾動的現金流 | Identity and Rich Dad Impression</title>
    <url>/2020/02/12/%E6%8A%95%E8%B3%87-%E7%A4%BE%E6%9C%83%E5%83%B9%E5%80%BC-v-s-%E6%9C%83%E6%BB%BE%E5%8B%95%E7%9A%84%E7%8F%BE%E9%87%91%E6%B5%81-Identity-and-Rich-Dad-Impression/</url>
    <content><![CDATA[<h1 id="投資-社會價值-v-s-會滾動的現金流-Identity-and-Rich-Dad-Impression"><a href="#投資-社會價值-v-s-會滾動的現金流-Identity-and-Rich-Dad-Impression" class="headerlink" title="[投資] 社會價值 v.s 會滾動的現金流 | Identity and Rich Dad Impression"></a>[投資] 社會價值 v.s 會滾動的現金流 | Identity and Rich Dad Impression</h1><p>Status: Published</p>
<h2 id="打理自已的事-自已的資產欄"><a href="#打理自已的事-自已的資產欄" class="headerlink" title="打理自已的事: 自已的資產欄"></a>打理自已的事: 自已的資產欄</h2><p>此次心得是來自<a href="https://www.books.com.tw/products/0010791121" target="_blank" rel="noopener">&lt;富爸爸，窮爸爸&gt;</a>一書中的片段內容，分享於大家。作者常說打理自已的事業時，其意思就是建立自已強的大「資產欄」。目的是</p>
<blockquote>
<p>只要有任何一塊錢流進你的資產，就不要讓它流走</p>
</blockquote>
<p>你這樣想吧，這一塊錢落進你的資產欄，它就是你的雇員了。關於錢，最美妙的是，它能一天24小時不斷地工作，並為你的子孫服務。</p>
<p><img src="Untitled.png" alt="Untitled.png"></p>
<p>如果想致富，就需要學習財務知識。 首先，必須先<strong>明白資產與負債的區別</strong>，並且購持續買資產</p>
<p>在我觀察的存股部落格中&lt;<a href="https://www.facebook.com/dragonsky7/" target="_blank" rel="noopener">孫悟天</a>&gt;也都是提倡這個觀念，簡單說也就是<strong>錢生錢</strong>的最基礎概念。</p>
<blockquote>
<p>千萬記住：生出來的利息、配股，都不能動<br>它們的存在是為了下一張股票的生存的。</p>
</blockquote>
<h2 id="窮人和中產皆級的別差"><a href="#窮人和中產皆級的別差" class="headerlink" title="窮人和中產皆級的別差"></a>窮人和中產皆級的別差</h2><p>當你的現金流增加時(開始滾動時)，你可以買一點奢侈品，一個重要的區別是富人最後才買奢侈品，而窮人和中產階級則傾向先買奢侈品。他們會先買下諸如大房子(注意他是說大房子)、皮衣、珠寶、遊艇等奢侈品，因為他們想看上去很富有。</p>
<h2 id="社會的虛榮感"><a href="#社會的虛榮感" class="headerlink" title="社會的虛榮感"></a>社會的虛榮感</h2><p>我自個兒想想，因為人們身上有著社會的虛榮感，造就人們的普遍認知。</p>
<blockquote>
<p>即使古代的哲人早已道盡生命的過程，解答人生的困惑，只是我仍然惑於現實的虛榮，無法放下，所以焦慮不堪</p>
</blockquote>
<p>by 無垢劇場-林麗珍</p>
<p><img src="Untitled1.png" alt="Untitled1.png"></p>
<p>他們看上去的確很富有，但已深陷貸款的陷阱之中。那些有錢二代繼承遺產的人，都是父祖輩先建立他們的資產，然後才用資產所產生的的收入購買奢侈品；窮人和中產則用他們的<strong>血汗錢</strong>，和原本要留給孩子們的遺產去購買奢侈品。</p>
<h2 id="奢侈品的正當性"><a href="#奢侈品的正當性" class="headerlink" title="奢侈品的正當性"></a>奢侈品的正當性</h2><p>真正的奢侈品，應該是來自投資和積累<strong>真正的資產獎勵</strong>。比如說投資獲得的額外收入，可以使用這筆錢去購買奢侈品。這樣的循環，證明了理財效益，也意味自已能夠用自已的財務知識得到它，因為缺乏財務知識，或是執行力不足都是在懲罰自已。</p>
<p><img src="Untitled2.png" alt="Untitled2.png"></p>
<h2 id="劫富說"><a href="#劫富說" class="headerlink" title="劫富說"></a>劫富說</h2><p>劫富可以說是針對富人的稅人，政府希望以控制金錢的流向以補助中產以下階層。殊不知富人終究是有各種節稅的方法，讓稅法影響不到自已的財產。</p>
<p>這邊舉個例子：一旦稅法通過，錢便開始流入國庫。起初人們很高興，可是錢郤被政府分配了雇員和富人。怎麼說呢？稅金透過工作和退休金的形式發給了政府雇員，另外透過政府的採購的形式付給了富人。政府是形成了一個巨大的錢庫，但財政的管理方式，讓錢又回流於富人。舉個專案預算的例子，政府的理想是避免擁有結餘，如果你沒有用完預用款，在下次預算你就會被削減這些錢的風險。因為你不會因為有結餘款被認為有效率並得到獎勵，此時商人則因為有結餘而得到獎勵。</p>
<h2 id="公司保護富人"><a href="#公司保護富人" class="headerlink" title="公司保護富人"></a>公司保護富人</h2><p>公司的確是保護富人，一般人不明白這個道理。因為公司不一定是真正的實體，另一種說法它可以只是一種形式上符合法律要求的文件，符合需求後即可註冊為公司。正因為企業所得稅率低於個人收入所得稅率，所以公司可以在稅前就先獲得抵減。</p>
<h2 id="結論："><a href="#結論：" class="headerlink" title="結論："></a>結論：</h2><p>我個人十分認同資產欄造就的現金流，對此也解決現況是否採取購房行動。另外我想提到的是只要是為人，就會有意識，思想讓我們有存在感，我們常被需要被受認同和肯定(<a href="https://neganchor.com/2015-01-02-300/" target="_blank" rel="noopener">自我認同 identity</a>)，如果自由意志思被社會牽著走，那又何嘗成為人呢？</p>
<p>這邊順道分享<a href="https://medium.com/@Learnhu/nlp%E4%B8%AD%E9%9A%8E-1-%E6%99%82%E9%96%93%E7%B7%9A-%E5%BE%9E%E5%B1%AC%E7%AD%89%E7%B4%9A-3d2d7653838d" target="_blank" rel="noopener">NLP稱為從屬等級（Logical Level）</a>。這東西是心靈成長課裡我個人獲益最多的一個模型，用這套模型去觀察他人或是檢視自我的內心狀態</p>
<p><img src="Untitled3.png" alt="Untitled3.png"></p>
<p>這是一張NLP, 心理學模型，其中自我認同（Identity）是很高的部份僅次於你的靈性。一旦沒有自我就會面臨種種負面情緒</p>
<p>書中用很嚴肅的口吻談劫富的觀點，富人和窮人之間的戰爭已經進了幾百年了。任何時間，只要制定稅法就會這種鬥爭。問題是輸家一定是無知者，即是那些每天起來勤奮工作以及繳稅的人。所以趕緊經營你的資產欄吧</p>
<p><img src="Untitled4.png" alt="Untitled4.png"></p>
<p><img src="Untitled5.png" alt="Untitled5.png"></p>
]]></content>
      <categories>
        <category>啟發</category>
      </categories>
      <tags>
        <tag>book</tag>
        <tag>Rich Dad</tag>
      </tags>
  </entry>
  <entry>
    <title>[教育] 思考才是教育的核心 | Forward to I think, therefore I am</title>
    <url>/2020/02/12/%E6%95%99%E8%82%B2-%E6%80%9D%E8%80%83%E6%89%8D%E6%98%AF%E6%95%99%E8%82%B2%E7%9A%84%E6%A0%B8%E5%BF%83-Forward-to-I-think-therefore-I-am/</url>
    <content><![CDATA[<h1 id="教育-思考才是教育的核心-Forward-to-I-think-therefore-I-am"><a href="#教育-思考才是教育的核心-Forward-to-I-think-therefore-I-am" class="headerlink" title="[教育] 思考才是教育的核心 | Forward to I think, therefore I am"></a>[教育] 思考才是教育的核心 | Forward to I think, therefore I am</h1><p>Status: Published</p>
<p>今天分享來自&lt;天下雜誌&gt; | 685期 和 &lt;得到app&gt;  | 谷歌方法論 43封信</p>
<p>談的是<strong>教學的核心，</strong>我們先看看雜誌專訪的副標題</p>
<p>國語課的核心並非修此而<strong>是文本</strong>，數學課的更不是算式而<strong>是邏輯</strong></p>
<p>若不想單方面餵養標準簽案，老師該怎麼做才能帶動學生<strong>獨立思考？</strong></p>
<p>透過不斷提問、雙向溝通與同儕討論，這所小學的改變正大力發酵</p>
<p><img src="Untitled.png" alt="Untitled.png"></p>
<p><img src="Untitled1.png" alt="Untitled1.png"></p>
<h2 id="台南復興國五年七班，很不一樣"><a href="#台南復興國五年七班，很不一樣" class="headerlink" title="台南復興國五年七班，很不一樣"></a>台南復興國五年七班，很不一樣</h2><p>鐘聲剛響起，進行的是國語課，學生們用手指默讀課文「一池子的綠」，讀完後再闔上。接著老師開發問：「一池子的綠」是指什麼？此時應答聲此起彼落，是「水芺蓉！」</p>
<p>接又老師又問：「池子在哪裡？」，學生回答到「在作老家裡！」課堂中，雙方一來一往，就像一顆球碰撞牆壁不斷反彈。邱老師得到答案後，不斷拋出問題，學生埋頭討論，從課文找出答案。</p>
<p>隨著時間推進，問題的難度也逐進提升，這時，學生得找出課文形容的「美」句子，並分析原因…</p>
<p><img src="Untitled2.png" alt="Untitled2.png"></p>
<p>翻拍天下雜誌 | 685期 專訪</p>
<h2 id="答案相同，理由不同"><a href="#答案相同，理由不同" class="headerlink" title="答案相同，理由不同"></a>答案相同，理由不同</h2><p>邱老師提醒學生不怕答案相同，<strong>因為你們的理由不會每個字都一樣</strong>。想辨法生出一點點不一樣，這就是挑戰！這樣的上課方式</p>
<blockquote>
<p>打破以往國語課逐段解講課文，再教生字、圈詞的模版。</p>
</blockquote>
<h2 id="整體到微觀，引導思考"><a href="#整體到微觀，引導思考" class="headerlink" title="整體到微觀，引導思考"></a>整體到微觀，引導思考</h2><p>邱老師藉由問答，從整體到微觀，引導學生<strong>自動</strong>細讀課文。四十分鐘的國文課到了尾聲，</p>
<blockquote>
<p>學生們都可以抓到文本的核核心精神</p>
</blockquote>
<p>邱老師以「一池子的綠」為例，說明學生在提問下不斷練習<strong><em>觀察、探究、思辯</em></strong>，連結日常生活，找出作者借物抒情，用不同技法描寫<strong>美</strong>的重點。</p>
<p><img src="Untitled3.png" alt="Untitled3.png"></p>
<p>powered by Pexels: thinking</p>
<h2 id="餵養教育-填鴨教育"><a href="#餵養教育-填鴨教育" class="headerlink" title="餵養教育(填鴨教育)"></a>餵養教育(填鴨教育)</h2><p>邱老師教書資歷17年，5年前接觸到日本教育大師「學習共同體」，邱老師開始改變教學方法，希望翻轉老師單向「餵養」知識的模式</p>
<p>曾是邱老師的同學觀察到如何做到<strong>整體到微觀，引導學生思考。</strong>老師的角色是負責起頭、穿針引線請學生發予，下課前整理、歸納學生的想法。這個概念和我最近上培訓課，去當客戶的助教的經驗相符，小組討論時即使同學一片極靜、沉默甚至是沒興趣，我的任務就是 → <strong>引領思考，歸納重點</strong>。</p>
<h2 id="畢業同學現身說法"><a href="#畢業同學現身說法" class="headerlink" title="畢業同學現身說法"></a>畢業同學現身說法</h2><p>目前就讀國一的李同學，曾是邱老師的學生則很有感：「國中的題目比較繁雜，考試強調思考邏輯，不是呆板的文子，尤其是數學，落差很大」，而剛結束段考的她認為小學累積2年的閱讀理解能力，確實對於銜接國中課程有幫助。不斷引導學生思考、討論是本質，課堂不應只是追求標準答案，而是釐清疑惑的地方。</p>
<h2 id="美國人的歷史課"><a href="#美國人的歷史課" class="headerlink" title="美國人的歷史課"></a>美國人的歷史課</h2><p>在台灣和中國，一般的歷史課是講述歷史事件和它們的影響，學生記住結論就好。但美國，學歷史是為了學會做究，這一點是美國教育的重點。他們的歷史課很大一部份成績是做研究，比如說分析一下華盛頓這個人在歷史作用，這種練習在中學就這樣要求了</p>
<blockquote>
<p>對於作業沒有絕對正確的標準答案，只有好的答案和不好的答案。</p>
</blockquote>
<p>你可以說華盛頓是了不起的偉人，也可以說是為了維護白人利益自的政治家。</p>
<p>不管怎麼說</p>
<blockquote>
<p>分析得要有理有據，結論必須是由証據自然推演出的邏輯結果，當然報告還要寫得好。</p>
</blockquote>
<p>吳軍 | 谷歌方法論 43封 | 為什麼要學歷史</p>
<p><img src="Untitled4.png" alt="Untitled4.png"></p>
<p>讀過一次華盛頓簡介，每個人的認知都不盡相同</p>
<h2 id="結論："><a href="#結論：" class="headerlink" title="結論："></a>結論：</h2><p>108年課綱以素養教育為核心，國小、國中、高中各自要把素養培養到什麼程度，其實都寫了很清楚，近年課綱一直在改，教學方式只能靠老師們自覺，很多人說，教育要仿歐美的教育捨棄現況的課綱。我們就用美國人學歷史來借鏡，課程不是唯一重點，真正的重點在老師的<strong>教學手法！</strong>因此老師在培育台灣未來十年、二十年後需要的人才，無論是課程設計或教學，都要有<strong>永續的概念</strong>。</p>
<p>美國歷史課的學習，學生們的驗究能力、分析和寫作能力都得到了訓練，我認為這就是最佳自<strong>主思考的能力</strong>。</p>
<p>常言道：終生學習的背後，其實就是<strong>自學</strong>，而懂得主動求知，找資料就是一切的根本。張忠謀也提倡<a href="https://money.udn.com/money/story/5648/3887498" target="_blank" rel="noopener">只有終身學習，才可避免被AI取代</a>，這觀念尤其重要！</p>
<blockquote>
<p>專業的道路上，只有累積沒有奇蹟<br>時間花在那裡，成就就在那裡</p>
</blockquote>
<hr>
<hr>
<p><img src="Untitled5.png" alt="Untitled5.png"></p>
<p><img src="Untitled6.png" alt="Untitled6.png"></p>
<p><img src="Untitled7.png" alt="Untitled7.png"></p>
<p><img src="Untitled2.png" alt="Untitled2.png"></p>
<p>經過這樣歷史課的學習，學生們的破究能力、分析和寫作能力都得到了訓練。</p>
<p><img src="Untitled8.png" alt="Untitled8.png"></p>
<h2 id="學歷史是為了學會做究"><a href="#學歷史是為了學會做究" class="headerlink" title="學歷史是為了學會做究"></a>學歷史是為了學會做究</h2><p>在美國，學歷史是為了學會做究，這一點是美國教育的重點。</p>
<p>一般的歷史課是講述歷史事件和它們的影響，學生記住結論就好。</p>
<p>在美國，歷史課很大一部份成績是做研究，比如說分析一下華盛頓這個人在歷史作用，這種練習在中學就這樣要求了，對於這樣的作業，沒有絕對正確的標準答案，只有好的答案和不好的答案。</p>
<p>你可以說華盛頓是了不起的偉人，也可以說是為了維護白人利益自的政治家。不管怎麼說，分析得要有理有據，結論必須是由証據自然推演出的邏輯結果，當然報告還要寫得好。</p>
<p>經過這樣歷史課的學習，學生們的驗究能力、分析和寫作能力都得到了訓練。</p>
<p>吳軍 | 谷歌方法論 43封 | 為什麼要學使史</p>
<p><img src="Untitled9.png" alt="Untitled9.png"></p>
<p><img src="Untitled10.png" alt="Untitled10.png"></p>
<p><img src="Untitled11.png" alt="Untitled11.png"></p>
]]></content>
      <categories>
        <category>啟發</category>
      </categories>
      <tags>
        <tag>得到App</tag>
        <tag>voice book</tag>
      </tags>
  </entry>
  <entry>
    <title>[啟發] 高手的學習方法 (一) | Master Learning Methods Part I</title>
    <url>/2020/02/12/%E5%95%9F%E7%99%BC-%E9%AB%98%E6%89%8B%E7%9A%84%E5%AD%B8%E7%BF%92%E6%96%B9%E6%B3%95-%E4%B8%80-Master-Learning-Methods-Part-I/</url>
    <content><![CDATA[<h1 id="啟發-高手的學習方法-一-Master-Learning-Methods-Part-I"><a href="#啟發-高手的學習方法-一-Master-Learning-Methods-Part-I" class="headerlink" title="[啟發] 高手的學習方法 (一) | Master Learning Methods Part I"></a>[啟發] 高手的學習方法 (一) | Master Learning Methods Part I</h1><p>Status: Published</p>
<p>學習是我們常常提到的詞，有人認為它很簡單，有人覺得它很難，有人認為它寫讀書，也有人認為它無所不在，有人在大學畢業時就停止了，有人決心要堅持一輩子。對我而言，我認為學習是終身的課題，學習更要有系統性，對於不同的學階段和狀態要給予不同學習方針。</p>
<p>萬維鋼老師是我在&lt;得到 app&gt;，follow的第二個導師，也是因為這篇統整學習的方法，讓我決定訂閱精英日課第二季。</p>
<p><img src="Untitled.png" alt="Untitled.png"></p>
<hr>
<h2 id="學習三個層次"><a href="#學習三個層次" class="headerlink" title="學習三個層次"></a>學習三個層次</h2><p>心理學家把人對外界的感知分為三層區域，先要對自已了解，才對面外</p>
<ul>
<li>「舒適區」是最裡面也是第一層，是我們熟悉的事物</li>
<li>「恐慌區」是最外面一層，它等於是我們完全陌生的事物</li>
<li>「學習區」是在舒適區和恐慌區之間，既有熟悉，又有新意</li>
</ul>
<p><img src="Untitled1.png" alt="Untitled1.png"></p>
<p>Img from <a href="https://satdharma.com/beyondego-new/subconscious-training/" target="_blank" rel="noopener">satdarma.com</a></p>
<h2 id="從認知科學角度出發"><a href="#從認知科學角度出發" class="headerlink" title="從認知科學角度出發"></a>從認知科學角度出發</h2><p>人腦學習新技能時，是發生在神經元這個層面的。</p>
<p>因為練習了一個動作，會觸發經常一起被使用神經元，最後就會長在一起，因此一個技能的形成可以解釋為</p>
<blockquote>
<p>神經元整個<strong><em>網絡</em></strong>結構長好 了，就相當於一個技能長在了你的大腦之中</p>
</blockquote>
<p><img src="Untitled2.png" alt="Untitled2.png"></p>
<p>最初僅有cell body漸漸會有dedrites(樹突)和axon(軸突)，可以是輸入也可以向外延伸至別的神經元</p>
<p>刻意練習的一個關鍵，就是要脫離「舒適區」，只在壓力狀態下做事。因為成長來自打擊，技藝來自鬥爭。嘗試、失敗，再嘗試、再失敗經過不斷循環，直到掌握為止，我們要的就是這樣“有成效的失敗”，失敗為成功之母就是這個道理。<br>而且，我們不但應該在「學習區」練習，且應該在學習區研究、工作和娛樂。另外如果你要提昇自已，就需要把自已放學習區和恐慌區的邊界。</p>
<h2 id="我們該如何學習？"><a href="#我們該如何學習？" class="headerlink" title="我們該如何學習？"></a>我們該如何學習？</h2><p>關鍵的一點，就是你要敢於從「舒適區」往外走一 步，但是還不能走得太遠。面對這個世界你不 「能一味迎合，你要敢於任性地加入一點新東西，但是為了你自己的安全起見，也不要太新！加過量了。不但學習新技能應該這樣，平時工作也應該這樣。心理學家契克森米哈賴說，想要達到<a href="https://zh.wikipedia.org/wiki/%E5%BF%83%E6%B5%81%E7%90%86%E8%AB%96" target="_blank" rel="noopener">「心流狀態</a>」，需要這個<em>工作帶點難度和你的技能正好配得上，</em>技能低工作難，你就會焦慮；技能高工作簡單，你就會無聊。</p>
<blockquote>
<p>正確的「心流」是工作難度稍微比你的技能高一點點，你歷經一番忘我的掙扎把它完成。這樣你不但做事做得有意思、感到時間過得特別快，而且還能不斷提高水平。</p>
</blockquote>
<h2 id="學習千萬不能”只進不出”"><a href="#學習千萬不能”只進不出”" class="headerlink" title="學習千萬不能”只進不出”"></a>學習千萬不能”只進不出”</h2><p>你可能會說，我是在「學習區」，學了，背了，但是啥也沒記住，這不是白學了?<br>其實，人的記憶有兩個強度：</p>
<ul>
<li>存儲強度 (storage strength)</li>
<li>提取強度 (retrieval strength)</li>
</ul>
<p><img src="Untitled3.png" alt="Untitled3.png"></p>
<p>提取記憶和記憶的存儲有正相關，提取越多更有機會存進長期記憶</p>
<ul>
<li><p>img</p>
<p>  <img src="Untitled4.png" alt="Untitled4.png"></p>
<p>  <img src="Untitled5.png" alt="Untitled5.png"></p>
<p>  <img src="Untitled6.png" alt="Untitled6.png"></p>
<p>  <img src="Untitled7.png" alt="Untitled7.png"></p>
</li>
</ul>
<p>存儲強度不會隨時間減弱(這點很重要)！我們每時每刻都在接收大量的信息，而其中的絕大部分都被大腦自動忽略了。這些被忽略的不算。那些剩下來的，是你主動希望記住的東西 ，比如說 一個人名，一個電話號碼或是一個英語單字。</p>
<p>一旦進入記憶，就永遠在那裡了。下次再見到它，它在你大腦裡的存<strong>儲強度會增強</strong>， 但是哪怕你再也不見它了，它的存儲強度也不會減弱。<em>存儲強度只增不減</em>。那麼為什麼我們會忘記東西呢？</p>
<blockquote>
<p>那是提取強度出了問題。如果沒有復習跟練習，提取強度就隨著時間慢慢減弱<br>所以，學習不能一昧到倒東西進腦袋，一定要適時思考跟應用，增加存取頻率。</p>
</blockquote>
<p>下篇會介紹古代偉人思想出發</p>
<p>幫助我們如何學習</p>
<hr>
<h1 id="啟發-高手的學習方法-二-Master-Learning-Methods-Part-II"><a href="#啟發-高手的學習方法-二-Master-Learning-Methods-Part-II" class="headerlink" title="[啟發] 高手的學習方法 (二) | Master Learning Methods Part II"></a>[啟發] 高手的學習方法 (二) | Master Learning Methods Part II</h1><h2 id="長、短期工作記憶"><a href="#長、短期工作記憶" class="headerlink" title="長、短期工作記憶"></a>長、短期工作記憶</h2><p>現在心理學認為人有兩種「工作記憶」。 </p>
<ul>
<li>短期工作記憶：相當於電腦記憶體，是完成一項具體工作的時候大腦隨時使用的記憶。</li>
<li>長期工作記憶：相當於硬碟，是我們平時的知識存儲</li>
</ul>
<p><img src="Untitled8.png" alt="Untitled8.png"></p>
<p>右邊的記憶區分為：長期和短期。二個區塊訊息交流構成不同的工作模式</p>
<p>配合工作記憶，來解釋日常的人們的工作模式非常有趣</p>
<ul>
<li>所謂學習：就是把進入到大腦的短期工作記憶的內容強化吸收，寫進長期工作記憶之中的過程</li>
<li>所謂創新：就是把長期工作記憶中的相關內容調出來，放在短期工作記憶裡跟新信息形成配合的過程</li>
<li>集中思維：就是在此時此刻的短期工作記憶裡強化這個新信息</li>
<li>發散思維：就是短期工作記憶和長期工作記憶之間的通道</li>
</ul>
<p>人腦不像計算機的存儲器能瞬間記錄訊息，大腦是肉長的。</p>
<blockquote>
<p>這就好像砌牆，你有了磚頭和水泥，總要再給點時間讓水泥風乾了，牆才能結實，這個道理就是呼應前篇提到的技能構成，它是由多個神經元網路所構成的，是需要點時間的阿</p>
</blockquote>
<h2 id="平台期，長肌肉時間"><a href="#平台期，長肌肉時間" class="headerlink" title="平台期，長肌肉時間"></a>平台期，長肌肉時間</h2><p>為什麼我們第一次學習新技能的時候總覺得很彆扭，過段時間，哪怕是睡一覺或者隔一天不練，再拿起來感覺反而好多了？！<strong><em>這一小段“不練”的間隔期對大腦非常重要</em></strong>。就好比練舉重，如果你每時每刻都舉重，你的肌肉沒有辦法生長，總要停一段時間長肉。</p>
<p><img src="Untitled9.png" alt="Untitled9.png"></p>
<p>每一個神經元要變成完整的神經網路是要時間的，此時我們稱成<a href="https://www.youtube.com/watch?v=W8_ktKKyW5A" target="_blank" rel="noopener">平台期</a></p>
<p>我們學習各種技能，有時候會遇到一個短暫的<strong><strong>平台期</strong></strong>。比如當年學開車，一開始進步神速，過了一段時間，就感覺有幾天雖然一直在練，但是水平不但沒提高反而還下降了， 怎麼開都彆扭—這就是平台期。這個平台其實是大腦內部正在忙著建立新連接的時期，不是沒有進步，是因為後台正在重組！</p>
<blockquote>
<p>據此我們知道，學習要慢慢來<br>學習知識並不是越快越好。複雜的技能需要時間間隔。</p>
</blockquote>
<h2 id="想記住，先學會忘記"><a href="#想記住，先學會忘記" class="headerlink" title="想記住，先學會忘記"></a>想記住，先學會忘記</h2><p>知道了<a href="https://medium.com/@joehuang_36936/%E5%95%9F%E7%99%BC-%E9%AB%98%E6%89%8B%E7%9A%84%E5%AD%B8%E7%BF%92%E6%96%B9%E6%B3%95-%E4%B8%80-master-learning-methods-part-i-6ae067071794" target="_blank" rel="noopener">上篇</a>提到的提取強度 (retrieval strength)的關系，東西存進腦袋是不會不見的。</p>
<p>即然如此，學習就不是天天都來，應該是用最少的時間學習，如此還能通過遺忘過濾掉一些不必要的信息。</p>
<p>以背單詞為例，這就要求我們</p>
<ul>
<li>第一次復習是在一天之後</li>
<li>第二次就要拉長，比如說再等一周之後</li>
<li>然後是一個月之後</li>
<li>然後是幾個月甚至更長時間</li>
</ul>
<p>有實驗證明，哪怕第一次復習是在兩個月之後，你感覺什麼都不記得了，其實還是能找到一點印象，這種學法還是有效的！</p>
<p>所以要想記住，最好先忘了。從這個角度講，慢慢學才是好辦法。這週學了一點就放下，下週接著學得先提取一下前面的記憶，這樣多次提取，記憶就加深了很多。交叉著在同一時期內學習幾門課程，比學完一門再學另一門的效果好得多。</p>
<h2 id="莊子-無為的狀態"><a href="#莊子-無為的狀態" class="headerlink" title="莊子 | 無為的狀態"></a>莊子 | 無為的狀態</h2><p>忘記的功夫。修煉這個“忘記”的功夫，咱們得學學莊子。那麼身一位有學問的現代人，應該怎麼達到莊子無為的境界呢?</p>
<p><img src="Untitled10.png" alt="Untitled10.png"></p>
<p>孔子、老子、孟子和莊子，給我們提供了四種路徑方法，每個人應該根據自己的性格喜好選擇不同的方法，而且在人生的不同階段，也可以使用不同的方法。</p>
<ul>
<li>孔子的思想應用：<br>在學習任何技能的初期，我們應該用孔子的辦法，勤學苦練，搞沉浸式的教育體驗，爭取習慣成自然。</li>
<li>老子的思想應用：<br>具體做事的時候，尤其是要做那些能夠影響別人的大事，我們應該參考老子的思想，不輕易干擾複雜系統。</li>
<li>孟子的想思應用：<br>培養藝術品位，提昇道德水準，我們可以用孟子的辦法，找到身上的閃光點作為種子，慢慢發展壯大。</li>
<li>莊子的想思應用：<br>如果面對一項壓力巨大而又特別重要的工作，我們就應該學習莊子，忘記自我，讓熱認知引導我們發揮水平。</li>
</ul>
<blockquote>
<p>這四派武功，你只有實踐了，才知道那到底是什麼境界<br>正所謂運用之妙，存乎一心。</p>
</blockquote>
<h2 id="結論："><a href="#結論：" class="headerlink" title="結論："></a>結論：</h2><p>讀完二篇的介紹，首先要清楚自已的學習區間，也就是「舒適區」、「學習區」與「恐慌區」。再來就是要懂得復習跟思考，這個手段就是增強我們的提取記憶，目的則是把短期記憶推展到長期記憶成生技能的一部份。</p>
<p>古人的思想這些手段的確是互相矛盾的，但世界本來就充滿矛盾且復雜。無為，本來就是一個悖論：你越想得到無為，你就越得不到無為。不過真正的高手是能善用策略面對不同的學習。</p>
<h2 id="References："><a href="#References：" class="headerlink" title="References："></a>References：</h2><ol>
<li>&lt;得到app&gt; 萬維鋼 | 精英日課第二季</li>
<li><a href="https://www.youtube.com/watch?v=W8_ktKKyW5A" target="_blank" rel="noopener">Neural Networks 3: axons, dendrites, synapses</a></li>
<li><a href="https://www.allaboutcircuits.com/news/artificial-neural-network-how-ANN-change-research-engineering/" target="_blank" rel="noopener">Artificial Neural Network Roundup: How ANNs Are Changing the Way We Research (and Engineer)</a></li>
</ol>
]]></content>
      <categories>
        <category>啟發</category>
      </categories>
      <tags>
        <tag>得到App</tag>
        <tag>voice book</tag>
        <tag>萬維鋼</tag>
      </tags>
  </entry>
  <entry>
    <title>[科學] 學佛是真的 | Through Psychology Explain Buddhism</title>
    <url>/2020/02/12/%E7%A7%91%E5%AD%B8-%E5%AD%B8%E4%BD%9B%E6%98%AF%E7%9C%9F%E7%9A%84-Through-Psychology-Explain-Buddhism/</url>
    <content><![CDATA[<h1 id="科學-學佛是真的-Through-Psychology-Explain-Buddhism"><a href="#科學-學佛是真的-Through-Psychology-Explain-Buddhism" class="headerlink" title="[科學] 學佛是真的 | Through Psychology Explain Buddhism"></a>[科學] 學佛是真的 | Through Psychology Explain Buddhism</h1><p>今天的分享來自&lt;得到 App&gt; 萬維鋼 | 精英日課 ，透過進化心理學列出七大模塊，事實是他們輪流坐莊來決定當下我的個體，再進一步解釋，其實”我”的本體，不屬於任何一個情感模塊。</p>
<p><img src="Untitled.png" alt="Untitled.png"></p>
<h2 id="▌進化心理學"><a href="#▌進化心理學" class="headerlink" title="▌進化心理學"></a>▌進化心理學</h2><p>▌實驗一</p>
<p>心理學有個動詞叫“prime”，也就是用一些外部的暗示去影響一個人的決策。比如說：給男性受試者看美女圖，會開啟了他大腦中的“求偶模塊。在漫長的人類歷史中，男性想要獲得配偶，就得拿出資源來。求偶模塊在我們大腦中根深蒂固，一旦這個模塊出來做主，它就要求趕緊得到資源。</p>
<p>▌實驗二<br>還有一個更有意思的實驗，也是針對男性</p>
<p>實驗把受試者分為兩組分別看電影。第一組看恐怖片，第二組看的是浪漫愛情喜劇。看完電影之後，又給受試者們看兩個藝術博物館的廣告。</p>
<ul>
<li>廣告一：宣傳點是這個藝術博物館為普羅大眾都喜好的展覽</li>
<li>廣告二：宣傳點則是這個博物館非等閒之輩來欣賞，你來就能彰顯你與眾不同的品位</li>
</ul>
<p><img src="Untitled1.png" alt="Untitled1.png"></p>
<p>那麼，剛才看的電影，對現在你對博物館的選擇有什麼影響嗎？</p>
<p>結果是，一開始看恐怖片的人更容易受到第一條廣告的影響，他們更願意去一個去的<strong><em>人多的博物館</em></strong>。而看浪漫片的人更容易受到第二條廣告的影響，<strong><em>他們想去一個人少的博物館</em></strong>。</p>
<blockquote>
<p>這是因為恐怖片和浪漫片開啟了你大腦中不同的<strong>模塊</strong>。恐怖片開啟的模塊叫<strong>“自我保護”</strong>，它想讓你和其他人在一起抱團取暖，所以你就要去到人多的地方。浪漫片則開啟的是前面說的 <strong>“求偶模塊”</strong>，它會讓你更願意找一個私密的地</p>
</blockquote>
<h2 id="▌七個思想模塊"><a href="#▌七個思想模塊" class="headerlink" title="▌七個思想模塊"></a>▌七個思想模塊</h2><p>那麼在腦中到底有多少模塊呢？<br>進化心理學家&lt;Douglas T. Kenrick/ Vladas Griskevicius&gt;，寫了一本書《理性動物》<br>共提供了七個思想模塊</p>
<ol>
<li>自我保護：讓你和其他人在一起抱團取暖，避免一個人獨處</li>
<li>求偶模塊：積極尋找資源展開行動</li>
<li>保住配偶：也就是防止配偶跟別人跑了, 這個模塊一旦開啟，人的注意力就不是在異性上，而是在潛在的同性競爭對手上<br>了</li>
<li>群體認同感：希望加入組織,獲得社交和團隊合作</li>
<li>關愛親屬：保護自己的孩子和父母、兄弟</li>
<li>社會地位：一種自我屬為社會認同</li>
<li>避免疾病：我們看到不乾淨的東西會感到噁心，且喜歡舒適的環境</li>
</ol>
<p><img src="Untitled2.png" alt="Untitled2.png"></p>
<p>Renovating the Pyramid of Needs: Contemporary Extensions Built Upon Ancient Foundations</p>
<p>現今的 <strong>“模塊說”</strong> 基本上是學界的一個共識，它是主流的學說之一。這些模塊是在長期進化過程中，我們大腦中一直存在的。只要人一出生，大腦就已經<strong>“預裝”</strong>了這些模塊。即使一個沒有受過任何教育的人，見到美麗異性也想追求、看到髒亂差環境也會反感。<br>但是請注意，模塊只是邏輯分類，並不是說大腦中有哪個區域負責哪個模塊。這些模塊之間也並不存在明顯的分界線，不像你手機裡的 APP 一樣，想用哪個程式就把它調出來，不用時就關閉這個再打開另一個。</p>
<blockquote>
<p>模塊之間有互相影響，而且無縫切換<br>常常一個模塊還沒結束,，另一個模塊就已經啟動了。<br>而我們大腦的決策權(心智)，基本上就被這些模塊輪流主導，也是腦中主要胡思亂想的來源</p>
</blockquote>
<h2 id="▌自由意志在哪裡"><a href="#▌自由意志在哪裡" class="headerlink" title="▌自由意志在哪裡?"></a>▌自由意志在哪裡?</h2><p>人腦不是君主制，而是一個<strong>“多元政體”</strong>。意思就是每個模塊都可以<strong>暫時接管你的大腦，輪流坐莊</strong>，各個模塊之間是存有互相競爭的關係。這種模型是近年以來心理學家對大腦最新的一個理解。其實這個道理就像是，人的腦中並不是只有一種聲音，人腦內其實有時常有爭論。著名迪事尼的卡通《腦筋急轉彎》，其實說的就是這個模型，說不定原著也是先了解進化心理學，再創作此作品呢</p>
<p><img src="Untitled3.png" alt="Untitled3.png"></p>
<h2 id="▌佛：五蘊皆空、無我"><a href="#▌佛：五蘊皆空、無我" class="headerlink" title="▌佛：五蘊皆空、無我"></a>▌佛：五蘊皆空、無我</h2><p><a href="https://www.books.com.tw/products/0010801330" target="_blank" rel="noopener">《未來簡史》</a>書中也有提到這個道理。如果是各個模塊輪流坐莊。</p>
<p>那麼第一，你沒有單一的<strong>“自我”；</strong>第二，你沒有<strong>“自由意志”</strong>。你的行動只是被這些模塊推來推去而 已。常常是某個模塊已經控制你了、已經讓你「做好決定了，事後，你才<strong>“意識到”</strong>你做出了這個決定，然後你的敘事自我還要給這個決定編個理由。</p>
<blockquote>
<p>模塊佔據你大腦的方法，是感情。<br>每個模塊都向你輸出一個感情，哪個感情強，哪個就容易抓住你的注意力。<br>這就好比你身處一大幫朋友和同事之間，他們每個人都在跟你說話，且都想讓你照他們說的話做，其中誰說話的聲音大，誰就更能吸引到你的注意力，此時你就容易聽誰的。</p>
</blockquote>
<p>如果你有打坐冥想的經驗，不但<strong>感情是這樣，思想也是這樣</strong>。比如你現在想要把注意力都集中在你的呼吸上，只體會自己的一呼一吸。你就會發現，你根本沒辦法長時間地集中注意力，很多想法就會不斷地冒出來一這些想法，也是從各個模塊中冒出來。</p>
<p><img src="Untitled4.png" alt="Untitled4.png"></p>
<blockquote>
<p>每次激起的模塊還根本不靠譜，而你常常被“他們”迷惑，影響思想和行為，但他們不是<strong><em>“你”</em></strong>，這正是佛陀說的“五蘊皆空”和 “無我”。</p>
</blockquote>
<p>看到這裡，你聽懂了嗎？因為沒有任何一個模塊是真正的自已</p>
<h2 id="▌修行，戰勝模塊-情感"><a href="#▌修行，戰勝模塊-情感" class="headerlink" title="▌修行，戰勝模塊(情感)"></a>▌修行，戰勝模塊(情感)</h2><p>但是佛陀，可不是這麼絕望的。佛陀說你可以通過修行，戰勝那些模塊，找回掌握控制權，擁有自由意志(尋找清淨)。</p>
<p>萬老師的比喻很妙：「這就好像一屋子的人都在讓你幹這幹那，而你非常酷，直接忽視大部分人的聲音， 自己選擇了對你最有利的意見——哪怕他的聲音很微弱」。</p>
<h2 id="▌結論"><a href="#▌結論" class="headerlink" title="▌結論"></a>▌結論</h2><p>很多時候常思考，我為什麼是我？至今30多歲，那個歲數的我，比較能代表真正的我？如果你曾思考過類似問題，不妨接受這個<strong>心理學推論</strong>，你本來就沒有屬於任於一個模塊。如果人沒有恆定的自我，你在不同時刻， 其實是被不同的思維模塊所左右而已。佛陀認為，你可以通過修行，戰勝那 些思維模塊，掌握控制權，擁有自由意志，這邊談到的自由意思，其實是空、是無我、是本來沒有我，正是六祖禪師說的：「本來無一物，何處惹塵埃」。</p>
<hr>
<blockquote>
<p>謝謝你的閱讀！我是黃大仙。<br>都市修行人 / 雲端架構師 / GCP講師 / 新手爸爸<br>喜歡研究不同領域事物，誠摯邀請一同交流學習！📒<br>如果有任何疑問，歡迎留下 Private Note 或留言給我！📒<br>👏1下——–給我一點鼓勵。<br>👏2~10下—–文章對你有幫助。<br>👏50下——-有興趣看「閱讀分享」相關的分享。</p>
</blockquote>
<p>謝謝你的閱讀！我是黃大仙。</p>
<p>都市修行人 / 雲端架構師 / GCP講師 / 新手爸爸</p>
<p>喜歡研究不同領域事物，誠摯邀請一同交流學習！📒</p>
<p>如果有任何疑問，歡迎留下 Private Note 或留言給我！📒</p>
<p>👏1下——–給我一點鼓勵。</p>
<p>👏2~10下—–文章對你有幫助。</p>
<p>👏50下——-有興趣看「閱讀分享」相關的分享。</p>
]]></content>
      <categories>
        <category>啟發</category>
      </categories>
      <tags>
        <tag>得到App</tag>
        <tag>voice book</tag>
        <tag>萬維鋼</tag>
      </tags>
  </entry>
  <entry>
    <title>[科技] 5G誰會最大贏家？| The Latest Winner in 5G Generation</title>
    <url>/2020/02/12/%E7%A7%91%E6%8A%80-5G%E8%AA%B0%E6%9C%83%E6%9C%80%E5%A4%A7%E8%B4%8F%E5%AE%B6%EF%BC%9F-The-Latest-Winner-in-5G-Generation/</url>
    <content><![CDATA[<h1 id="科技-5G誰會最大贏家？-The-Latest-Winner-in-5G-Generation"><a href="#科技-5G誰會最大贏家？-The-Latest-Winner-in-5G-Generation" class="headerlink" title="[科技] 5G誰會最大贏家？| The Latest Winner in 5G Generation"></a>[科技] 5G誰會最大贏家？| The Latest Winner in 5G Generation</h1><p>Blog URL: <a href="https://drive.google.com/drive/folders/1b0SSbMex7Z5_a2Nqwj3BETH4bbJfG6Qd" target="_blank" rel="noopener">https://drive.google.com/drive/folders/1b0SSbMex7Z5_a2Nqwj3BETH4bbJfG6Qd</a><br>Status: Published</p>
<p>今天的分享主來自&lt;得到 App&gt; 吳軍 |  前沿科技，談的是5G誰是大贏。在開始之前先用通信歷史來鋪陳，談到過去什麼是高大尚的產品，後來沒有競爭力失去光環。文後也提供解方：鼓勵透過”信息熵”來做批判性思考，認為5G的未是必靠網路的大融合</p>
<p><img src="Untitled.png" alt="Untitled.png"></p>
<h2 id="▌用歷史看5G：從Internet-→-moblie-→-5G-IoT"><a href="#▌用歷史看5G：從Internet-→-moblie-→-5G-IoT" class="headerlink" title="▌用歷史看5G：從Internet → moblie → 5G + IoT"></a>▌用歷史看5G：從Internet → moblie → 5G + IoT</h2><p>走過網際網路時代，設備製造商，包括生產手機的和通信設備商，其實都已經賺了個盆滿缽滿。僅 華為一家，2018年的營業額就超過了千億美元，幾乎抵得上我們所說的BAT(Baidu, Alibaba, Tencent)三家的總和。</p>
<p>Apple也是靠著手機成為了全球收入最高且最賺錢的公司。在此之前網路時代剛來臨時，網絡設備製造商Cisco曾經是全球最為炙手可熱的公司。每個大時代下都會有相應因的巨頭產生 ，因此，5G時代在未來也同樣會出現大量的製造IoT設備的企業，成為5G的贏家。</p>
<p>但是，這裡面可能有一個”坑”，大家要非常小心。</p>
<blockquote>
<p>那就是不具有太多技術含量的所謂智慧硬體其實不值錢，比如說，製造低端傳感器的企業，製造非智能攝影機的企業，製造RFID晶片和讀寫器的企業，等等。</p>
</blockquote>
<h2 id="▌它是不是只有充電器等級？"><a href="#▌它是不是只有充電器等級？" class="headerlink" title="▌它是不是只有充電器等級？"></a>▌它是不是只有充電器等級？</h2><p>這個<strong>“坑”</strong>是什麼？這些企業就如同在 PC時代製造機箱或電源供應器，智慧手機時代，製造充電器的企業一樣。當這些低端硬體數量增加後，單個產品的價格還會下降。20年前你看那些產品和技術覺得很高大上，5年後它們就是<strong><em>充電器的技術含量</em></strong>。在前兩代網路發展中受益的設備製造商，都是做系統的。那為什麼要做系統呢?</p>
<blockquote>
<p>做好一個系統是有難度的，因為系統的表現不等於部分之和， 只有那些有本事做到整體大於部分和的企業， 才能在系統這個層面贏得競爭力。</p>
</blockquote>
<p>今天這個趨勢其實已經可以看出點端倪，中國過去有不少生產普通攝影機的企業，都沒有受益於中國監控產業的發展，它們甚至將攝影機白白送給銀行或者一些要驗證身份的企業使用，以換取極微薄的服務費或者一點點數據。</p>
<p>而真正掙到錢，而且受到資本市場追捧的，<strong><em>是製造具有目標識別功能的智慧攝影機的企業</em></strong>。一個智慧攝像頭的價格，是普通攝影機的50倍阿！</p>
<p><img src="Untitled1.png" alt="Untitled1.png"></p>
<h2 id="▌不敗公式：有效率的能量轉換"><a href="#▌不敗公式：有效率的能量轉換" class="headerlink" title="▌不敗公式：有效率的能量轉換"></a>▌不敗公式：有效率的能量轉換</h2><p>那麼未來這些應用會圍繞怎樣一個核心展開呢？簡單地講用<a href="https://zh.wikipedia.org/wiki/%E7%86%B5_(%E4%BF%A1%E6%81%AF%E8%AE%BA)" target="_blank" rel="noopener">&lt;</a><a href="https://zh.wikipedia.org/wiki/%E7%86%B5_(%E4%BF%A1%E6%81%AF%E8%AE%BA)https://zh.wikipedia.org/wiki/%E7%86%B5_(%E4%BF%A1%E6%81%AF%E8%AE%BA)" target="_blank" rel="noopener">信息熵 | entropy&gt;</a>解說，智能化和以訊息的使用<strong><em>換取能量的節省</em></strong>依然會是主旋律！我們不妨看看今天移動通信的很多應用，比如</p>
<ul>
<li>滴滴打車、Uber Eat，大家都是利用訊息 → 節省體力</li>
<li>美圖秀秀代替Photoshop，另外帶超大廣角的相機代替自拍棒 → 節省空間</li>
</ul>
<p>以上都是讓計算機變得更有智慧，來減少我們的工作(能量)。<br>如果你能開發一個新的5G商業模式，可以有效率的做能量轉換那麼就有機會突圍成功</p>
<p><a href="https://www.youtube.com/watch?v=13T7bVHU1a4" target="_blank" rel="noopener">https://www.youtube.com/watch?v=13T7bVHU1a4</a></p>
<p>另一個酷的實例：Verizon 和 SONY Ericsson 的5G合作</p>
<p>跑車100%遮敝玻璃，賽車手僅使用Real time 畫面傳送賽道 → 未來可實現遠端駕駛</p>
<blockquote>
<p>而真正能讓5G發機的時刻，是5G的網絡大融合。簡單說就是讓LAN+WAN合為一體，透過這個概念去開發出你們的產品和服務！</p>
</blockquote>
<h2 id="▌5G市場的規模，未來可以達一個日本的GDP"><a href="#▌5G市場的規模，未來可以達一個日本的GDP" class="headerlink" title="▌5G市場的規模，未來可以達一個日本的GDP"></a>▌5G市場的規模，未來可以達一個日本的GDP</h2><p>事實上從2015年至今， 電信服務的收入一直在兩萬億美元左右徘徊， 設備製造企業的收入看似在增加， 但真正增加較快的只有華為和中國的幾家手機廠， 即使是過去增長率很高的蘋果， 現在也停滯了。相比之下， 全世界網際網路產業直到今天依然有每年將近20%的增長就顯得特別亮眼。</p>
<p>那麼將來有了5G和IoT之後， 市場規模能達到多大呢?最保守的估計， 到2030年， 可以在今天網路和電信市場規模的基礎上翻一番， 也就是說達到8萬億美元以上， 或者說， 造就出一個4萬億美元的新的市場。 4萬億美元的市場規模有多大呢？比今天「日本」的GDP略小些， 比「德國」大一些。</p>
<p>那麼這個目標能否達成呢？如果我們分解一 下，就是每年增長6%，要求並不高。但是， <strong><em>如果沒有在5G時代網路產業和電信產業的融合，這個每年6%的目標還真達不到</em></strong>，因為在4G時代的最近幾年，電信產業是沒有增長的，因為它搭不上移動網路發展的快車，而網際網路又難以利用電信很大的基數。</p>
<p>其實我們可以看一看在整個4G時代，電信運營商除了幫助我們把網速提高了，是否還給我們帶來了什麼增值服務嗎？其實沒有…</p>
<blockquote>
<p>如果到了5G時代，當你家裡的網路和外面的移動網路合二為一時，電信企業就能夠依靠計算機企業的技術力量提供新的加增服務了，當然它們也就為計算機企業提供了一個更大的發展空間。</p>
</blockquote>
<p><img src="Untitled2.png" alt="Untitled2.png"></p>
<p>5G的普及將會是打破LAN, MAN, WAN</p>
<p>因此，在未來，網路的融合不僅是技術發展的結果，也是產業發展的需要。這時候產業的格局也就完全改變了。如果哪一天Google或者亞馬遜成為了一家電信企業，大家不必奇怪。</p>
<p>如果我們回顧一下早期計算機產業軟硬體的發展，就會發現一個相似之處。當時硬體企業產值高，但是因為摩爾定律的作用，價格不可能上漲，因此銷售額沒有增長，而軟軟產業利潤率很高，增長很快，但是盤子很小。</p>
<p>在移動網路時代，軟硬體產業開始融合，世界上主要的IT企業今天既生產硬體，也開發軟軟，於是它們的銷售額和利潤都快速增長。其中最典型的就是蘋果公司，你很難說它是硬體或是軟體公司</p>
<h2 id="▌結論："><a href="#▌結論：" class="headerlink" title="▌結論："></a>▌結論：</h2><p>在未來，大國之間的競爭力，在某種方面體現在誰能將這兩個產業融合好。總論一下在5G時代，大家不妨利用能量和訊息論，考慮一下自己未來的選擇</p>
<ol>
<li><p>巨大規模的市場機會，關鍵在於網路的融合</p>
</li>
<li><p>沒有技術含量的簡單產品沒有機會，系統級的創新才有。</p>
</li>
</ol>
<hr>
<blockquote>
<p>謝謝你的閱讀！我是黃大仙。<br>都市修行人 / 雲端架構師 / GCP講師 / 新手爸爸<br>喜歡研究不同領域事物，誠摯邀請一同交流學習！📒<br>如果有任何疑問，歡迎留下 Private Note 或留言給我！📒<br>👏1下——–給我一點鼓勵。<br>👏2~10下—–文章對你有幫助。<br>👏50下——-有興趣看「閱讀分享」相關的分享。</p>
</blockquote>
]]></content>
      <categories>
        <category>啟發</category>
      </categories>
      <tags>
        <tag>得到App</tag>
        <tag>吳軍</tag>
        <tag>voice book</tag>
      </tags>
  </entry>
</search>
